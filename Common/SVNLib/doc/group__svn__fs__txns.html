<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Subversion: Filesystem transactions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Filesystem transactions<br>
<small>
[<a class="el" href="group__fs__handling.html">Filesystem interaction subsystem</a>]</small>
</h1>Filesystem Transactions.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__begin__txn2__flags.html">Bitmask flags for svn_fs_begin_txn2()</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of a Subversion transaction object.  <a href="#ge0ac340327051a48262d7442b5a3a873"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__txns.html#g2fa27aba3d45db58c8889beda852fed9">svn_fs_begin_txn2</a> (<a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> **txn_p, <a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> rev, apr_uint32_t flags, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin a new transaction on the filesystem <em>fs</em>, based on existing revision <em>rev</em>.  <a href="#g2fa27aba3d45db58c8889beda852fed9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__txns.html#g5f3d23248081c14a10f72034bae82848">svn_fs_begin_txn</a> (<a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> **txn_p, <a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> rev, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="group__svn__fs__txns.html#g2fa27aba3d45db58c8889beda852fed9" title="Begin a new transaction on the filesystem fs, based on existing revision rev.">svn_fs_begin_txn2()</a>, but with <em>flags</em> set to 0.  <a href="#g5f3d23248081c14a10f72034bae82848"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__txns.html#ge86163e9e3623168cee620446a40e755">svn_fs_commit_txn</a> (const char **conflict_p, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *new_rev, <a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> *txn, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit <em>txn</em>.  <a href="#ge86163e9e3623168cee620446a40e755"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__txns.html#g3854fdae3fed37d82514183b061f7c16">svn_fs_abort_txn</a> (<a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> *txn, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abort the transaction <em>txn</em>.  <a href="#g3854fdae3fed37d82514183b061f7c16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__txns.html#g1b7d6f51cfbe7083fb11937c0abeaa28">svn_fs_purge_txn</a> (<a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, const char *txn_id, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cleanup the dead transaction in <em>fs</em> whose ID is <em>txn_id</em>.  <a href="#g1b7d6f51cfbe7083fb11937c0abeaa28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__txns.html#g023643006df41c54ac79376f3a6101ee">svn_fs_txn_name</a> (const char **name_p, <a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> *txn, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*name_p</em> to the name of the transaction <em>txn</em>, as a NULL-terminated string.  <a href="#g023643006df41c54ac79376f3a6101ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__txns.html#gf10904f009ec2136304acf11017f67f2">svn_fs_txn_base_revision</a> (<a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> *txn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <em>txn's</em> base revision.  <a href="#gf10904f009ec2136304acf11017f67f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__txns.html#g18241d3755602b52f2ccd0c6c68118f1">svn_fs_open_txn</a> (<a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> **txn, <a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, const char *name, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open the transaction named <em>name</em> in the filesystem <em>fs</em>.  <a href="#g18241d3755602b52f2ccd0c6c68118f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__txns.html#ga53bc028497b6468ae4cdb2347e8d8b0">svn_fs_list_transactions</a> (apr_array_header_t **names_p, <a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*names_p</em> to an array of <code>const char *</code> ids which are the names of all the currently active transactions in the filesystem <em>fs</em>.  <a href="#ga53bc028497b6468ae4cdb2347e8d8b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__txns.html#gbced341c635f385b663af51fee1e289d">svn_fs_txn_prop</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **value_p, <a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> *txn, const char *propname, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*value_p</em> to the value of the property named <em>propname</em> on transaction <em>txn</em>.  <a href="#gbced341c635f385b663af51fee1e289d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__txns.html#g035aeb24035a350c6d5ec8a81a636994">svn_fs_txn_proplist</a> (apr_hash_t **table_p, <a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> *txn, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*table_p</em> to the entire property list of transaction <em>txn</em>, as an APR hash table allocated in <em>pool</em>.  <a href="#g035aeb24035a350c6d5ec8a81a636994"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__txns.html#g2e9673e36aec896dae01a6c31787bcd6">svn_fs_change_txn_prop</a> (<a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> *txn, const char *name, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change a transactions <em>txn's</em> property's value, or add/delete a property.  <a href="#g2e9673e36aec896dae01a6c31787bcd6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__txns.html#gd73ecc9b8b7b18e3e97f024f73daa6b1">svn_fs_change_txn_props</a> (<a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> *txn, apr_array_header_t *props, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change, add, and/or delete transaction property values in transaction <em>txn</em>.  <a href="#gd73ecc9b8b7b18e3e97f024f73daa6b1"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Filesystem Transactions. 
<p>
To make a change to a Subversion filesystem:<ul>
<li>Create a transaction object, using <a class="el" href="group__svn__fs__txns.html#g5f3d23248081c14a10f72034bae82848" title="Same as svn_fs_begin_txn2(), but with flags set to 0.">svn_fs_begin_txn()</a>.</li><li>Call <a class="el" href="group__svn__fs__roots.html#ga7420b1ecb9c73f62cbb0d5f22963cdf" title="Set *root_p to the root directory of txn.">svn_fs_txn_root()</a>, to get the transaction's root directory.</li><li>Make whatever changes you like in that tree.</li><li>Commit the transaction, using <a class="el" href="group__svn__fs__txns.html#ge86163e9e3623168cee620446a40e755" title="Commit txn.">svn_fs_commit_txn()</a>.</li></ul>
<p>
The filesystem implementation guarantees that your commit will either:<ul>
<li>succeed completely, so that all of the changes are committed to create a new revision of the filesystem, or</li><li>fail completely, leaving the filesystem unchanged.</li></ul>
<p>
Until you commit the transaction, any changes you make are invisible. Only when your commit succeeds do they become visible to the outside world, as a new revision of the filesystem.<p>
If you begin a transaction, and then decide you don't want to make the change after all (say, because your net connection with the client disappeared before the change was complete), you can call <a class="el" href="group__svn__fs__txns.html#g3854fdae3fed37d82514183b061f7c16" title="Abort the transaction txn.">svn_fs_abort_txn()</a>, to cancel the entire transaction; this leaves the filesystem unchanged.<p>
The only way to change the contents of files or directories, or their properties, is by making a transaction and creating a new revision, as described above. Once a revision has been committed, it never changes again; the filesystem interface provides no means to go back and edit the contents of an old revision. Once history has been recorded, it is set in stone. Clients depend on this property to do updates and commits reliably; proxies depend on this property to cache changes accurately; and so on.<p>
There are two kinds of nodes in the filesystem: mutable, and immutable. Revisions in the filesystem consist entirely of immutable nodes, whose contents never change. A transaction in progress, which the user is still constructing, uses mutable nodes for those nodes which have been changed so far, and refers to immutable nodes from existing revisions for portions of the tree which haven't been changed yet in that transaction.<p>
Immutable nodes, as part of revisions, never refer to mutable nodes, which are part of uncommitted transactions. Mutable nodes may refer to immutable nodes, or other mutable nodes.<p>
Note that the terms "immutable" and "mutable" describe whether or not the nodes have been changed as part of a transaction --- not the permissions on the nodes they refer to. Even if you aren't authorized to modify the filesystem's root directory, you might be authorized to change some descendant of the root; doing so would create a new mutable copy of the root directory. Mutability refers to the role of the node: part of an existing revision, or part of a new one. This is independent of your authorization to make changes to a given node.<p>
Transactions are actually persistent objects, stored in the database. You can open a filesystem, begin a transaction, and close the filesystem, and then a separate process could open the filesystem, pick up the same transaction, and continue work on it. When a transaction is successfully committed, it is removed from the database.<p>
Every transaction is assigned a name. You can open a transaction by name, and resume work on it, or find out the name of a transaction you already have open. You can also list all the transactions currently present in the database.<p>
You may assign properties to transactions; these are name/value pairs. When you commit a transaction, all of its properties become unversioned revision properties of the new revision. (There is one exception: the svn:date property will be automatically set on new transactions to the date that the transaction was created, and will be overwritten when the transaction is committed by the current time; changes to a transaction's svn:date property will not affect its committed value.)<p>
Transaction names are guaranteed to contain only letters (upper- and lower-case), digits, `-', and `.', from the ASCII character set.<p>
The Subversion filesystem will make a best effort to not reuse transaction names. The Berkeley DB backend generates transaction names using a sequence, or a counter, which is stored in the BDB database. Each new transaction increments the counter. The current value of the counter is not serialized into a filesystem dump file, so dumping and restoring the repository will reset the sequence and reuse transaction names. The FSFS backend generates a transaction name using the hostname, process ID and current time in microseconds since 00:00:00 January 1, 1970 UTC. So it is extremely unlikely that a transaction name will be reused. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="ge0ac340327051a48262d7442b5a3a873"></a><!-- doxytag: member="svn_fs.h::svn_fs_txn_t" ref="ge0ac340327051a48262d7442b5a3a873" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> <a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type of a Subversion transaction object. 
<p>

<p>Definition at line <a class="el" href="svn__fs_8h-source.html#l00654">654</a> of file <a class="el" href="svn__fs_8h-source.html">svn_fs.h</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g3854fdae3fed37d82514183b061f7c16"></a><!-- doxytag: member="svn_fs.h::svn_fs_abort_txn" ref="g3854fdae3fed37d82514183b061f7c16" args="(svn_fs_txn_t *txn, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_abort_txn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>txn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Abort the transaction <em>txn</em>. 
<p>
Any changes made in <em>txn</em> are discarded, and the filesystem is left unchanged. Use <em>pool</em> for any necessary allocations.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function first sets the state of <em>txn</em> to "dead", and then attempts to purge it and any related data from the filesystem. If some part of the cleanup process fails, <em>txn</em> and some portion of its data may remain in the database after this function returns. Use <a class="el" href="group__svn__fs__txns.html#g1b7d6f51cfbe7083fb11937c0abeaa28" title="Cleanup the dead transaction in fs whose ID is txn_id.">svn_fs_purge_txn()</a> to retry the transaction cleanup. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5f3d23248081c14a10f72034bae82848"></a><!-- doxytag: member="svn_fs.h::svn_fs_begin_txn" ref="g5f3d23248081c14a10f72034bae82848" args="(svn_fs_txn_t **txn_p, svn_fs_t *fs, svn_revnum_t rev, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_begin_txn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> **&nbsp;</td>
          <td class="paramname"> <em>txn_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&nbsp;</td>
          <td class="paramname"> <em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="group__svn__fs__txns.html#g2fa27aba3d45db58c8889beda852fed9" title="Begin a new transaction on the filesystem fs, based on existing revision rev.">svn_fs_begin_txn2()</a>, but with <em>flags</em> set to 0. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000117">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.1 API. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2fa27aba3d45db58c8889beda852fed9"></a><!-- doxytag: member="svn_fs.h::svn_fs_begin_txn2" ref="g2fa27aba3d45db58c8889beda852fed9" args="(svn_fs_txn_t **txn_p, svn_fs_t *fs, svn_revnum_t rev, apr_uint32_t flags, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_begin_txn2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> **&nbsp;</td>
          <td class="paramname"> <em>txn_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&nbsp;</td>
          <td class="paramname"> <em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begin a new transaction on the filesystem <em>fs</em>, based on existing revision <em>rev</em>. 
<p>
Set <em>*txn_p</em> to a pointer to the new transaction. When committed, this transaction will create a new revision.<p>
Allocate the new transaction in <em>pool</em>; when <em>pool</em> is freed, the new transaction will be closed (neither committed nor aborted).<p>
<em>flags</em> determines transaction enforcement behaviors, and is composed from the constants SVN_FS_TXN_* (<code>SVN_FS_TXN_CHECK_OOD</code> etc.).<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If you're building a txn for committing, you probably don't want to call this directly. Instead, call <a class="el" href="group__svn__repos__hook__wrappers.html#gff82acc57f89eb74c4f33071dc820506" title="Same as svn_repos_fs_begin_txn_for_commit2(), but with revprop_table set to a hash...">svn_repos_fs_begin_txn_for_commit()</a>, which honors the repository's hook configurations.</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.2. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2e9673e36aec896dae01a6c31787bcd6"></a><!-- doxytag: member="svn_fs.h::svn_fs_change_txn_prop" ref="g2e9673e36aec896dae01a6c31787bcd6" args="(svn_fs_txn_t *txn, const char *name, const svn_string_t *value, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_change_txn_prop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>txn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change a transactions <em>txn's</em> property's value, or add/delete a property. 
<p>
<em>name</em> is the name of the property to change, and <em>value</em> is the new value of the property, or zero if the property should be removed altogether. Do any necessary temporary allocation in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="gd73ecc9b8b7b18e3e97f024f73daa6b1"></a><!-- doxytag: member="svn_fs.h::svn_fs_change_txn_props" ref="gd73ecc9b8b7b18e3e97f024f73daa6b1" args="(svn_fs_txn_t *txn, apr_array_header_t *props, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_change_txn_props           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>txn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_array_header_t *&nbsp;</td>
          <td class="paramname"> <em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change, add, and/or delete transaction property values in transaction <em>txn</em>. 
<p>
<em>props</em> is an array of <code><a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a></code> elements. This is equivalent to calling svn_fs_change_txp_prop multiple times with the <code>name</code> and <code>value</code> fields of each successive <code><a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a></code>, but may be more efficient. (Properties not mentioned are left alone.) Do any necessary temporary allocation in <em>pool</em>.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge86163e9e3623168cee620446a40e755"></a><!-- doxytag: member="svn_fs.h::svn_fs_commit_txn" ref="ge86163e9e3623168cee620446a40e755" args="(const char **conflict_p, svn_revnum_t *new_rev, svn_fs_txn_t *txn, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_commit_txn           </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>conflict_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *&nbsp;</td>
          <td class="paramname"> <em>new_rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>txn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Commit <em>txn</em>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>You usually don't want to call this directly. Instead, call <a class="el" href="group__svn__repos__hook__wrappers.html#gb93801ca0f62f026b4163307b7eec2c4" title="Like svn_fs_commit_txn(), but invoke the repos&#39;s pre- and post-commit hooks around...">svn_repos_fs_commit_txn()</a>, which honors the repository's hook configurations.</dd></dl>
If the transaction conflicts with other changes committed to the repository, return an <code>SVN_ERR_FS_CONFLICT</code> error. Otherwise, create a new filesystem revision containing the changes made in <em>txn</em>, storing that new revision number in <em>*new_rev</em>, and return zero.<p>
If <em>conflict_p</em> is non-zero, use it to provide details on any conflicts encountered merging <em>txn</em> with the most recent committed revisions. If a conflict occurs, set <em>*conflict_p</em> to the path of the conflict in <em>txn</em>, with the same lifetime as <em>txn</em>; otherwise, set <em>*conflict_p</em> to NULL.<p>
If the commit succeeds, <em>txn</em> is invalid.<p>
If the commit fails, <em>txn</em> is still valid; you can make more operations to resolve the conflict, or call <a class="el" href="group__svn__fs__txns.html#g3854fdae3fed37d82514183b061f7c16" title="Abort the transaction txn.">svn_fs_abort_txn()</a> to abort the transaction.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Success or failure of the commit of <em>txn</em> is determined by examining the value of <em>*new_rev</em> upon this function's return. If the value is a valid revision number, the commit was successful, even though a non-<code>NULL</code> function return value may indicate that something else went wrong. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga53bc028497b6468ae4cdb2347e8d8b0"></a><!-- doxytag: member="svn_fs.h::svn_fs_list_transactions" ref="ga53bc028497b6468ae4cdb2347e8d8b0" args="(apr_array_header_t **names_p, svn_fs_t *fs, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_list_transactions           </td>
          <td>(</td>
          <td class="paramtype">apr_array_header_t **&nbsp;</td>
          <td class="paramname"> <em>names_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*names_p</em> to an array of <code>const char *</code> ids which are the names of all the currently active transactions in the filesystem <em>fs</em>. 
<p>
Allocate the array in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="g18241d3755602b52f2ccd0c6c68118f1"></a><!-- doxytag: member="svn_fs.h::svn_fs_open_txn" ref="g18241d3755602b52f2ccd0c6c68118f1" args="(svn_fs_txn_t **txn, svn_fs_t *fs, const char *name, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_open_txn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> **&nbsp;</td>
          <td class="paramname"> <em>txn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open the transaction named <em>name</em> in the filesystem <em>fs</em>. 
<p>
Set <em>*txn</em> to the transaction.<p>
If there is no such transaction, <code>SVN_ERR_FS_NO_SUCH_TRANSACTION</code> is the error returned.<p>
Allocate the new transaction in <em>pool</em>; when <em>pool</em> is freed, the new transaction will be closed (neither committed nor aborted). 
</div>
</div><p>
<a class="anchor" name="g1b7d6f51cfbe7083fb11937c0abeaa28"></a><!-- doxytag: member="svn_fs.h::svn_fs_purge_txn" ref="g1b7d6f51cfbe7083fb11937c0abeaa28" args="(svn_fs_t *fs, const char *txn_id, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_purge_txn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>txn_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cleanup the dead transaction in <em>fs</em> whose ID is <em>txn_id</em>. 
<p>
Use <em>pool</em> for all allocations. If the transaction is not yet dead, the error <code>SVN_ERR_FS_TRANSACTION_NOT_DEAD</code> is returned. (The caller probably forgot to abort the transaction, or the cleanup step of that abort failed for some reason.) 
</div>
</div><p>
<a class="anchor" name="gf10904f009ec2136304acf11017f67f2"></a><!-- doxytag: member="svn_fs.h::svn_fs_txn_base_revision" ref="gf10904f009ec2136304acf11017f67f2" args="(svn_fs_txn_t *txn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> svn_fs_txn_base_revision           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>txn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return <em>txn's</em> base revision. 
<p>

</div>
</div><p>
<a class="anchor" name="g023643006df41c54ac79376f3a6101ee"></a><!-- doxytag: member="svn_fs.h::svn_fs_txn_name" ref="g023643006df41c54ac79376f3a6101ee" args="(const char **name_p, svn_fs_txn_t *txn, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_txn_name           </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>name_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>txn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*name_p</em> to the name of the transaction <em>txn</em>, as a NULL-terminated string. 
<p>
Allocate the name in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="gbced341c635f385b663af51fee1e289d"></a><!-- doxytag: member="svn_fs.h::svn_fs_txn_prop" ref="gbced341c635f385b663af51fee1e289d" args="(svn_string_t **value_p, svn_fs_txn_t *txn, const char *propname, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_txn_prop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__string__t.html">svn_string_t</a> **&nbsp;</td>
          <td class="paramname"> <em>value_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>txn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>propname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*value_p</em> to the value of the property named <em>propname</em> on transaction <em>txn</em>. 
<p>
If <em>txn</em> has no property by that name, set <em>*value_p</em> to zero. Allocate the result in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="g035aeb24035a350c6d5ec8a81a636994"></a><!-- doxytag: member="svn_fs.h::svn_fs_txn_proplist" ref="g035aeb24035a350c6d5ec8a81a636994" args="(apr_hash_t **table_p, svn_fs_txn_t *txn, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_txn_proplist           </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&nbsp;</td>
          <td class="paramname"> <em>table_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__txns.html#ge0ac340327051a48262d7442b5a3a873">svn_fs_txn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>txn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*table_p</em> to the entire property list of transaction <em>txn</em>, as an APR hash table allocated in <em>pool</em>. 
<p>
The resulting table maps property names to pointers to <code><a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a></code> objects containing the property value. 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 24 16:18:29 2008 for Subversion by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
