<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Subversion: svn_io.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>svn_io.h File Reference</h1>General file I/O for Subversion. <a href="#_details">More...</a>
<p>
<code>#include &lt;apr.h&gt;</code><br>
<code>#include &lt;apr_pools.h&gt;</code><br>
<code>#include &lt;apr_file_io.h&gt;</code><br>
<code>#include &lt;apr_thread_proc.h&gt;</code><br>
<code>#include &quot;<a class="el" href="svn__types_8h-source.html">svn_types.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="svn__error_8h-source.html">svn_error.h</a>&quot;</code><br>

<p>
<a href="svn__io_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__io__dirent__t.html">svn_io_dirent_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents the kind and special status of a directory entry.  <a href="structsvn__io__dirent__t.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An abstract stream of bytes--either incoming or outgoing or both.  <a href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g9a8939b5258b070a48aa1e0cd154909a">svn_read_fn_t</a> )(void *baton, char *buffer, apr_size_t *len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read handler function for a generic stream.  <a href="group__svn__io__byte__streams.html#g9a8939b5258b070a48aa1e0cd154909a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga79398b116a9209eb3a79947a6066f54">svn_write_fn_t</a> )(void *baton, const char *data, apr_size_t *len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write handler function for a generic stream.  <a href="group__svn__io__byte__streams.html#ga79398b116a9209eb3a79947a6066f54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g576facc62f51e98c14cb440df1e58cd9">svn_close_fn_t</a> )(void *baton)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close handler function for a generic stream.  <a href="group__svn__io__byte__streams.html#g576facc62f51e98c14cb440df1e58cd9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e3dd33688b3e75430f4720f4d90c1506"></a><!-- doxytag: member="svn_io.h::svn_io_walk_func_t" ref="e3dd33688b3e75430f4720f4d90c1506" args=")(void *baton, const char *path, const apr_finfo_t *finfo, apr_pool_t *pool)" -->
typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#e3dd33688b3e75430f4720f4d90c1506">svn_io_walk_func_t</a> )(void *baton, const char *path, const apr_finfo_t *finfo, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback function type for <a class="el" href="svn__io_8h.html#cac394a2c49dcfb02b8cda55c9281625" title="This function will recursively walk over the files and directories rooted at dirname...">svn_io_dir_walk()</a>. <br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a78fffc81af962281813070c753d7884">svn_io_file_del_t</a> { <br>
&nbsp;&nbsp;<a class="el" href="svn__io_8h.html#a78fffc81af962281813070c753d788470268318a6e388419ae0e85ab7f7599c">svn_io_file_del_none</a> =  0, 
<br>
&nbsp;&nbsp;<a class="el" href="svn__io_8h.html#a78fffc81af962281813070c753d78846256344ca6b43868daa12365d75834d2">svn_io_file_del_on_close</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="svn__io_8h.html#a78fffc81af962281813070c753d78840f89c57067b563673ea1ec5605c908bd">svn_io_file_del_on_pool_cleanup</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used as an argument when creating temporary files to indicate when a file should be removed.  <a href="svn__io_8h.html#a78fffc81af962281813070c753d7884">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#31ee1827a2b62a2f4a122ef18e378b05">svn_io_check_path</a> (const char *path, <a class="el" href="svn__types_8h.html#c3ca125707a8ca1289c73236b5ce7f9a">svn_node_kind_t</a> *kind, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the <em>kind</em> of <em>path</em>.  <a href="#31ee1827a2b62a2f4a122ef18e378b05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#0f8fdad8dc4fe854ef5b9971f8ab043e">svn_io_check_special_path</a> (const char *path, <a class="el" href="svn__types_8h.html#c3ca125707a8ca1289c73236b5ce7f9a">svn_node_kind_t</a> *kind, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *is_special, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="svn__io_8h.html#31ee1827a2b62a2f4a122ef18e378b05" title="Determine the kind of path.">svn_io_check_path()</a>, but also set *is_special to <code>TRUE</code> if the path is not a normal file.  <a href="#0f8fdad8dc4fe854ef5b9971f8ab043e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#47336875b45ac006d69aef58db4fb5bb">svn_io_check_resolved_path</a> (const char *path, <a class="el" href="svn__types_8h.html#c3ca125707a8ca1289c73236b5ce7f9a">svn_node_kind_t</a> *kind, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="svn__io_8h.html#31ee1827a2b62a2f4a122ef18e378b05" title="Determine the kind of path.">svn_io_check_path()</a>, but resolve symlinks.  <a href="#47336875b45ac006d69aef58db4fb5bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#58df63b2898a8a2a7df988b2d633eb1a">svn_io_open_unique_file2</a> (apr_file_t **f, const char **unique_name_p, const char *path, const char *suffix, <a class="el" href="svn__io_8h.html#a78fffc81af962281813070c753d7884">svn_io_file_del_t</a> delete_when, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a new file (for reading and writing) with a unique name based on utf-8 encoded <em>path</em>, in the same directory as <em>path</em>.  <a href="#58df63b2898a8a2a7df988b2d633eb1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#2384857ad348105316edf6d1036d599f">svn_io_open_unique_file</a> (apr_file_t **f, const char **unique_name_p, const char *path, const char *suffix, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> delete_on_close, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like svn_io_open_unique_file2, but can't delete on pool cleanup.  <a href="#2384857ad348105316edf6d1036d599f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#d11db24f003c6f280e39d3c9675280dc">svn_io_create_unique_link</a> (const char **unique_name_p, const char *path, const char *dest, const char *suffix, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="svn__io_8h.html#2384857ad348105316edf6d1036d599f" title="Like svn_io_open_unique_file2, but can&#39;t delete on pool cleanup.">svn_io_open_unique_file()</a>, except that instead of creating a file, a symlink is generated that references the path <em>dest</em>.  <a href="#d11db24f003c6f280e39d3c9675280dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#94e184ae6677e8b0b4cae0ec145b7b67">svn_io_read_link</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **dest, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*dest</em> to the path that the symlink at <em>path</em> references.  <a href="#94e184ae6677e8b0b4cae0ec145b7b67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fbb4b86585411439008e934ede6f8b39"></a><!-- doxytag: member="svn_io.h::svn_io_temp_dir" ref="fbb4b86585411439008e934ede6f8b39" args="(const char **dir, apr_pool_t *pool)" -->
<a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#fbb4b86585411439008e934ede6f8b39">svn_io_temp_dir</a> (const char **dir, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*dir</em> to a directory path (allocated in <em>pool</em>) deemed usable for the creation of temporary files and subdirectories. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#b4a3b25a089372c59aca6783a3a31595">svn_io_copy_file</a> (const char *src, const char *dst, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> copy_perms, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy <em>src</em> to <em>dst</em> atomically, in a "byte-for-byte" manner.  <a href="#b4a3b25a089372c59aca6783a3a31595"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#539dc0c726940a466a3bc2358d6b85d8">svn_io_copy_link</a> (const char *src, const char *dst, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy symbolic link <em>src</em> to <em>dst</em> atomically.  <a href="#539dc0c726940a466a3bc2358d6b85d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#fcaeff1ea5e9ae65c8188678a1e042bf">svn_io_copy_dir_recursively</a> (const char *src, const char *dst_parent, const char *dst_basename, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> copy_perms, <a class="el" href="svn__types_8h.html#ddaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recursively copy directory <em>src</em> into <em>dst_parent</em>, as a new entry named <em>dst_basename</em>.  <a href="#fcaeff1ea5e9ae65c8188678a1e042bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#0ef4d0c5c6a86ab48f515b4a31efad70">svn_io_make_dir_recursively</a> (const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create directory <em>path</em> on the file system, creating intermediate directories as required, like <code>mkdir -p</code>.  <a href="#0ef4d0c5c6a86ab48f515b4a31efad70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#cea0b7ecaacd02da03a5cfaebe27067a">svn_io_dir_empty</a> (<a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *is_empty_p, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*is_empty_p</em> to <code>TRUE</code> if directory <em>path</em> is empty, else to <code>FALSE</code> if it is not empty.  <a href="#cea0b7ecaacd02da03a5cfaebe27067a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#967781b8e5991f3c72f125a333661d1b">svn_io_append_file</a> (const char *src, const char *dst, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append <em>src</em> to <em>dst</em>.  <a href="#967781b8e5991f3c72f125a333661d1b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#185f4ee690965e622aa1748339847ae5">svn_io_set_file_read_only</a> (const char *path, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> ignore_enoent, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a file as read-only as the operating system allows.  <a href="#185f4ee690965e622aa1748339847ae5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#c407a16bc12b63d2e57a3e2375490ad5">svn_io_set_file_read_write</a> (const char *path, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> ignore_enoent, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a file as writable as the operating system allows.  <a href="#c407a16bc12b63d2e57a3e2375490ad5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#02cd461341834d955e258a70def4f56f">svn_io_set_file_read_write_carefully</a> (const char *path, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> enable_write, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> ignore_enoent, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to svn_io_set_file_read_* functions.  <a href="#02cd461341834d955e258a70def4f56f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#358a735a173b43509cf4060b73930cf5">svn_io_set_file_executable</a> (const char *path, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> executable, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> ignore_enoent, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>path's</em> "executability" (but do nothing if it is a symlink).  <a href="#358a735a173b43509cf4060b73930cf5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#2cb981f75792c99480f93b83ae9265d2">svn_io_is_file_executable</a> (<a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *executable, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine whether a file is executable by the current user.  <a href="#2cb981f75792c99480f93b83ae9265d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#b3f73a4554d78dbbc3d9e0f29943380e">svn_io_read_length_line</a> (apr_file_t *file, char *buf, apr_size_t *limit, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a line from <em>file</em> into <em>buf</em>, but not exceeding <em>*limit</em> bytes.  <a href="#b3f73a4554d78dbbc3d9e0f29943380e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#e9ed0a769c24087316ebcc868fb559a0">svn_io_file_affected_time</a> (apr_time_t *apr_time, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*apr_time</em> to the time of last modification of the contents of the file <em>path</em>.  <a href="#e9ed0a769c24087316ebcc868fb559a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#474cc5427ee6e900ff8c96559e368fe6">svn_io_set_file_affected_time</a> (apr_time_t apr_time, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the timestamp of file <em>path</em> to <em>apr_time</em>.  <a href="#474cc5427ee6e900ff8c96559e368fe6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#759d9be046832ba2e1f8d5408a7023d1">svn_io_filesizes_different_p</a> (<a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *different_p, const char *file1, const char *file2, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*different_p</em> to non-zero if <em>file1</em> and <em>file2</em> have different sizes, else set to zero.  <a href="#759d9be046832ba2e1f8d5408a7023d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#d7384374afef049adcc8485de4083186">svn_io_file_checksum</a> (unsigned char digest[], const char *file, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put the md5 checksum of <em>file</em> into <em>digest</em>.  <a href="#d7384374afef049adcc8485de4083186"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#c3ddb92f73a78796c75a0790bc9cf727">svn_io_files_contents_same_p</a> (<a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *same, const char *file1, const char *file2, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*same</em> to TRUE if <em>file1</em> and <em>file2</em> have the same contents, else set it to FALSE.  <a href="#c3ddb92f73a78796c75a0790bc9cf727"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#36cd10dc8fb91f40c0df79edf8fc3a18">svn_io_file_create</a> (const char *file, const char *contents, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create file at utf8-encoded <em>file</em> with contents <em>contents</em>.  <a href="#36cd10dc8fb91f40c0df79edf8fc3a18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#98ada015dbb0b5d467375edba000dd4b">svn_io_file_lock</a> (const char *lock_file, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> exclusive, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock file at <em>lock_file</em>.  <a href="#98ada015dbb0b5d467375edba000dd4b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#256b06e01a023d03c47e8a29f8a0344a">svn_io_file_lock2</a> (const char *lock_file, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> exclusive, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> nonblocking, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock file at <em>lock_file</em>.  <a href="#256b06e01a023d03c47e8a29f8a0344a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#1738477996c854ac51fbd77cccaddfb5">svn_io_file_flush_to_disk</a> (apr_file_t *file, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush any unwritten data from <em>file</em> to disk.  <a href="#1738477996c854ac51fbd77cccaddfb5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#e6c6d960b1f742e2c00f8d7dd6ea1c5d">svn_io_dir_file_copy</a> (const char *src_path, const char *dest_path, const char *file, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy file <em>file</em> from location <em>src_path</em> to location <em>dest_path</em>.  <a href="#e6c6d960b1f742e2c00f8d7dd6ea1c5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gdc3e897290c9479c6b903876d18dc87c">svn_stream_create</a> (void *baton, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a generic stream.  <a href="group__svn__io__byte__streams.html#gdc3e897290c9479c6b903876d18dc87c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g0ff601f7fb4a7c8c92770edd7376b052"></a><!-- doxytag: member="svn_io.h::svn_stream_set_baton" ref="g0ff601f7fb4a7c8c92770edd7376b052" args="(svn_stream_t *stream, void *baton)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g0ff601f7fb4a7c8c92770edd7376b052">svn_stream_set_baton</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, void *baton)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>stream's</em> baton to <em>baton</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ge9ebdcf950b897d9c0cb89c331262aed"></a><!-- doxytag: member="svn_io.h::svn_stream_set_read" ref="ge9ebdcf950b897d9c0cb89c331262aed" args="(svn_stream_t *stream, svn_read_fn_t read_fn)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ge9ebdcf950b897d9c0cb89c331262aed">svn_stream_set_read</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#g9a8939b5258b070a48aa1e0cd154909a">svn_read_fn_t</a> read_fn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>stream's</em> read function to <em>read_fn</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gea19e182974e64a77d3f949a25f496a1"></a><!-- doxytag: member="svn_io.h::svn_stream_set_write" ref="gea19e182974e64a77d3f949a25f496a1" args="(svn_stream_t *stream, svn_write_fn_t write_fn)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gea19e182974e64a77d3f949a25f496a1">svn_stream_set_write</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#ga79398b116a9209eb3a79947a6066f54">svn_write_fn_t</a> write_fn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>stream's</em> write function to <em>write_fn</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g090c93a72964b78a00de75fa10fc5078"></a><!-- doxytag: member="svn_io.h::svn_stream_set_close" ref="g090c93a72964b78a00de75fa10fc5078" args="(svn_stream_t *stream, svn_close_fn_t close_fn)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g090c93a72964b78a00de75fa10fc5078">svn_stream_set_close</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#g576facc62f51e98c14cb440df1e58cd9">svn_close_fn_t</a> close_fn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>stream's</em> close function to <em>close_fn</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g9f0acad4da18e90c1dc5250643af7049">svn_stream_empty</a> (apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a stream that is empty for reading and infinite for writing.  <a href="group__svn__io__byte__streams.html#g9f0acad4da18e90c1dc5250643af7049"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g61c69116290c1f5e5fedd91ed7bed5ca">svn_stream_disown</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a stream allocated in <em>pool</em> which forwards all requests to <em>stream</em>.  <a href="group__svn__io__byte__streams.html#g61c69116290c1f5e5fedd91ed7bed5ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gdf2971328919edf3fed5ef8353a90525">svn_stream_from_aprfile2</a> (apr_file_t *file, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> disown, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a stream from an APR file.  <a href="group__svn__io__byte__streams.html#gdf2971328919edf3fed5ef8353a90525"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gd12a2e4cbc23bcf8ee3f650966b8c43b">svn_stream_from_aprfile</a> (apr_file_t *file, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="group__svn__io__byte__streams.html#gdf2971328919edf3fed5ef8353a90525" title="Create a stream from an APR file.">svn_stream_from_aprfile2()</a>, except that the file will always be disowned.  <a href="group__svn__io__byte__streams.html#gd12a2e4cbc23bcf8ee3f650966b8c43b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g64eca282d3b75b431a6f8ae5a6637fbb">svn_stream_for_stdout</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **out, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*out</em> to a generic stream connected to stdout, allocated in <em>pool</em>.  <a href="group__svn__io__byte__streams.html#g64eca282d3b75b431a6f8ae5a6637fbb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gbe260b52fa278bc63ba75ea695e54303">svn_stream_from_stringbuf</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *str, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a generic stream connected to stringbuf <em>str</em>.  <a href="group__svn__io__byte__streams.html#gbe260b52fa278bc63ba75ea695e54303"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g10756ab562fd20d32fb880c859607b4c">svn_stream_compressed</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a stream that decompresses all data read and compresses all data written.  <a href="group__svn__io__byte__streams.html#g10756ab562fd20d32fb880c859607b4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gdda74c8a8bf6d4dc64488979aa197afc">svn_stream_checksummed</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const unsigned char **read_digest, const unsigned char **write_digest, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> read_all, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a stream that calculates checksums for all data read and written.  <a href="group__svn__io__byte__streams.html#gdda74c8a8bf6d4dc64488979aa197afc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g241e8929f8f7631a629142bd749b25fc">svn_stream_read</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, char *buffer, apr_size_t *len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read from a generic stream.  <a href="group__svn__io__byte__streams.html#g241e8929f8f7631a629142bd749b25fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g0094764a89afdedecac79df9ad1ebccb">svn_stream_write</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const char *data, apr_size_t *len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to a generic stream.  <a href="group__svn__io__byte__streams.html#g0094764a89afdedecac79df9ad1ebccb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g7d9cdab4d5d8707d59a1b1d3dab95bb4">svn_stream_close</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a generic stream.  <a href="group__svn__io__byte__streams.html#g7d9cdab4d5d8707d59a1b1d3dab95bb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g288ac398ebf52240457408a18ca0479f"></a><!-- doxytag: member="svn_io.h::svn_stream_printf" ref="g288ac398ebf52240457408a18ca0479f" args="(svn_stream_t *stream, apr_pool_t *pool, const char *fmt,...) __attribute__((format(printf" -->
<a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g288ac398ebf52240457408a18ca0479f">svn_stream_printf</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_pool_t *pool, const char *fmt,...) __attribute__((format(printf</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to <em>stream</em> using a printf-style <em>fmt</em> specifier, passed through apr_psprintf() using memory from <em>pool</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> <a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g4ca0edf4a668ba821d7dc5356361c658">svn_stream_printf_from_utf8</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const char *encoding, apr_pool_t *pool, const char *fmt,...) __attribute__((format(printf</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to <em>stream</em> using a printf-style <em>fmt</em> specifier, passed through apr_psprintf() using memory from <em>pool</em>.  <a href="group__svn__io__byte__streams.html#g4ca0edf4a668ba821d7dc5356361c658"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> <a class="el" href="structsvn__error__t.html">svn_error_t</a> <br>
<a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gac6d0a2e4bd56065397a058f792899e9">svn_stream_readline</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **stringbuf, const char *eol, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *eof, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate <em>*stringbuf</em> in <em>pool</em>, and read into it one line (terminated by <em>eol</em>) from <em>stream</em>.  <a href="group__svn__io__byte__streams.html#gac6d0a2e4bd56065397a058f792899e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g1960de4b4eb0cf1a69a5ba5e11aaa6be">svn_stream_copy2</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *from, <a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *to, <a class="el" href="svn__types_8h.html#ddaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the contents of the readable stream <em>from</em> and write them to the writable stream <em>to</em> calling <em>cancel_func</em> before copying each chunk.  <a href="group__svn__io__byte__streams.html#g1960de4b4eb0cf1a69a5ba5e11aaa6be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g444db383401ed714a240ff6ca5ca76b3">svn_stream_copy</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *from, <a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *to, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="group__svn__io__byte__streams.html#g1960de4b4eb0cf1a69a5ba5e11aaa6be" title="Read the contents of the readable stream from and write them to the writable stream...">svn_stream_copy2()</a>, but without the cancellation function.  <a href="group__svn__io__byte__streams.html#g444db383401ed714a240ff6ca5ca76b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g14b9375f4e0300888b853650e15a987a">svn_stream_contents_same</a> (<a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *same, <a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream1, <a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream2, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*same</em> to TRUE if <em>stream1</em> and <em>stream2</em> have the same contents, else set it to FALSE.  <a href="group__svn__io__byte__streams.html#g14b9375f4e0300888b853650e15a987a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#9135b41547d59296fc54c8316278a0d6">svn_stringbuf_from_file2</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **result, const char *filename, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*result</em> to a string containing the contents of <em>filename</em>, which is either "-" (indicating that stdin should be read) or the utf8-encoded path of a real file.  <a href="#9135b41547d59296fc54c8316278a0d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#2ffefcabf44f9e9fb2f71d409fcf782e">svn_stringbuf_from_file</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **result, const char *filename, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="svn__io_8h.html#9135b41547d59296fc54c8316278a0d6" title="Set *result to a string containing the contents of filename, which is either &quot;-&quot;...">svn_stringbuf_from_file2()</a>, except that if <em>filename</em> is "-", return the error <code>SVN_ERR_UNSUPPORTED_FEATURE</code> and don't touch <em>*result</em>.  <a href="#2ffefcabf44f9e9fb2f71d409fcf782e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#59b7be5b78cc045ed972b226e06ab509">svn_stringbuf_from_aprfile</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **result, apr_file_t *file, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets <em>*result</em> to a string containing the contents of the already opened <em>file</em>.  <a href="#59b7be5b78cc045ed972b226e06ab509"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#bce28e789f76b15917b28b157d54dcfb">svn_io_remove_file</a> (const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove file <em>path</em>, a utf8-encoded path.  <a href="#bce28e789f76b15917b28b157d54dcfb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#9a26dab3678b7ee9c8ebdb8e1d60aedc">svn_io_remove_dir2</a> (const char *path, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> ignore_enoent, <a class="el" href="svn__types_8h.html#ddaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recursively remove directory <em>path</em>.  <a href="#9a26dab3678b7ee9c8ebdb8e1d60aedc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#d7a26505bf041286d02793eb2a17be04">svn_io_remove_dir</a> (const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="svn__io_8h.html#9a26dab3678b7ee9c8ebdb8e1d60aedc" title="Recursively remove directory path.">svn_io_remove_dir2()</a>, but with <em>ignore_enoent</em> set to <code>FALSE</code>.  <a href="#d7a26505bf041286d02793eb2a17be04"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#0f79a74771d956231850979d58b9106e">svn_io_get_dir_filenames</a> (apr_hash_t **dirents, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read all of the disk entries in directory <em>path</em>, a utf8-encoded path.  <a href="#0f79a74771d956231850979d58b9106e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#1583e69324a3f820894422f57fa37d57">svn_io_get_dirents2</a> (apr_hash_t **dirents, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read all of the disk entries in directory <em>path</em>, a utf8-encoded path.  <a href="#1583e69324a3f820894422f57fa37d57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#4b09482c9762a2391435a6d1702d59af">svn_io_get_dirents</a> (apr_hash_t **dirents, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="svn__io_8h.html#1583e69324a3f820894422f57fa37d57" title="Read all of the disk entries in directory path, a utf8-encoded path.">svn_io_get_dirents2()</a>, but <em>*dirents</em> is a hash table with <code>svn_node_kind_t</code> values.  <a href="#4b09482c9762a2391435a6d1702d59af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#cac394a2c49dcfb02b8cda55c9281625">svn_io_dir_walk</a> (const char *dirname, apr_int32_t wanted, <a class="el" href="svn__io_8h.html#e3dd33688b3e75430f4720f4d90c1506">svn_io_walk_func_t</a> walk_func, void *walk_baton, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will recursively walk over the files and directories rooted at <em>dirname</em>, a utf8-encoded path.  <a href="#cac394a2c49dcfb02b8cda55c9281625"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#4ee2641c854734f78337aee204b79201">svn_io_start_cmd</a> (apr_proc_t *cmd_proc, const char *path, const char *cmd, const char *const *args, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> inherit, apr_file_t *infile, apr_file_t *outfile, apr_file_t *errfile, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start <em>cmd</em> with <em>args</em>, using utf8-encoded <em>path</em> as working directory.  <a href="#4ee2641c854734f78337aee204b79201"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#cc0478196081ff559613daf3ac8a39c7">svn_io_wait_for_cmd</a> (apr_proc_t *cmd_proc, const char *cmd, int *exitcode, apr_exit_why_e *exitwhy, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the process <em>*cmd_proc</em> to complete and optionally retrieve its exit code.  <a href="#cc0478196081ff559613daf3ac8a39c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#b59c1c8d67cf405ca36a5556858da82d">svn_io_run_cmd</a> (const char *path, const char *cmd, const char *const *args, int *exitcode, apr_exit_why_e *exitwhy, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> inherit, apr_file_t *infile, apr_file_t *outfile, apr_file_t *errfile, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run a command to completion, by first calling <a class="el" href="svn__io_8h.html#4ee2641c854734f78337aee204b79201" title="Start cmd with args, using utf8-encoded path as working directory.">svn_io_start_cmd()</a> and then calling <a class="el" href="svn__io_8h.html#cc0478196081ff559613daf3ac8a39c7" title="Wait for the process *cmd_proc to complete and optionally retrieve its exit code...">svn_io_wait_for_cmd()</a>.  <a href="#b59c1c8d67cf405ca36a5556858da82d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#6c0266e00c285a0b90eef9faf0e31024">svn_io_run_diff</a> (const char *dir, const char *const *user_args, int num_user_args, const char *label1, const char *label2, const char *from, const char *to, int *exitcode, apr_file_t *outfile, apr_file_t *errfile, const char *diff_cmd, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invoke <code>the</code> configured diff program, with <em>user_args</em> (an array of utf8-encoded <em>num_user_args</em> arguments) if they are specified (that is, if <em>user_args</em> is non-NULL), or "-u" if they are not.  <a href="#6c0266e00c285a0b90eef9faf0e31024"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#284650316c8ceefd30c4dae9aef49ec4">svn_io_run_diff3_2</a> (int *exitcode, const char *dir, const char *mine, const char *older, const char *yours, const char *mine_label, const char *older_label, const char *yours_label, apr_file_t *merged, const char *diff3_cmd, const apr_array_header_t *user_args, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invoke the configured <code>diff3</code> program, in utf8-encoded <em>dir</em> like this:.  <a href="#284650316c8ceefd30c4dae9aef49ec4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#e800def15e3ffc5e1645b296c4e7a1ca">svn_io_run_diff3</a> (const char *dir, const char *mine, const char *older, const char *yours, const char *mine_label, const char *older_label, const char *yours_label, apr_file_t *merged, int *exitcode, const char *diff3_cmd, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="svn__io_8h.html#284650316c8ceefd30c4dae9aef49ec4" title="Invoke the configured diff3 program, in utf8-encoded dir like this:.">svn_io_run_diff3_2()</a>, but with <em>user_args</em> set to <code>NULL</code>.  <a href="#e800def15e3ffc5e1645b296c4e7a1ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#c4625a082416ccaafdd77e35e14ec4d4">svn_io_parse_mimetypes_file</a> (apr_hash_t **type_map, const char *mimetypes_file, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse utf8-encoded <em>mimetypes_file</em> as a MIME types file (such as is provided with Apache HTTP Server), and set <em>*type_map</em> to a hash mapping <code>const char *</code> filename extensions to <code>const char *</code> MIME types.  <a href="#c4625a082416ccaafdd77e35e14ec4d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#c1989d5030f1445f2502258bf4901ab4">svn_io_detect_mimetype2</a> (const char **mimetype, const char *file, apr_hash_t *mimetype_map, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Examine utf8-encoded <em>file</em> to determine if it can be described by a known (as in, known by this function) Multipurpose Internet Mail Extension (MIME) type.  <a href="#c1989d5030f1445f2502258bf4901ab4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#e1a5fef60e9dde8f5537e637e21d025a">svn_io_detect_mimetype</a> (const char **mimetype, const char *file, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like svn_io_detect_mimetype2, but with <em>mimetypes_map</em> set to <code>NULL</code>.  <a href="#e1a5fef60e9dde8f5537e637e21d025a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#aafb0039d02ec4d4393c433c9430aa48">svn_io_file_open</a> (apr_file_t **new_file, const char *fname, apr_int32_t flag, apr_fileperms_t perm, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for apr_file_open().  <a href="#aafb0039d02ec4d4393c433c9430aa48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#c53b59ed0d20666286dcc001f1aed43c">svn_io_file_close</a> (apr_file_t *file, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for apr_file_close().  <a href="#c53b59ed0d20666286dcc001f1aed43c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#13cf1ae46bf9a45d01db6cf59d787ecd">svn_io_file_getc</a> (char *ch, apr_file_t *file, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for apr_file_getc().  <a href="#13cf1ae46bf9a45d01db6cf59d787ecd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#a9b673694dfebc9fa7018f423b6459c3">svn_io_file_info_get</a> (apr_finfo_t *finfo, apr_int32_t wanted, apr_file_t *file, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for apr_file_info_get().  <a href="#a9b673694dfebc9fa7018f423b6459c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#783e5b2a7198107666cba41642610919">svn_io_file_read</a> (apr_file_t *file, void *buf, apr_size_t *nbytes, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for apr_file_read().  <a href="#783e5b2a7198107666cba41642610919"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#58487bc76681879193a9a067dd37b483">svn_io_file_read_full</a> (apr_file_t *file, void *buf, apr_size_t nbytes, apr_size_t *bytes_read, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for apr_file_read_full().  <a href="#58487bc76681879193a9a067dd37b483"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#b296b86da8b825399792d38f68e0e914">svn_io_file_seek</a> (apr_file_t *file, apr_seek_where_t where, apr_off_t *offset, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for apr_file_seek().  <a href="#b296b86da8b825399792d38f68e0e914"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#5a78c172c69437a05e32d3dff6f152d0">svn_io_file_write</a> (apr_file_t *file, const void *buf, apr_size_t *nbytes, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for apr_file_write().  <a href="#5a78c172c69437a05e32d3dff6f152d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#6789d12c70d0a2fefb539830183ee773">svn_io_file_write_full</a> (apr_file_t *file, const void *buf, apr_size_t nbytes, apr_size_t *bytes_written, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for apr_file_write_full().  <a href="#6789d12c70d0a2fefb539830183ee773"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#8b3c8bc2bdde3a1a28eb402432e410e0">svn_io_stat</a> (apr_finfo_t *finfo, const char *fname, apr_int32_t wanted, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for apr_stat().  <a href="#8b3c8bc2bdde3a1a28eb402432e410e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#958d10520c3e99ddcbbf333eed40d86f">svn_io_file_rename</a> (const char *from_path, const char *to_path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for apr_file_rename().  <a href="#958d10520c3e99ddcbbf333eed40d86f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#2e4247ed6ed8390f4f7d68a5dea3f0e6">svn_io_file_move</a> (const char *from_path, const char *to_path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move the file from <em>from_path</em> to <em>to_path</em>, even across device boundaries.  <a href="#2e4247ed6ed8390f4f7d68a5dea3f0e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#108e7a96396aab7cacbf1e1c3ed5221f">svn_io_dir_make</a> (const char *path, apr_fileperms_t perm, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for apr_dir_make().  <a href="#108e7a96396aab7cacbf1e1c3ed5221f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#052b330df7626a534833e6329b33d753">svn_io_dir_make_hidden</a> (const char *path, apr_fileperms_t perm, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="svn__io_8h.html#108e7a96396aab7cacbf1e1c3ed5221f" title="Wrapper for apr_dir_make().">svn_io_dir_make()</a>, but sets the hidden attribute on the directory on systems that support it.  <a href="#052b330df7626a534833e6329b33d753"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#51baaf892b96c9893bbae4fa5e747495">svn_io_dir_make_sgid</a> (const char *path, apr_fileperms_t perm, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="svn__io_8h.html#108e7a96396aab7cacbf1e1c3ed5221f" title="Wrapper for apr_dir_make().">svn_io_dir_make()</a>, but attempts to set the sgid on the directory on systems that support it.  <a href="#51baaf892b96c9893bbae4fa5e747495"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#946da2aa39f21a0f6099d2984620b2ff">svn_io_dir_open</a> (apr_dir_t **new_dir, const char *dirname, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for apr_dir_open().  <a href="#946da2aa39f21a0f6099d2984620b2ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#09827e5b0404fd70abc39a2193aecb26">svn_io_dir_remove_nonrecursive</a> (const char *dirname, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for apr_dir_remove().  <a href="#09827e5b0404fd70abc39a2193aecb26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__io_8h.html#83669c6c77f141089dcc20ef80453d4a">svn_io_dir_read</a> (apr_finfo_t *finfo, apr_int32_t wanted, apr_dir_t *thedir, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for apr_dir_read().  <a href="#83669c6c77f141089dcc20ef80453d4a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__format__files.html#g80f0a4330380bafb4cd65e09151f411b">svn_io_read_version_file</a> (int *version, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*version</em> to the integer that starts the file at <em>path</em>.  <a href="group__svn__io__format__files.html#g80f0a4330380bafb4cd65e09151f411b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__format__files.html#g29aa0631f0facde88398ad50d9411aca">svn_io_write_version_file</a> (const char *path, int version, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create (or overwrite) the file at <em>path</em> with new contents, formatted as a non-negative integer <em>version</em> followed by a single newline.  <a href="group__svn__io__format__files.html#g29aa0631f0facde88398ad50d9411aca"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
General file I/O for Subversion. 
<p>

<p>Definition in file <a class="el" href="svn__io_8h-source.html">svn_io.h</a>.</p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="a78fffc81af962281813070c753d7884"></a><!-- doxytag: member="svn_io.h::svn_io_file_del_t" ref="a78fffc81af962281813070c753d7884" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="svn__io_8h.html#a78fffc81af962281813070c753d7884">svn_io_file_del_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used as an argument when creating temporary files to indicate when a file should be removed. 
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.4.</dd></dl>
Not specifying any of these means no removal at all. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="a78fffc81af962281813070c753d788470268318a6e388419ae0e85ab7f7599c"></a><!-- doxytag: member="svn_io_file_del_none" ref="a78fffc81af962281813070c753d788470268318a6e388419ae0e85ab7f7599c" args="" -->svn_io_file_del_none</em>&nbsp;</td><td>
No deletion ever. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="a78fffc81af962281813070c753d78846256344ca6b43868daa12365d75834d2"></a><!-- doxytag: member="svn_io_file_del_on_close" ref="a78fffc81af962281813070c753d78846256344ca6b43868daa12365d75834d2" args="" -->svn_io_file_del_on_close</em>&nbsp;</td><td>
Remove when the file is closed. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="a78fffc81af962281813070c753d78840f89c57067b563673ea1ec5605c908bd"></a><!-- doxytag: member="svn_io_file_del_on_pool_cleanup" ref="a78fffc81af962281813070c753d78840f89c57067b563673ea1ec5605c908bd" args="" -->svn_io_file_del_on_pool_cleanup</em>&nbsp;</td><td>
Remove when the associated pool is cleared. </td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="svn__io_8h-source.html#l00049">49</a> of file <a class="el" href="svn__io_8h-source.html">svn_io.h</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="967781b8e5991f3c72f125a333661d1b"></a><!-- doxytag: member="svn_io.h::svn_io_append_file" ref="967781b8e5991f3c72f125a333661d1b" args="(const char *src, const char *dst, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_append_file           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append <em>src</em> to <em>dst</em>. 
<p>
<em>dst</em> will be appended to if it exists, else it will be created. Both <em>src</em> and <em>dst</em> are utf8-encoded. 
</div>
</div><p>
<a class="anchor" name="31ee1827a2b62a2f4a122ef18e378b05"></a><!-- doxytag: member="svn_io.h::svn_io_check_path" ref="31ee1827a2b62a2f4a122ef18e378b05" args="(const char *path, svn_node_kind_t *kind, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_check_path           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#c3ca125707a8ca1289c73236b5ce7f9a">svn_node_kind_t</a> *&nbsp;</td>
          <td class="paramname"> <em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the <em>kind</em> of <em>path</em>. 
<p>
<em>path</em> should be UTF-8 encoded.<p>
If <em>path</em> is a file, set <em>*kind</em> to <code>svn_node_file</code>.<p>
If <em>path</em> is a directory, set <em>*kind</em> to <code>svn_node_dir</code>.<p>
If <em>path</em> does not exist, set <em>*kind</em> to <code>svn_node_none</code>.<p>
If <em>path</em> exists but is none of the above, set <em>*kind</em> to <code>svn_node_unknown</code>.<p>
If unable to determine <em>path's</em> kind, return an error, with <em>*kind's</em> value undefined.<p>
Use <em>pool</em> for temporary allocations.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="svn__types_8h.html#c3ca125707a8ca1289c73236b5ce7f9a" title="The various types of nodes in the Subversion filesystem.">svn_node_kind_t</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="47336875b45ac006d69aef58db4fb5bb"></a><!-- doxytag: member="svn_io.h::svn_io_check_resolved_path" ref="47336875b45ac006d69aef58db4fb5bb" args="(const char *path, svn_node_kind_t *kind, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_check_resolved_path           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#c3ca125707a8ca1289c73236b5ce7f9a">svn_node_kind_t</a> *&nbsp;</td>
          <td class="paramname"> <em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="svn__io_8h.html#31ee1827a2b62a2f4a122ef18e378b05" title="Determine the kind of path.">svn_io_check_path()</a>, but resolve symlinks. 
<p>
This returns the same varieties of <em>kind</em> as <a class="el" href="svn__io_8h.html#31ee1827a2b62a2f4a122ef18e378b05" title="Determine the kind of path.">svn_io_check_path()</a>. 
</div>
</div><p>
<a class="anchor" name="0f8fdad8dc4fe854ef5b9971f8ab043e"></a><!-- doxytag: member="svn_io.h::svn_io_check_special_path" ref="0f8fdad8dc4fe854ef5b9971f8ab043e" args="(const char *path, svn_node_kind_t *kind, svn_boolean_t *is_special, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_check_special_path           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#c3ca125707a8ca1289c73236b5ce7f9a">svn_node_kind_t</a> *&nbsp;</td>
          <td class="paramname"> <em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&nbsp;</td>
          <td class="paramname"> <em>is_special</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="svn__io_8h.html#31ee1827a2b62a2f4a122ef18e378b05" title="Determine the kind of path.">svn_io_check_path()</a>, but also set *is_special to <code>TRUE</code> if the path is not a normal file. 
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fcaeff1ea5e9ae65c8188678a1e042bf"></a><!-- doxytag: member="svn_io.h::svn_io_copy_dir_recursively" ref="fcaeff1ea5e9ae65c8188678a1e042bf" args="(const char *src, const char *dst_parent, const char *dst_basename, svn_boolean_t copy_perms, svn_cancel_func_t cancel_func, void *cancel_baton, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_copy_dir_recursively           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dst_parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dst_basename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>copy_perms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#ddaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a>&nbsp;</td>
          <td class="paramname"> <em>cancel_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cancel_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recursively copy directory <em>src</em> into <em>dst_parent</em>, as a new entry named <em>dst_basename</em>. 
<p>
If <em>dst_basename</em> already exists in <em>dst_parent</em>, return error. <em>copy_perms</em> will be passed through to <a class="el" href="svn__io_8h.html#b4a3b25a089372c59aca6783a3a31595" title="Copy src to dst atomically, in a &quot;byte-for-byte&quot; manner.">svn_io_copy_file()</a> when any files are copied. <em>src</em>, <em>dst_parent</em>, and <em>dst_basename</em> are all utf8-encoded.<p>
If <em>cancel_func</em> is non-NULL, invoke it with <em>cancel_baton</em> at various points during the operation. If it returns any error (typically <code>SVN_ERR_CANCELLED</code>), return that error immediately. 
</div>
</div><p>
<a class="anchor" name="b4a3b25a089372c59aca6783a3a31595"></a><!-- doxytag: member="svn_io.h::svn_io_copy_file" ref="b4a3b25a089372c59aca6783a3a31595" args="(const char *src, const char *dst, svn_boolean_t copy_perms, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_copy_file           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>copy_perms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy <em>src</em> to <em>dst</em> atomically, in a "byte-for-byte" manner. 
<p>
Overwrite <em>dst</em> if it exists, else create it. Both <em>src</em> and <em>dst</em> are utf8-encoded filenames. If <em>copy_perms</em> is TRUE, set <em>dst's</em> permissions to match those of <em>src</em>. 
</div>
</div><p>
<a class="anchor" name="539dc0c726940a466a3bc2358d6b85d8"></a><!-- doxytag: member="svn_io.h::svn_io_copy_link" ref="539dc0c726940a466a3bc2358d6b85d8" args="(const char *src, const char *dst, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_copy_link           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy symbolic link <em>src</em> to <em>dst</em> atomically. 
<p>
Overwrite <em>dst</em> if it exists, else create it. Both <em>src</em> and <em>dst</em> are utf8-encoded filenames. After copying, the <em>dst</em> link will point to the same thing <em>src</em> does.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d11db24f003c6f280e39d3c9675280dc"></a><!-- doxytag: member="svn_io.h::svn_io_create_unique_link" ref="d11db24f003c6f280e39d3c9675280dc" args="(const char **unique_name_p, const char *path, const char *dest, const char *suffix, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_create_unique_link           </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>unique_name_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="svn__io_8h.html#2384857ad348105316edf6d1036d599f" title="Like svn_io_open_unique_file2, but can&#39;t delete on pool cleanup.">svn_io_open_unique_file()</a>, except that instead of creating a file, a symlink is generated that references the path <em>dest</em>. 
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e1a5fef60e9dde8f5537e637e21d025a"></a><!-- doxytag: member="svn_io.h::svn_io_detect_mimetype" ref="e1a5fef60e9dde8f5537e637e21d025a" args="(const char **mimetype, const char *file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_detect_mimetype           </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>mimetype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like svn_io_detect_mimetype2, but with <em>mimetypes_map</em> set to <code>NULL</code>. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000129">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.4 API </dd></dl>

</div>
</div><p>
<a class="anchor" name="c1989d5030f1445f2502258bf4901ab4"></a><!-- doxytag: member="svn_io.h::svn_io_detect_mimetype2" ref="c1989d5030f1445f2502258bf4901ab4" args="(const char **mimetype, const char *file, apr_hash_t *mimetype_map, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_detect_mimetype2           </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>mimetype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&nbsp;</td>
          <td class="paramname"> <em>mimetype_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Examine utf8-encoded <em>file</em> to determine if it can be described by a known (as in, known by this function) Multipurpose Internet Mail Extension (MIME) type. 
<p>
If so, set <em>*mimetype</em> to a character string describing the MIME type, else set it to <code>NULL</code>.<p>
If not <code>NULL</code>, <em>mimetype_map</em> is a hash mapping <code>const char *</code> filename extensions to <code>const char *</code> MIME types, and is the first source consulted regarding <em>file's</em> MIME type.<p>
Use <em>pool</em> for any necessary allocations.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cea0b7ecaacd02da03a5cfaebe27067a"></a><!-- doxytag: member="svn_io.h::svn_io_dir_empty" ref="cea0b7ecaacd02da03a5cfaebe27067a" args="(svn_boolean_t *is_empty_p, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_dir_empty           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&nbsp;</td>
          <td class="paramname"> <em>is_empty_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*is_empty_p</em> to <code>TRUE</code> if directory <em>path</em> is empty, else to <code>FALSE</code> if it is not empty. 
<p>
<em>path</em> must be a directory, and is utf8-encoded. Use <em>pool</em> for temporary allocation. 
</div>
</div><p>
<a class="anchor" name="e6c6d960b1f742e2c00f8d7dd6ea1c5d"></a><!-- doxytag: member="svn_io.h::svn_io_dir_file_copy" ref="e6c6d960b1f742e2c00f8d7dd6ea1c5d" args="(const char *src_path, const char *dest_path, const char *file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_dir_file_copy           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dest_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy file <em>file</em> from location <em>src_path</em> to location <em>dest_path</em>. 
<p>
Use <em>pool</em> for memory allocations. 
</div>
</div><p>
<a class="anchor" name="108e7a96396aab7cacbf1e1c3ed5221f"></a><!-- doxytag: member="svn_io.h::svn_io_dir_make" ref="108e7a96396aab7cacbf1e1c3ed5221f" args="(const char *path, apr_fileperms_t perm, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_dir_make           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_fileperms_t&nbsp;</td>
          <td class="paramname"> <em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wrapper for apr_dir_make(). 
<p>
<em>path</em> is utf8-encoded. 
</div>
</div><p>
<a class="anchor" name="052b330df7626a534833e6329b33d753"></a><!-- doxytag: member="svn_io.h::svn_io_dir_make_hidden" ref="052b330df7626a534833e6329b33d753" args="(const char *path, apr_fileperms_t perm, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_dir_make_hidden           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_fileperms_t&nbsp;</td>
          <td class="paramname"> <em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="svn__io_8h.html#108e7a96396aab7cacbf1e1c3ed5221f" title="Wrapper for apr_dir_make().">svn_io_dir_make()</a>, but sets the hidden attribute on the directory on systems that support it. 
<p>

</div>
</div><p>
<a class="anchor" name="51baaf892b96c9893bbae4fa5e747495"></a><!-- doxytag: member="svn_io.h::svn_io_dir_make_sgid" ref="51baaf892b96c9893bbae4fa5e747495" args="(const char *path, apr_fileperms_t perm, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_dir_make_sgid           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_fileperms_t&nbsp;</td>
          <td class="paramname"> <em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="svn__io_8h.html#108e7a96396aab7cacbf1e1c3ed5221f" title="Wrapper for apr_dir_make().">svn_io_dir_make()</a>, but attempts to set the sgid on the directory on systems that support it. 
<p>
Does not return an error if the attempt to set the sgid bit fails. On Unix filesystems, setting the sgid bit on a directory ensures that files and subdirectories created within inherit group ownership from the parent instead of from the primary gid.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="946da2aa39f21a0f6099d2984620b2ff"></a><!-- doxytag: member="svn_io.h::svn_io_dir_open" ref="946da2aa39f21a0f6099d2984620b2ff" args="(apr_dir_t **new_dir, const char *dirname, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_dir_open           </td>
          <td>(</td>
          <td class="paramtype">apr_dir_t **&nbsp;</td>
          <td class="paramname"> <em>new_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dirname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wrapper for apr_dir_open(). 
<p>
<em>dirname</em> is utf8-encoded. 
</div>
</div><p>
<a class="anchor" name="83669c6c77f141089dcc20ef80453d4a"></a><!-- doxytag: member="svn_io.h::svn_io_dir_read" ref="83669c6c77f141089dcc20ef80453d4a" args="(apr_finfo_t *finfo, apr_int32_t wanted, apr_dir_t *thedir, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_dir_read           </td>
          <td>(</td>
          <td class="paramtype">apr_finfo_t *&nbsp;</td>
          <td class="paramname"> <em>finfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_int32_t&nbsp;</td>
          <td class="paramname"> <em>wanted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_dir_t *&nbsp;</td>
          <td class="paramname"> <em>thedir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wrapper for apr_dir_read(). 
<p>
Ensures that <em>finfo-&gt;name</em> is utf8-encoded, which means allocating <em>finfo-&gt;name</em> in <em>pool</em>, which may or may not be the same as <em>finfo's</em> pool. Use <em>pool</em> for error allocation as well. 
</div>
</div><p>
<a class="anchor" name="09827e5b0404fd70abc39a2193aecb26"></a><!-- doxytag: member="svn_io.h::svn_io_dir_remove_nonrecursive" ref="09827e5b0404fd70abc39a2193aecb26" args="(const char *dirname, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_dir_remove_nonrecursive           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dirname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wrapper for apr_dir_remove(). 
<p>
<em>dirname</em> is utf8-encoded. <dl class="note" compact><dt><b>Note:</b></dt><dd>This function has this name to avoid confusion with <a class="el" href="svn__io_8h.html#9a26dab3678b7ee9c8ebdb8e1d60aedc" title="Recursively remove directory path.">svn_io_remove_dir2()</a>, which is recursive. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cac394a2c49dcfb02b8cda55c9281625"></a><!-- doxytag: member="svn_io.h::svn_io_dir_walk" ref="cac394a2c49dcfb02b8cda55c9281625" args="(const char *dirname, apr_int32_t wanted, svn_io_walk_func_t walk_func, void *walk_baton, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_dir_walk           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dirname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_int32_t&nbsp;</td>
          <td class="paramname"> <em>wanted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__io_8h.html#e3dd33688b3e75430f4720f4d90c1506">svn_io_walk_func_t</a>&nbsp;</td>
          <td class="paramname"> <em>walk_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>walk_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will recursively walk over the files and directories rooted at <em>dirname</em>, a utf8-encoded path. 
<p>
For each file or directory, <em>walk_func</em> is invoked, passing in the <em>walk_baton</em>, the utf8-encoded full path to the entry, an <code>apr_finfo_t</code> structure, and a temporary pool for allocations. For any directory, <em>walk_func</em> will be invoked on the directory itself before being invoked on any subdirectories or files within the directory.<p>
The set of information passed to <em>walk_func</em> is specified by <em>wanted</em>, and the items specified by <code>APR_FINFO_TYPE</code> and <code>APR_FINFO_NAME</code>.<p>
All allocations will be performed in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="e9ed0a769c24087316ebcc868fb559a0"></a><!-- doxytag: member="svn_io.h::svn_io_file_affected_time" ref="e9ed0a769c24087316ebcc868fb559a0" args="(apr_time_t *apr_time, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_affected_time           </td>
          <td>(</td>
          <td class="paramtype">apr_time_t *&nbsp;</td>
          <td class="paramname"> <em>apr_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*apr_time</em> to the time of last modification of the contents of the file <em>path</em>. 
<p>
<em>path</em> is utf8-encoded.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This is the APR mtime which corresponds to the traditional mtime on Unix, and the last write time on Windows. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d7384374afef049adcc8485de4083186"></a><!-- doxytag: member="svn_io.h::svn_io_file_checksum" ref="d7384374afef049adcc8485de4083186" args="(unsigned char digest[], const char *file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_checksum           </td>
          <td>(</td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>digest</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Put the md5 checksum of <em>file</em> into <em>digest</em>. 
<p>
<em>digest</em> points to <code>APR_MD5_DIGESTSIZE</code> bytes of storage. Use <em>pool</em> only for temporary allocations. 
</div>
</div><p>
<a class="anchor" name="c53b59ed0d20666286dcc001f1aed43c"></a><!-- doxytag: member="svn_io.h::svn_io_file_close" ref="c53b59ed0d20666286dcc001f1aed43c" args="(apr_file_t *file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_close           </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wrapper for apr_file_close(). 
<p>

</div>
</div><p>
<a class="anchor" name="36cd10dc8fb91f40c0df79edf8fc3a18"></a><!-- doxytag: member="svn_io.h::svn_io_file_create" ref="36cd10dc8fb91f40c0df79edf8fc3a18" args="(const char *file, const char *contents, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_create           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create file at utf8-encoded <em>file</em> with contents <em>contents</em>. 
<p>
<em>file</em> must not already exist. Use <em>pool</em> for memory allocations. 
</div>
</div><p>
<a class="anchor" name="1738477996c854ac51fbd77cccaddfb5"></a><!-- doxytag: member="svn_io.h::svn_io_file_flush_to_disk" ref="1738477996c854ac51fbd77cccaddfb5" args="(apr_file_t *file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_flush_to_disk           </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flush any unwritten data from <em>file</em> to disk. 
<p>
Use <em>pool</em> for memory allocations.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="13cf1ae46bf9a45d01db6cf59d787ecd"></a><!-- doxytag: member="svn_io.h::svn_io_file_getc" ref="13cf1ae46bf9a45d01db6cf59d787ecd" args="(char *ch, apr_file_t *file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_getc           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wrapper for apr_file_getc(). 
<p>

</div>
</div><p>
<a class="anchor" name="a9b673694dfebc9fa7018f423b6459c3"></a><!-- doxytag: member="svn_io.h::svn_io_file_info_get" ref="a9b673694dfebc9fa7018f423b6459c3" args="(apr_finfo_t *finfo, apr_int32_t wanted, apr_file_t *file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_info_get           </td>
          <td>(</td>
          <td class="paramtype">apr_finfo_t *&nbsp;</td>
          <td class="paramname"> <em>finfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_int32_t&nbsp;</td>
          <td class="paramname"> <em>wanted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wrapper for apr_file_info_get(). 
<p>

</div>
</div><p>
<a class="anchor" name="98ada015dbb0b5d467375edba000dd4b"></a><!-- doxytag: member="svn_io.h::svn_io_file_lock" ref="98ada015dbb0b5d467375edba000dd4b" args="(const char *lock_file, svn_boolean_t exclusive, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_lock           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>lock_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>exclusive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lock file at <em>lock_file</em>. 
<p>
If <em>exclusive</em> is TRUE, obtain exclusive lock, otherwise obtain shared lock. Lock will be automatically released when <em>pool</em> is cleared or destroyed. Use <em>pool</em> for memory allocations.<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000122">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.0 API. </dd></dl>

</div>
</div><p>
<a class="anchor" name="256b06e01a023d03c47e8a29f8a0344a"></a><!-- doxytag: member="svn_io.h::svn_io_file_lock2" ref="256b06e01a023d03c47e8a29f8a0344a" args="(const char *lock_file, svn_boolean_t exclusive, svn_boolean_t nonblocking, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_lock2           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>lock_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>exclusive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>nonblocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lock file at <em>lock_file</em>. 
<p>
If <em>exclusive</em> is TRUE, obtain exclusive lock, otherwise obtain shared lock.<p>
If <em>nonblocking</em> is TRUE, do not wait for the lock if it is not available: throw an error instead.<p>
Lock will be automatically released when <em>pool</em> is cleared or destroyed. Use <em>pool</em> for memory allocations.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2e4247ed6ed8390f4f7d68a5dea3f0e6"></a><!-- doxytag: member="svn_io.h::svn_io_file_move" ref="2e4247ed6ed8390f4f7d68a5dea3f0e6" args="(const char *from_path, const char *to_path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_move           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>from_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>to_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Move the file from <em>from_path</em> to <em>to_path</em>, even across device boundaries. 
<p>
Overwrite <em>to_path</em> if it exists.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function is different from svn_io_file_rename in that the latter fails in the 'across device boundaries' case.</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div><p>
<a class="anchor" name="aafb0039d02ec4d4393c433c9430aa48"></a><!-- doxytag: member="svn_io.h::svn_io_file_open" ref="aafb0039d02ec4d4393c433c9430aa48" args="(apr_file_t **new_file, const char *fname, apr_int32_t flag, apr_fileperms_t perm, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_open           </td>
          <td>(</td>
          <td class="paramtype">apr_file_t **&nbsp;</td>
          <td class="paramname"> <em>new_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_int32_t&nbsp;</td>
          <td class="paramname"> <em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_fileperms_t&nbsp;</td>
          <td class="paramname"> <em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wrapper for apr_file_open(). 
<p>
<em>fname</em> is utf8-encoded. 
</div>
</div><p>
<a class="anchor" name="783e5b2a7198107666cba41642610919"></a><!-- doxytag: member="svn_io.h::svn_io_file_read" ref="783e5b2a7198107666cba41642610919" args="(apr_file_t *file, void *buf, apr_size_t *nbytes, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_read           </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&nbsp;</td>
          <td class="paramname"> <em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wrapper for apr_file_read(). 
<p>

</div>
</div><p>
<a class="anchor" name="58487bc76681879193a9a067dd37b483"></a><!-- doxytag: member="svn_io.h::svn_io_file_read_full" ref="58487bc76681879193a9a067dd37b483" args="(apr_file_t *file, void *buf, apr_size_t nbytes, apr_size_t *bytes_read, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_read_full           </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&nbsp;</td>
          <td class="paramname"> <em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&nbsp;</td>
          <td class="paramname"> <em>bytes_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wrapper for apr_file_read_full(). 
<p>

</div>
</div><p>
<a class="anchor" name="958d10520c3e99ddcbbf333eed40d86f"></a><!-- doxytag: member="svn_io.h::svn_io_file_rename" ref="958d10520c3e99ddcbbf333eed40d86f" args="(const char *from_path, const char *to_path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_rename           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>from_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>to_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wrapper for apr_file_rename(). 
<p>
<em>from_path</em> and <em>to_path</em> are utf8-encoded. 
</div>
</div><p>
<a class="anchor" name="b296b86da8b825399792d38f68e0e914"></a><!-- doxytag: member="svn_io.h::svn_io_file_seek" ref="b296b86da8b825399792d38f68e0e914" args="(apr_file_t *file, apr_seek_where_t where, apr_off_t *offset, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_seek           </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_seek_where_t&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_off_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wrapper for apr_file_seek(). 
<p>

</div>
</div><p>
<a class="anchor" name="5a78c172c69437a05e32d3dff6f152d0"></a><!-- doxytag: member="svn_io.h::svn_io_file_write" ref="5a78c172c69437a05e32d3dff6f152d0" args="(apr_file_t *file, const void *buf, apr_size_t *nbytes, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_write           </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&nbsp;</td>
          <td class="paramname"> <em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wrapper for apr_file_write(). 
<p>

</div>
</div><p>
<a class="anchor" name="6789d12c70d0a2fefb539830183ee773"></a><!-- doxytag: member="svn_io.h::svn_io_file_write_full" ref="6789d12c70d0a2fefb539830183ee773" args="(apr_file_t *file, const void *buf, apr_size_t nbytes, apr_size_t *bytes_written, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_file_write_full           </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&nbsp;</td>
          <td class="paramname"> <em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&nbsp;</td>
          <td class="paramname"> <em>bytes_written</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wrapper for apr_file_write_full(). 
<p>

</div>
</div><p>
<a class="anchor" name="c3ddb92f73a78796c75a0790bc9cf727"></a><!-- doxytag: member="svn_io.h::svn_io_files_contents_same_p" ref="c3ddb92f73a78796c75a0790bc9cf727" args="(svn_boolean_t *same, const char *file1, const char *file2, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_files_contents_same_p           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&nbsp;</td>
          <td class="paramname"> <em>same</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*same</em> to TRUE if <em>file1</em> and <em>file2</em> have the same contents, else set it to FALSE. 
<p>
Use <em>pool</em> for temporary allocations. 
</div>
</div><p>
<a class="anchor" name="759d9be046832ba2e1f8d5408a7023d1"></a><!-- doxytag: member="svn_io.h::svn_io_filesizes_different_p" ref="759d9be046832ba2e1f8d5408a7023d1" args="(svn_boolean_t *different_p, const char *file1, const char *file2, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_filesizes_different_p           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&nbsp;</td>
          <td class="paramname"> <em>different_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*different_p</em> to non-zero if <em>file1</em> and <em>file2</em> have different sizes, else set to zero. 
<p>
Both <em>file1</em> and <em>file2</em> are utf8-encoded.<p>
Setting <em>*different_p</em> to zero does not mean the files definitely have the same size, it merely means that the sizes are not definitely different. That is, if the size of one or both files cannot be determined, then the sizes are not known to be different, so <em>*different_p</em> is set to 0. 
</div>
</div><p>
<a class="anchor" name="0f79a74771d956231850979d58b9106e"></a><!-- doxytag: member="svn_io.h::svn_io_get_dir_filenames" ref="0f79a74771d956231850979d58b9106e" args="(apr_hash_t **dirents, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_get_dir_filenames           </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&nbsp;</td>
          <td class="paramname"> <em>dirents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read all of the disk entries in directory <em>path</em>, a utf8-encoded path. 
<p>
Set <em>*dirents</em> to a hash mapping dirent names (<code>char *</code>) to undefined non-NULL values, allocated in <em>pool</em>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The `.' and `..' directories normally returned by apr_dir_read() are NOT returned in the hash.</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.4. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4b09482c9762a2391435a6d1702d59af"></a><!-- doxytag: member="svn_io.h::svn_io_get_dirents" ref="4b09482c9762a2391435a6d1702d59af" args="(apr_hash_t **dirents, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_get_dirents           </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&nbsp;</td>
          <td class="paramname"> <em>dirents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to <a class="el" href="svn__io_8h.html#1583e69324a3f820894422f57fa37d57" title="Read all of the disk entries in directory path, a utf8-encoded path.">svn_io_get_dirents2()</a>, but <em>*dirents</em> is a hash table with <code>svn_node_kind_t</code> values. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000127">Deprecated:</a></b></dt><dd>Provided for backwards compatibility with the 1.2 API. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1583e69324a3f820894422f57fa37d57"></a><!-- doxytag: member="svn_io.h::svn_io_get_dirents2" ref="1583e69324a3f820894422f57fa37d57" args="(apr_hash_t **dirents, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_get_dirents2           </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&nbsp;</td>
          <td class="paramname"> <em>dirents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read all of the disk entries in directory <em>path</em>, a utf8-encoded path. 
<p>
Set <em>*dirents</em> to a hash mapping dirent names (<code>char *</code>) to <code><a class="el" href="structsvn__io__dirent__t.html" title="Represents the kind and special status of a directory entry.">svn_io_dirent_t</a></code> structures, allocated in <em>pool</em>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The `.' and `..' directories normally returned by apr_dir_read() are NOT returned in the hash.<p>
The kind field in the <em>dirents</em> is set according to the mapping as documented for <a class="el" href="svn__io_8h.html#31ee1827a2b62a2f4a122ef18e378b05" title="Determine the kind of path.">svn_io_check_path()</a></dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2cb981f75792c99480f93b83ae9265d2"></a><!-- doxytag: member="svn_io.h::svn_io_is_file_executable" ref="2cb981f75792c99480f93b83ae9265d2" args="(svn_boolean_t *executable, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_is_file_executable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&nbsp;</td>
          <td class="paramname"> <em>executable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine whether a file is executable by the current user. 
<p>
Set <em>*executable</em> to <code>TRUE</code> if the file <em>path</em> is executable by the current user, otherwise set it to <code>FALSE</code>.<p>
On Windows and on platforms without userids, always returns <code>FALSE</code>. 
</div>
</div><p>
<a class="anchor" name="0ef4d0c5c6a86ab48f515b4a31efad70"></a><!-- doxytag: member="svn_io.h::svn_io_make_dir_recursively" ref="0ef4d0c5c6a86ab48f515b4a31efad70" args="(const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_make_dir_recursively           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create directory <em>path</em> on the file system, creating intermediate directories as required, like <code>mkdir -p</code>. 
<p>
Report no error if <em>path</em> already exists. <em>path</em> is utf8-encoded.<p>
This is essentially a wrapper for apr_dir_make_recursive(), passing <code>APR_OS_DEFAULT</code> as the permissions. 
</div>
</div><p>
<a class="anchor" name="2384857ad348105316edf6d1036d599f"></a><!-- doxytag: member="svn_io.h::svn_io_open_unique_file" ref="2384857ad348105316edf6d1036d599f" args="(apr_file_t **f, const char **unique_name_p, const char *path, const char *suffix, svn_boolean_t delete_on_close, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_open_unique_file           </td>
          <td>(</td>
          <td class="paramtype">apr_file_t **&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>unique_name_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>delete_on_close</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like svn_io_open_unique_file2, but can't delete on pool cleanup. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000120">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.0 API</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>In 1.4 the API was extended to require either <em>f</em> or <em>unique_name_p</em> (the other can be NULL). Before that, both were required. </dd></dl>

</div>
</div><p>
<a class="anchor" name="58df63b2898a8a2a7df988b2d633eb1a"></a><!-- doxytag: member="svn_io.h::svn_io_open_unique_file2" ref="58df63b2898a8a2a7df988b2d633eb1a" args="(apr_file_t **f, const char **unique_name_p, const char *path, const char *suffix, svn_io_file_del_t delete_when, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_open_unique_file2           </td>
          <td>(</td>
          <td class="paramtype">apr_file_t **&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>unique_name_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__io_8h.html#a78fffc81af962281813070c753d7884">svn_io_file_del_t</a>&nbsp;</td>
          <td class="paramname"> <em>delete_when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open a new file (for reading and writing) with a unique name based on utf-8 encoded <em>path</em>, in the same directory as <em>path</em>. 
<p>
The file handle is returned in <em>*f</em>, and the name, which ends with <em>suffix</em>, is returned in <em>*unique_name_p</em>, also utf8-encoded. Either <em>f</em> or <em>unique_name_p</em> may be <code>NULL</code>.<p>
If <em>delete_when</em> is <code>svn_io_file_del_on_close</code>, then the <code>APR_DELONCLOSE</code> flag will be used when opening the file. The <code>APR_BUFFERED</code> flag will always be used.<p>
The first attempt will just append <em>suffix</em>. If the result is not a unique name, then subsequent attempts will append a dot, followed by an iteration number ("2", then "3", and so on), followed by the suffix. For example, if <em>path</em> is<p>
tests/t1/A/D/G/pi<p>
then successive calls to<p>
svn_io_open_unique_file2(&amp;f, &amp;unique_name, <em>path</em>, ".tmp", ..., pool)<p>
will open<p>
tests/t1/A/D/G/pi.tmp tests/t1/A/D/G/pi.2.tmp tests/t1/A/D/G/pi.3.tmp tests/t1/A/D/G/pi.4.tmp tests/t1/A/D/G/pi.5.tmp ...<p>
Assuming <em>suffix</em> is non-empty, <em>*unique_name_p</em> will never be exactly the same as <em>path</em>, even if <em>path</em> does not exist.<p>
It doesn't matter if <em>path</em> is a file or directory, the unique name will be in <em>path's</em> parent either way.<p>
Allocate <em>*f</em> and <em>*unique_name_p</em> in <em>pool</em>.<p>
If no unique name can be found, <code>SVN_ERR_IO_UNIQUE_NAMES_EXHAUSTED</code> is the error returned.<p>
Claim of Historical Inevitability: this function was written because<p>
<ul>
<li>tmpnam() is not thread-safe.</li><li>tempname() tries standard system tmp areas first.</li></ul>
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.4 </dd></dl>

</div>
</div><p>
<a class="anchor" name="c4625a082416ccaafdd77e35e14ec4d4"></a><!-- doxytag: member="svn_io.h::svn_io_parse_mimetypes_file" ref="c4625a082416ccaafdd77e35e14ec4d4" args="(apr_hash_t **type_map, const char *mimetypes_file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_parse_mimetypes_file           </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&nbsp;</td>
          <td class="paramname"> <em>type_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>mimetypes_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse utf8-encoded <em>mimetypes_file</em> as a MIME types file (such as is provided with Apache HTTP Server), and set <em>*type_map</em> to a hash mapping <code>const char *</code> filename extensions to <code>const char *</code> MIME types. 
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b3f73a4554d78dbbc3d9e0f29943380e"></a><!-- doxytag: member="svn_io.h::svn_io_read_length_line" ref="b3f73a4554d78dbbc3d9e0f29943380e" args="(apr_file_t *file, char *buf, apr_size_t *limit, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_read_length_line           </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&nbsp;</td>
          <td class="paramname"> <em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a line from <em>file</em> into <em>buf</em>, but not exceeding <em>*limit</em> bytes. 
<p>
Does not include newline, instead '\0' is put there. Length (as in strlen) is returned in <em>*limit</em>. <em>buf</em> should be pre-allocated. <em>file</em> should be already opened.<p>
When the file is out of lines, <code>APR_EOF</code> will be returned. 
</div>
</div><p>
<a class="anchor" name="94e184ae6677e8b0b4cae0ec145b7b67"></a><!-- doxytag: member="svn_io.h::svn_io_read_link" ref="94e184ae6677e8b0b4cae0ec145b7b67" args="(svn_string_t **dest, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_read_link           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__string__t.html">svn_string_t</a> **&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*dest</em> to the path that the symlink at <em>path</em> references. 
<p>
Allocate the string from <em>pool</em>.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d7a26505bf041286d02793eb2a17be04"></a><!-- doxytag: member="svn_io.h::svn_io_remove_dir" ref="d7a26505bf041286d02793eb2a17be04" args="(const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_remove_dir           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to <a class="el" href="svn__io_8h.html#9a26dab3678b7ee9c8ebdb8e1d60aedc" title="Recursively remove directory path.">svn_io_remove_dir2()</a>, but with <em>ignore_enoent</em> set to <code>FALSE</code>. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000126">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.4 API </dd></dl>

</div>
</div><p>
<a class="anchor" name="9a26dab3678b7ee9c8ebdb8e1d60aedc"></a><!-- doxytag: member="svn_io.h::svn_io_remove_dir2" ref="9a26dab3678b7ee9c8ebdb8e1d60aedc" args="(const char *path, svn_boolean_t ignore_enoent, svn_cancel_func_t cancel_func, void *cancel_baton, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_remove_dir2           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>ignore_enoent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#ddaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a>&nbsp;</td>
          <td class="paramname"> <em>cancel_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cancel_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recursively remove directory <em>path</em>. 
<p>
<em>path</em> is utf8-encoded. If <em>ignore_enoent</em> is <code>TRUE</code>, don't fail if the target directory doesn't exist. Use <em>pool</em> for temporary allocations.<p>
Because recursive delete of a directory tree can be a lengthy operation, provide <em>cancel_func</em> and <em>cancel_baton</em> for interuptability.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bce28e789f76b15917b28b157d54dcfb"></a><!-- doxytag: member="svn_io.h::svn_io_remove_file" ref="bce28e789f76b15917b28b157d54dcfb" args="(const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_remove_file           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove file <em>path</em>, a utf8-encoded path. 
<p>
This wraps apr_file_remove(), converting any error to a Subversion error. 
</div>
</div><p>
<a class="anchor" name="b59c1c8d67cf405ca36a5556858da82d"></a><!-- doxytag: member="svn_io.h::svn_io_run_cmd" ref="b59c1c8d67cf405ca36a5556858da82d" args="(const char *path, const char *cmd, const char *const *args, int *exitcode, apr_exit_why_e *exitwhy, svn_boolean_t inherit, apr_file_t *infile, apr_file_t *outfile, apr_file_t *errfile, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_run_cmd           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&nbsp;</td>
          <td class="paramname"> <em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>exitcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_exit_why_e *&nbsp;</td>
          <td class="paramname"> <em>exitwhy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>inherit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>infile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>outfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>errfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Run a command to completion, by first calling <a class="el" href="svn__io_8h.html#4ee2641c854734f78337aee204b79201" title="Start cmd with args, using utf8-encoded path as working directory.">svn_io_start_cmd()</a> and then calling <a class="el" href="svn__io_8h.html#cc0478196081ff559613daf3ac8a39c7" title="Wait for the process *cmd_proc to complete and optionally retrieve its exit code...">svn_io_wait_for_cmd()</a>. 
<p>
The parameters correspond to the same-named parameters of those two functions. 
</div>
</div><p>
<a class="anchor" name="6c0266e00c285a0b90eef9faf0e31024"></a><!-- doxytag: member="svn_io.h::svn_io_run_diff" ref="6c0266e00c285a0b90eef9faf0e31024" args="(const char *dir, const char *const *user_args, int num_user_args, const char *label1, const char *label2, const char *from, const char *to, int *exitcode, apr_file_t *outfile, apr_file_t *errfile, const char *diff_cmd, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_run_diff           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&nbsp;</td>
          <td class="paramname"> <em>user_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_user_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>label1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>label2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>exitcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>outfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>errfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>diff_cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invoke <code>the</code> configured diff program, with <em>user_args</em> (an array of utf8-encoded <em>num_user_args</em> arguments) if they are specified (that is, if <em>user_args</em> is non-NULL), or "-u" if they are not. 
<p>
If <em>user_args</em> is NULL, the value of <em>num_user_args</em> is ignored.<p>
Diff runs in utf8-encoded <em>dir</em>, and its exit status is stored in <em>exitcode</em>, if it is not <code>NULL</code>.<p>
If <em>label1</em> and/or <em>label2</em> are not NULL they will be passed to the diff process as the arguments of "-L" options. <em>label1</em> and <em>label2</em> are also in utf8, and will be converted to native charset along with the other args.<p>
<em>from</em> is the first file passed to diff, and <em>to</em> is the second. The stdout of diff will be sent to <em>outfile</em>, and the stderr to <em>errfile</em>.<p>
<em>diff_cmd</em> must be non-NULL.<p>
Do all allocation in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="e800def15e3ffc5e1645b296c4e7a1ca"></a><!-- doxytag: member="svn_io.h::svn_io_run_diff3" ref="e800def15e3ffc5e1645b296c4e7a1ca" args="(const char *dir, const char *mine, const char *older, const char *yours, const char *mine_label, const char *older_label, const char *yours_label, apr_file_t *merged, int *exitcode, const char *diff3_cmd, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_run_diff3           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>mine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>older</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>yours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>mine_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>older_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>yours_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>merged</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>exitcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>diff3_cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to <a class="el" href="svn__io_8h.html#284650316c8ceefd30c4dae9aef49ec4" title="Invoke the configured diff3 program, in utf8-encoded dir like this:.">svn_io_run_diff3_2()</a>, but with <em>user_args</em> set to <code>NULL</code>. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000128">Deprecated:</a></b></dt><dd>Provided for backwards compatibility with the 1.3 API. </dd></dl>

</div>
</div><p>
<a class="anchor" name="284650316c8ceefd30c4dae9aef49ec4"></a><!-- doxytag: member="svn_io.h::svn_io_run_diff3_2" ref="284650316c8ceefd30c4dae9aef49ec4" args="(int *exitcode, const char *dir, const char *mine, const char *older, const char *yours, const char *mine_label, const char *older_label, const char *yours_label, apr_file_t *merged, const char *diff3_cmd, const apr_array_header_t *user_args, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_run_diff3_2           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>exitcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>mine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>older</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>yours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>mine_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>older_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>yours_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>merged</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>diff3_cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&nbsp;</td>
          <td class="paramname"> <em>user_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invoke the configured <code>diff3</code> program, in utf8-encoded <em>dir</em> like this:. 
<p>
diff3 -E -m <em>mine</em> <em>older</em> <em>yours</em> &gt; <em>merged</em> <p>
(See the diff3 documentation for details.)<p>
If <em>user_args</em> is non-NULL, replace "-E" with the <code>const char*</code> elements that <em>user_args</em> contains.<p>
<em>mine</em>, <em>older</em> and <em>yours</em> are utf8-encoded paths (relative to <em>dir</em> or absolute) to three files that already exist.<p>
<em>merged</em> is an open file handle, and is left open after the merge result is written to it. (<em>merged</em> should *not* be the same file as <em>mine</em>, or nondeterministic things may happen!)<p>
<em>mine_label</em>, <em>older_label</em>, <em>yours_label</em> are utf8-encoded label parameters for diff3's -L option. Any of them may be <code>NULL</code>, in which case the corresponding <em>mine</em>, <em>older</em>, or <em>yours</em> parameter is used instead.<p>
Set <em>*exitcode</em> to diff3's exit status. If <em>*exitcode</em> is anything other than 0 or 1, then return <code>SVN_ERR_EXTERNAL_PROGRAM</code>. (Note the following from the diff3 info pages: "An exit status of 0 means `diff3' was successful, 1 means some conflicts were found, and 2 means trouble.")<p>
<em>diff3_cmd</em> must be non-NULL.<p>
Do all allocation in <em>pool</em>.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.4. </dd></dl>

</div>
</div><p>
<a class="anchor" name="474cc5427ee6e900ff8c96559e368fe6"></a><!-- doxytag: member="svn_io.h::svn_io_set_file_affected_time" ref="474cc5427ee6e900ff8c96559e368fe6" args="(apr_time_t apr_time, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_set_file_affected_time           </td>
          <td>(</td>
          <td class="paramtype">apr_time_t&nbsp;</td>
          <td class="paramname"> <em>apr_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the timestamp of file <em>path</em> to <em>apr_time</em>. 
<p>
<em>path</em> is utf8-encoded.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This is the APR mtime which corresponds to the traditional mtime on Unix, and the last write time on Windows. </dd></dl>

</div>
</div><p>
<a class="anchor" name="358a735a173b43509cf4060b73930cf5"></a><!-- doxytag: member="svn_io.h::svn_io_set_file_executable" ref="358a735a173b43509cf4060b73930cf5" args="(const char *path, svn_boolean_t executable, svn_boolean_t ignore_enoent, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_set_file_executable           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>executable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>ignore_enoent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>path's</em> "executability" (but do nothing if it is a symlink). 
<p>
<em>path</em> is the utf8-encoded path to the file. If <em>executable</em> is <code>TRUE</code>, then make the file executable. If <code>FALSE</code>, make it non-executable. If <em>ignore_enoent</em> is <code>TRUE</code>, don't fail if the target file doesn't exist.<p>
When making the file executable on operating systems with unix style permissions, never add an execute permission where there is not already a read permission: that is, only make the file executable for the user, group or world if the corresponding read permission is already set for user, group or world.<p>
When making the file non-executable on operating systems with unix style permissions, remove all execute permissions.<p>
On other operating systems, toggle the file's "executability" as much as the operating system allows.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If <em>path</em> is a directory, act on it as though it were a file, as described above, but note that you probably don't want to call this function on directories. We have left it effective on directories for compatibility reasons, but as its name implies, it should be used only for files. </dd></dl>

</div>
</div><p>
<a class="anchor" name="185f4ee690965e622aa1748339847ae5"></a><!-- doxytag: member="svn_io.h::svn_io_set_file_read_only" ref="185f4ee690965e622aa1748339847ae5" args="(const char *path, svn_boolean_t ignore_enoent, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_set_file_read_only           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>ignore_enoent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a file as read-only as the operating system allows. 
<p>
<em>path</em> is the utf8-encoded path to the file. If <em>ignore_enoent</em> is <code>TRUE</code>, don't fail if the target file doesn't exist.<p>
If <em>path</em> is a symlink, do nothing.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If <em>path</em> is a directory, act on it as though it were a file, as described above, but note that you probably don't want to call this function on directories. We have left it effective on directories for compatibility reasons, but as its name implies, it should be used only for files. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c407a16bc12b63d2e57a3e2375490ad5"></a><!-- doxytag: member="svn_io.h::svn_io_set_file_read_write" ref="c407a16bc12b63d2e57a3e2375490ad5" args="(const char *path, svn_boolean_t ignore_enoent, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_set_file_read_write           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>ignore_enoent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a file as writable as the operating system allows. 
<p>
<em>path</em> is the utf8-encoded path to the file. If <em>ignore_enoent</em> is <code>TRUE</code>, don't fail if the target file doesn't exist. <dl class="warning" compact><dt><b>Warning:</b></dt><dd>On Unix this function will do the equivalent of chmod a+w path. If this is not what you want you should not use this function, but rather use apr_file_perms_set().</dd></dl>
If <em>path</em> is a symlink, do nothing.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If <em>path</em> is a directory, act on it as though it were a file, as described above, but note that you probably don't want to call this function on directories. We have left it effective on directories for compatibility reasons, but as its name implies, it should be used only for files. </dd></dl>

</div>
</div><p>
<a class="anchor" name="02cd461341834d955e258a70def4f56f"></a><!-- doxytag: member="svn_io.h::svn_io_set_file_read_write_carefully" ref="02cd461341834d955e258a70def4f56f" args="(const char *path, svn_boolean_t enable_write, svn_boolean_t ignore_enoent, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_set_file_read_write_carefully           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>enable_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>ignore_enoent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to svn_io_set_file_read_* functions. 
<p>
Change the read-write permissions of a file. <dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.1.</dd></dl>
When making <em>path</em> read-write on operating systems with unix style permissions, set the permissions on <em>path</em> to the permissions that are set when a new file is created (effectively honoring the user's umask).<p>
When making the file read-only on operating systems with unix style permissions, remove all write permissions.<p>
On other operating systems, toggle the file's "writability" as much as the operating system allows.<p>
<em>path</em> is the utf8-encoded path to the file. If <em>enable_write</em> is <code>TRUE</code>, then make the file read-write. If <code>FALSE</code>, make it read-only. If <em>ignore_enoent</em> is <code>TRUE</code>, don't fail if the target file doesn't exist.<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000121">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.3 API. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4ee2641c854734f78337aee204b79201"></a><!-- doxytag: member="svn_io.h::svn_io_start_cmd" ref="4ee2641c854734f78337aee204b79201" args="(apr_proc_t *cmd_proc, const char *path, const char *cmd, const char *const *args, svn_boolean_t inherit, apr_file_t *infile, apr_file_t *outfile, apr_file_t *errfile, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_start_cmd           </td>
          <td>(</td>
          <td class="paramtype">apr_proc_t *&nbsp;</td>
          <td class="paramname"> <em>cmd_proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&nbsp;</td>
          <td class="paramname"> <em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>inherit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>infile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>outfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>errfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start <em>cmd</em> with <em>args</em>, using utf8-encoded <em>path</em> as working directory. 
<p>
Connect <em>cmd's</em> stdin, stdout, and stderr to <em>infile</em>, <em>outfile</em>, and <em>errfile</em>, except where they are NULL. Return the process handle for the invoked program in <em>*cmd_proc</em>.<p>
<em>args</em> is a list of utf8-encoded <code>const char *</code> arguments, terminated by <code>NULL</code>. <em>args</em>[0] is the name of the program, though it need not be the same as <em>cmd</em>.<p>
If <em>inherit</em> is TRUE, the invoked program inherits its environment from the caller and <em>cmd</em>, if not absolute, is searched for in PATH. Otherwise, the invoked program runs with an empty environment and <em>cmd</em> must be an absolute path.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>On some platforms, failure to execute <em>cmd</em> in the child process will result in error output being written to <em>errfile</em>, if non-NULL, and a non-zero exit status being returned to the parent process.</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8b3c8bc2bdde3a1a28eb402432e410e0"></a><!-- doxytag: member="svn_io.h::svn_io_stat" ref="8b3c8bc2bdde3a1a28eb402432e410e0" args="(apr_finfo_t *finfo, const char *fname, apr_int32_t wanted, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_stat           </td>
          <td>(</td>
          <td class="paramtype">apr_finfo_t *&nbsp;</td>
          <td class="paramname"> <em>finfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_int32_t&nbsp;</td>
          <td class="paramname"> <em>wanted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wrapper for apr_stat(). 
<p>
<em>fname</em> is utf8-encoded. 
</div>
</div><p>
<a class="anchor" name="cc0478196081ff559613daf3ac8a39c7"></a><!-- doxytag: member="svn_io.h::svn_io_wait_for_cmd" ref="cc0478196081ff559613daf3ac8a39c7" args="(apr_proc_t *cmd_proc, const char *cmd, int *exitcode, apr_exit_why_e *exitwhy, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_io_wait_for_cmd           </td>
          <td>(</td>
          <td class="paramtype">apr_proc_t *&nbsp;</td>
          <td class="paramname"> <em>cmd_proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>exitcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_exit_why_e *&nbsp;</td>
          <td class="paramname"> <em>exitwhy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for the process <em>*cmd_proc</em> to complete and optionally retrieve its exit code. 
<p>
<em>cmd</em> is used only in error messages.<p>
If <em>exitcode</em> is not NULL, <em>*exitcode</em> will contain the exit code of the process upon return, and if <em>exitwhy</em> is not NULL, <em>*exitwhy</em> will indicate why the process terminated. If <em>exitwhy</em> is NULL, and the exit reason is not <code>APR_PROC_CHECK_EXIT()</code>, or if <em>exitcode</em> is NULL and the exit code is non-zero, then an <code>SVN_ERR_EXTERNAL_PROGRAM</code> error will be returned.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div><p>
<a class="anchor" name="59b7be5b78cc045ed972b226e06ab509"></a><!-- doxytag: member="svn_io.h::svn_stringbuf_from_aprfile" ref="59b7be5b78cc045ed972b226e06ab509" args="(svn_stringbuf_t **result, apr_file_t *file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stringbuf_from_aprfile           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets <em>*result</em> to a string containing the contents of the already opened <em>file</em>. 
<p>
Reads from the current position in file to the end. Does not close the file or reset the cursor position. 
</div>
</div><p>
<a class="anchor" name="2ffefcabf44f9e9fb2f71d409fcf782e"></a><!-- doxytag: member="svn_io.h::svn_stringbuf_from_file" ref="2ffefcabf44f9e9fb2f71d409fcf782e" args="(svn_stringbuf_t **result, const char *filename, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stringbuf_from_file           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to <a class="el" href="svn__io_8h.html#9135b41547d59296fc54c8316278a0d6" title="Set *result to a string containing the contents of filename, which is either &quot;-&quot;...">svn_stringbuf_from_file2()</a>, except that if <em>filename</em> is "-", return the error <code>SVN_ERR_UNSUPPORTED_FEATURE</code> and don't touch <em>*result</em>. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000125">Deprecated:</a></b></dt><dd>Provided for backwards compatibility with the 1.4 API. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9135b41547d59296fc54c8316278a0d6"></a><!-- doxytag: member="svn_io.h::svn_stringbuf_from_file2" ref="9135b41547d59296fc54c8316278a0d6" args="(svn_stringbuf_t **result, const char *filename, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stringbuf_from_file2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*result</em> to a string containing the contents of <em>filename</em>, which is either "-" (indicating that stdin should be read) or the utf8-encoded path of a real file. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Callers should be aware of possible unexpected results when using this function to read from stdin where additional stdin-reading processes abound. For example, if a program tries both to invoke an external editor and to read from stdin, stdin could be trashed and the editor might act funky or die outright.</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 24 16:18:28 2008 for Subversion by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
