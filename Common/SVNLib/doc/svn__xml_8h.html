<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Subversion: svn_xml.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>svn_xml.h File Reference</h1>XML code shared by various Subversion libraries. <a href="#_details">More...</a>
<p>
<code>#include &lt;apr.h&gt;</code><br>
<code>#include &lt;apr_pools.h&gt;</code><br>
<code>#include &lt;apr_hash.h&gt;</code><br>
<code>#include &quot;<a class="el" href="svn__error_8h-source.html">svn_error.h</a>&quot;</code><br>

<p>
<a href="svn__xml_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="05c7a03105de7809b8760f1425a888da"></a><!-- doxytag: member="svn_xml.h::svn_xml_parser_t" ref="05c7a03105de7809b8760f1425a888da" args="" -->
typedef struct <a class="el" href="svn__xml_8h.html#05c7a03105de7809b8760f1425a888da">svn_xml_parser_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#05c7a03105de7809b8760f1425a888da">svn_xml_parser_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A generalized Subversion XML parser object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9b28b96800ab1dacc3aaac31b3aae70c"></a><!-- doxytag: member="svn_xml.h::svn_xml_start_elem" ref="9b28b96800ab1dacc3aaac31b3aae70c" args=")(void *baton, const char *name, const char **atts)" -->
typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>svn_xml_start_elem</b> )(void *baton, const char *name, const char **atts)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8b40e822eb46cd2614e2f97d7f58c108"></a><!-- doxytag: member="svn_xml.h::svn_xml_end_elem" ref="8b40e822eb46cd2614e2f97d7f58c108" args=")(void *baton, const char *name)" -->
typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>svn_xml_end_elem</b> )(void *baton, const char *name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="135ad18229b9b856b4527d471c14ddee"></a><!-- doxytag: member="svn_xml.h::svn_xml_char_data" ref="135ad18229b9b856b4527d471c14ddee" args=")(void *baton, const char *data, apr_size_t len)" -->
typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>svn_xml_char_data</b> )(void *baton, const char *data, apr_size_t len)</td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#96fab6557db17be482982e30d7becbc6">svn_xml_open_tag_style</a> { <br>
&nbsp;&nbsp;<a class="el" href="svn__xml_8h.html#96fab6557db17be482982e30d7becbc6325a91b8ed7a386421fbc4efe6af7751">svn_xml_normal</a> =  1, 
<br>
&nbsp;&nbsp;<a class="el" href="svn__xml_8h.html#96fab6557db17be482982e30d7becbc61d0dae4e4332a29d0cb9e467239f50df">svn_xml_protect_pcdata</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="svn__xml_8h.html#96fab6557db17be482982e30d7becbc66fdb5e284fb439d68e280d9235127eb5">svn_xml_self_closing</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used as style argument to <a class="el" href="svn__xml_8h.html#93ba8523ad3d6063db280ff9d2db544b" title="Store a new xml tag tagname in *str.">svn_xml_make_open_tag()</a> and friends.  <a href="svn__xml_8h.html#96fab6557db17be482982e30d7becbc6">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#4e1f838f920694c5d8fb572bb8f158f3">svn_xml_is_xml_safe</a> (const char *data, apr_size_t len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if a string of character <em>data</em> of length <em>len</em> is a safe bet for use with the svn_xml_escape_* functions found in this header.  <a href="#4e1f838f920694c5d8fb572bb8f158f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#791aebe273d97127c89d03e20d687fee">svn_xml_escape_cdata_stringbuf</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **outstr, const <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *string, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create or append in <em>*outstr</em> an xml-escaped version of <em>string</em>, suitable for output as character data.  <a href="#791aebe273d97127c89d03e20d687fee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="203e4a15ff06354096450be45a57ad63"></a><!-- doxytag: member="svn_xml.h::svn_xml_escape_cdata_string" ref="203e4a15ff06354096450be45a57ad63" args="(svn_stringbuf_t **outstr, const svn_string_t *string, apr_pool_t *pool)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#203e4a15ff06354096450be45a57ad63">svn_xml_escape_cdata_string</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **outstr, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *string, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="svn__xml_8h.html#791aebe273d97127c89d03e20d687fee" title="Create or append in *outstr an xml-escaped version of string, suitable for output...">svn_xml_escape_cdata_stringbuf()</a>, but <em>string</em> is an <code><a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a></code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="68b27ad8ed4dc71a4e94f00a3402f148"></a><!-- doxytag: member="svn_xml.h::svn_xml_escape_cdata_cstring" ref="68b27ad8ed4dc71a4e94f00a3402f148" args="(svn_stringbuf_t **outstr, const char *string, apr_pool_t *pool)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#68b27ad8ed4dc71a4e94f00a3402f148">svn_xml_escape_cdata_cstring</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **outstr, const char *string, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="svn__xml_8h.html#791aebe273d97127c89d03e20d687fee" title="Create or append in *outstr an xml-escaped version of string, suitable for output...">svn_xml_escape_cdata_stringbuf()</a>, but <em>string</em> is a NULL-terminated C string. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#dc69586dc0963c1e90141fda77041137">svn_xml_escape_attr_stringbuf</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **outstr, const <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *string, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create or append in <em>*outstr</em> an xml-escaped version of <em>string</em>, suitable for output as an attribute value.  <a href="#dc69586dc0963c1e90141fda77041137"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="15cf427831b36add12969b80df9576f4"></a><!-- doxytag: member="svn_xml.h::svn_xml_escape_attr_string" ref="15cf427831b36add12969b80df9576f4" args="(svn_stringbuf_t **outstr, const svn_string_t *string, apr_pool_t *pool)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#15cf427831b36add12969b80df9576f4">svn_xml_escape_attr_string</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **outstr, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *string, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="svn__xml_8h.html#dc69586dc0963c1e90141fda77041137" title="Create or append in *outstr an xml-escaped version of string, suitable for output...">svn_xml_escape_attr_stringbuf()</a>, but <em>string</em> is an <code><a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a></code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fddce35e71a70d50b652c9a2b61a7506"></a><!-- doxytag: member="svn_xml.h::svn_xml_escape_attr_cstring" ref="fddce35e71a70d50b652c9a2b61a7506" args="(svn_stringbuf_t **outstr, const char *string, apr_pool_t *pool)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#fddce35e71a70d50b652c9a2b61a7506">svn_xml_escape_attr_cstring</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **outstr, const char *string, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="svn__xml_8h.html#dc69586dc0963c1e90141fda77041137" title="Create or append in *outstr an xml-escaped version of string, suitable for output...">svn_xml_escape_attr_stringbuf()</a>, but <em>string</em> is a NULL-terminated C string. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#c1070a1f742deb7666f1fa02a7794ec7">svn_xml_fuzzy_escape</a> (const char *string, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return UTF-8 string <em>string</em> if it contains no characters that are unrepresentable in XML.  <a href="#c1070a1f742deb7666f1fa02a7794ec7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1f8f1b81e03621e15d5d4a3412ded766"></a><!-- doxytag: member="svn_xml.h::svn_xml_make_parser" ref="1f8f1b81e03621e15d5d4a3412ded766" args="(void *baton, svn_xml_start_elem start_handler, svn_xml_end_elem end_handler, svn_xml_char_data data_handler, apr_pool_t *pool)" -->
<a class="el" href="svn__xml_8h.html#05c7a03105de7809b8760f1425a888da">svn_xml_parser_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#1f8f1b81e03621e15d5d4a3412ded766">svn_xml_make_parser</a> (void *baton, svn_xml_start_elem start_handler, svn_xml_end_elem end_handler, svn_xml_char_data data_handler, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a general Subversion XML parser. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8aae298d9c4b403502fd03f8c3e491de"></a><!-- doxytag: member="svn_xml.h::svn_xml_free_parser" ref="8aae298d9c4b403502fd03f8c3e491de" args="(svn_xml_parser_t *svn_parser)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#8aae298d9c4b403502fd03f8c3e491de">svn_xml_free_parser</a> (<a class="el" href="svn__xml_8h.html#05c7a03105de7809b8760f1425a888da">svn_xml_parser_t</a> *svn_parser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a general Subversion XML parser. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#57a5745b6c3a8a78f6cf96cec7322593">svn_xml_parse</a> (<a class="el" href="svn__xml_8h.html#05c7a03105de7809b8760f1425a888da">svn_xml_parser_t</a> *svn_parser, const char *buf, apr_size_t len, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> is_final)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Push <em>len</em> bytes of xml data in <em>buf</em> at <em>svn_parser</em>.  <a href="#57a5745b6c3a8a78f6cf96cec7322593"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#c42af5bd3d46c569326baf9fe3dee787">svn_xml_signal_bailout</a> (<a class="el" href="structsvn__error__t.html">svn_error_t</a> *error, <a class="el" href="svn__xml_8h.html#05c7a03105de7809b8760f1425a888da">svn_xml_parser_t</a> *svn_parser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The way to officially bail out of xml parsing.  <a href="#c42af5bd3d46c569326baf9fe3dee787"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#07a589fa0a35a7550ac452225eacefa0">svn_xml_get_attr_value</a> (const char *name, const char **atts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value associated with <em>name</em> in expat attribute array <em>atts</em>, else return <code>NULL</code>.  <a href="#07a589fa0a35a7550ac452225eacefa0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">apr_hash_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#1914b5fb6cf24bb299ea171eddb681f7">svn_xml_ap_to_hash</a> (va_list ap, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an attribute hash from <code>va_list</code> <em>ap</em>.  <a href="#1914b5fb6cf24bb299ea171eddb681f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">apr_hash_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#46344c54e4a536df1cd0d6531e4a4934">svn_xml_make_att_hash</a> (const char **atts, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a hash that corresponds to Expat xml attribute list <em>atts</em>.  <a href="#46344c54e4a536df1cd0d6531e4a4934"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="078fe0e91283b54183cfafb69d733adf"></a><!-- doxytag: member="svn_xml.h::svn_xml_hash_atts_preserving" ref="078fe0e91283b54183cfafb69d733adf" args="(const char **atts, apr_hash_t *ht, apr_pool_t *pool)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#078fe0e91283b54183cfafb69d733adf">svn_xml_hash_atts_preserving</a> (const char **atts, apr_hash_t *ht, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="svn__xml_8h.html#46344c54e4a536df1cd0d6531e4a4934" title="Create a hash that corresponds to Expat xml attribute list atts.">svn_xml_make_att_hash()</a>, but takes a hash and preserves any key/value pairs already in it. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="388721068598aacbdf67e2f9304df67f"></a><!-- doxytag: member="svn_xml.h::svn_xml_hash_atts_overlaying" ref="388721068598aacbdf67e2f9304df67f" args="(const char **atts, apr_hash_t *ht, apr_pool_t *pool)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#388721068598aacbdf67e2f9304df67f">svn_xml_hash_atts_overlaying</a> (const char **atts, apr_hash_t *ht, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="svn__xml_8h.html#46344c54e4a536df1cd0d6531e4a4934" title="Create a hash that corresponds to Expat xml attribute list atts.">svn_xml_make_att_hash()</a>, but takes a hash and overwrites key/value pairs already in it that also appear in <em>atts</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#8952697d8cace5f4db1a05958007b04b">svn_xml_make_header</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **str, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an XML header and return it in <em>*str</em>.  <a href="#8952697d8cace5f4db1a05958007b04b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#93ba8523ad3d6063db280ff9d2db544b">svn_xml_make_open_tag</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **str, apr_pool_t *pool, enum <a class="el" href="svn__xml_8h.html#96fab6557db17be482982e30d7becbc6">svn_xml_open_tag_style</a> style, const char *tagname,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store a new xml tag <em>tagname</em> in <em>*str</em>.  <a href="#93ba8523ad3d6063db280ff9d2db544b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b08389a7d146e02b1f2e2ce6ef49f243"></a><!-- doxytag: member="svn_xml.h::svn_xml_make_open_tag_v" ref="b08389a7d146e02b1f2e2ce6ef49f243" args="(svn_stringbuf_t **str, apr_pool_t *pool, enum svn_xml_open_tag_style style, const char *tagname, va_list ap)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#b08389a7d146e02b1f2e2ce6ef49f243">svn_xml_make_open_tag_v</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **str, apr_pool_t *pool, enum <a class="el" href="svn__xml_8h.html#96fab6557db17be482982e30d7becbc6">svn_xml_open_tag_style</a> style, const char *tagname, va_list ap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="svn__xml_8h.html#93ba8523ad3d6063db280ff9d2db544b" title="Store a new xml tag tagname in *str.">svn_xml_make_open_tag()</a>, but takes a <code>va_list</code> instead of being variadic. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#2505af51b37f20fc09716f7a09718794">svn_xml_make_open_tag_hash</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **str, apr_pool_t *pool, enum <a class="el" href="svn__xml_8h.html#96fab6557db17be482982e30d7becbc6">svn_xml_open_tag_style</a> style, const char *tagname, apr_hash_t *attributes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="svn__xml_8h.html#93ba8523ad3d6063db280ff9d2db544b" title="Store a new xml tag tagname in *str.">svn_xml_make_open_tag()</a>, but takes a hash table of attributes (<code>char *</code> keys mapping to <code>char *</code> values).  <a href="#2505af51b37f20fc09716f7a09718794"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__xml_8h.html#828f71e7c3e1c2550282651e2de529c3">svn_xml_make_close_tag</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **str, apr_pool_t *pool, const char *tagname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes a close tag.  <a href="#828f71e7c3e1c2550282651e2de529c3"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
XML code shared by various Subversion libraries. 
<p>

<p>Definition in file <a class="el" href="svn__xml_8h-source.html">svn_xml.h</a>.</p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="96fab6557db17be482982e30d7becbc6"></a><!-- doxytag: member="svn_xml.h::svn_xml_open_tag_style" ref="96fab6557db17be482982e30d7becbc6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="svn__xml_8h.html#96fab6557db17be482982e30d7becbc6">svn_xml_open_tag_style</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used as style argument to <a class="el" href="svn__xml_8h.html#93ba8523ad3d6063db280ff9d2db544b" title="Store a new xml tag tagname in *str.">svn_xml_make_open_tag()</a> and friends. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="96fab6557db17be482982e30d7becbc6325a91b8ed7a386421fbc4efe6af7751"></a><!-- doxytag: member="svn_xml_normal" ref="96fab6557db17be482982e30d7becbc6325a91b8ed7a386421fbc4efe6af7751" args="" -->svn_xml_normal</em>&nbsp;</td><td>
&lt;tag . 
<p>
..&gt; </td></tr>
<tr><td valign="top"><em><a class="anchor" name="96fab6557db17be482982e30d7becbc61d0dae4e4332a29d0cb9e467239f50df"></a><!-- doxytag: member="svn_xml_protect_pcdata" ref="96fab6557db17be482982e30d7becbc61d0dae4e4332a29d0cb9e467239f50df" args="" -->svn_xml_protect_pcdata</em>&nbsp;</td><td>
&lt;tag . 
<p>
..&gt;, no cosmetic newline </td></tr>
<tr><td valign="top"><em><a class="anchor" name="96fab6557db17be482982e30d7becbc66fdb5e284fb439d68e280d9235127eb5"></a><!-- doxytag: member="svn_xml_self_closing" ref="96fab6557db17be482982e30d7becbc66fdb5e284fb439d68e280d9235127eb5" args="" -->svn_xml_self_closing</em>&nbsp;</td><td>
&lt;tag . 
<p>
../&gt; </td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="svn__xml_8h-source.html#l00042">42</a> of file <a class="el" href="svn__xml_8h-source.html">svn_xml.h</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="1914b5fb6cf24bb299ea171eddb681f7"></a><!-- doxytag: member="svn_xml.h::svn_xml_ap_to_hash" ref="1914b5fb6cf24bb299ea171eddb681f7" args="(va_list ap, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_hash_t* svn_xml_ap_to_hash           </td>
          <td>(</td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an attribute hash from <code>va_list</code> <em>ap</em>. 
<p>
The contents of <em>ap</em> are alternating <code>char *</code> keys and <code>char *</code> vals, terminated by a final <code>NULL</code> falling on an even index (zero-based). 
</div>
</div><p>
<a class="anchor" name="dc69586dc0963c1e90141fda77041137"></a><!-- doxytag: member="svn_xml.h::svn_xml_escape_attr_stringbuf" ref="dc69586dc0963c1e90141fda77041137" args="(svn_stringbuf_t **outstr, const svn_stringbuf_t *string, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_xml_escape_attr_stringbuf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **&nbsp;</td>
          <td class="paramname"> <em>outstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create or append in <em>*outstr</em> an xml-escaped version of <em>string</em>, suitable for output as an attribute value. 
<p>
If <em>*outstr</em> is <code>NULL</code>, store a new stringbuf, else append to the existing stringbuf there. 
</div>
</div><p>
<a class="anchor" name="791aebe273d97127c89d03e20d687fee"></a><!-- doxytag: member="svn_xml.h::svn_xml_escape_cdata_stringbuf" ref="791aebe273d97127c89d03e20d687fee" args="(svn_stringbuf_t **outstr, const svn_stringbuf_t *string, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_xml_escape_cdata_stringbuf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **&nbsp;</td>
          <td class="paramname"> <em>outstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create or append in <em>*outstr</em> an xml-escaped version of <em>string</em>, suitable for output as character data. 
<p>
If <em>*outstr</em> is <code>NULL</code>, store a new stringbuf, else append to the existing stringbuf there. 
</div>
</div><p>
<a class="anchor" name="c1070a1f742deb7666f1fa02a7794ec7"></a><!-- doxytag: member="svn_xml.h::svn_xml_fuzzy_escape" ref="c1070a1f742deb7666f1fa02a7794ec7" args="(const char *string, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_xml_fuzzy_escape           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return UTF-8 string <em>string</em> if it contains no characters that are unrepresentable in XML. 
<p>
Else, return a copy of <em>string</em>, allocated in <em>pool</em>, with each unrepresentable character replaced by "?\uuu", where "uuu" is the three-digit unsigned decimal value of that character.<p>
Neither the input nor the output need be valid XML; however, the output can always be safely XML-escaped.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The current implementation treats all Unicode characters as representable, except for most ASCII control characters (the exceptions being CR, LF, and TAB, which are valid in XML). There may be other UTF-8 characters that are invalid in XML; see <a href="http://subversion.tigris.org/servlets/ReadMsg?list=dev&msgNo=90591">http://subversion.tigris.org/servlets/ReadMsg?list=dev&amp;msgNo=90591</a> and its thread for details.</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.2. </dd></dl>

</div>
</div><p>
<a class="anchor" name="07a589fa0a35a7550ac452225eacefa0"></a><!-- doxytag: member="svn_xml.h::svn_xml_get_attr_value" ref="07a589fa0a35a7550ac452225eacefa0" args="(const char *name, const char **atts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_xml_get_attr_value           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>atts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the value associated with <em>name</em> in expat attribute array <em>atts</em>, else return <code>NULL</code>. 
<p>
(There could never be a <code>NULL</code> attribute value in the XML, although the empty string is possible.)<p>
<em>atts</em> is an array of c-strings: even-numbered indexes are names, odd-numbers hold values. If all is right, it should end on an even-numbered index pointing to <code>NULL</code>. 
</div>
</div><p>
<a class="anchor" name="4e1f838f920694c5d8fb572bb8f158f3"></a><!-- doxytag: member="svn_xml.h::svn_xml_is_xml_safe" ref="4e1f838f920694c5d8fb572bb8f158f3" args="(const char *data, apr_size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_xml_is_xml_safe           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine if a string of character <em>data</em> of length <em>len</em> is a safe bet for use with the svn_xml_escape_* functions found in this header. 
<p>
Return <code>TRUE</code> if it is, <code>FALSE</code> otherwise.<p>
Essentially, this function exists to determine whether or not simply running a string of bytes through the Subversion XML escape routines will produce legitimate XML. It should only be necessary for data which might contain bytes that cannot be safely encoded into XML (certain control characters, for example). 
</div>
</div><p>
<a class="anchor" name="46344c54e4a536df1cd0d6531e4a4934"></a><!-- doxytag: member="svn_xml.h::svn_xml_make_att_hash" ref="46344c54e4a536df1cd0d6531e4a4934" args="(const char **atts, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_hash_t* svn_xml_make_att_hash           </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>atts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a hash that corresponds to Expat xml attribute list <em>atts</em>. 
<p>
The hash's keys and values are <code>char *</code>'s.<p>
<em>atts</em> may be NULL, in which case you just get an empty hash back (this makes life more convenient for some callers). 
</div>
</div><p>
<a class="anchor" name="828f71e7c3e1c2550282651e2de529c3"></a><!-- doxytag: member="svn_xml.h::svn_xml_make_close_tag" ref="828f71e7c3e1c2550282651e2de529c3" args="(svn_stringbuf_t **str, apr_pool_t *pool, const char *tagname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_xml_make_close_tag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tagname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes a close tag. 
<p>

</div>
</div><p>
<a class="anchor" name="8952697d8cace5f4db1a05958007b04b"></a><!-- doxytag: member="svn_xml.h::svn_xml_make_header" ref="8952697d8cace5f4db1a05958007b04b" args="(svn_stringbuf_t **str, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_xml_make_header           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an XML header and return it in <em>*str</em>. 
<p>
Fully-formed XML documents should start out with a header, something like &lt;?xml version="1.0" encoding="utf-8"?&gt;<p>
This function returns such a header. <em>*str</em> must either be <code>NULL</code>, in which case a new string is created, or it must point to an existing string to be appended to. 
</div>
</div><p>
<a class="anchor" name="93ba8523ad3d6063db280ff9d2db544b"></a><!-- doxytag: member="svn_xml.h::svn_xml_make_open_tag" ref="93ba8523ad3d6063db280ff9d2db544b" args="(svn_stringbuf_t **str, apr_pool_t *pool, enum svn_xml_open_tag_style style, const char *tagname,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_xml_make_open_tag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="svn__xml_8h.html#96fab6557db17be482982e30d7becbc6">svn_xml_open_tag_style</a>&nbsp;</td>
          <td class="paramname"> <em>style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tagname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Store a new xml tag <em>tagname</em> in <em>*str</em>. 
<p>
If <em>str</em> is <code>NULL</code>, allocate <em>*str</em> in <em>pool</em>; else append the new tag to <em>*str</em>, allocating in <em>str's</em> pool<p>
Take the tag's attributes from varargs, a NULL-terminated list of alternating <code>char *</code> key and <code>char *</code> val. Do xml-escaping on each val.<p>
<em>style</em> is one of the enumerated styles in <code>svn_xml_open_tag_style</code>. 
</div>
</div><p>
<a class="anchor" name="2505af51b37f20fc09716f7a09718794"></a><!-- doxytag: member="svn_xml.h::svn_xml_make_open_tag_hash" ref="2505af51b37f20fc09716f7a09718794" args="(svn_stringbuf_t **str, apr_pool_t *pool, enum svn_xml_open_tag_style style, const char *tagname, apr_hash_t *attributes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_xml_make_open_tag_hash           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="svn__xml_8h.html#96fab6557db17be482982e30d7becbc6">svn_xml_open_tag_style</a>&nbsp;</td>
          <td class="paramname"> <em>style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tagname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&nbsp;</td>
          <td class="paramname"> <em>attributes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="svn__xml_8h.html#93ba8523ad3d6063db280ff9d2db544b" title="Store a new xml tag tagname in *str.">svn_xml_make_open_tag()</a>, but takes a hash table of attributes (<code>char *</code> keys mapping to <code>char *</code> values). 
<p>
You might ask, why not just provide svn_xml_make_tag_atts()?<p>
The reason is that a hash table is the most natural interface to an attribute list; the fact that Expat uses <code>char **</code> atts instead is certainly a defensible implementation decision, but since we'd have to have special code to support such lists throughout Subversion anyway, we might as well write that code for the natural interface (hashes) and then convert in the few cases where conversion is needed. Someday it might even be nice to change expat-lite to work with apr hashes.<p>
See conversion functions <a class="el" href="svn__xml_8h.html#46344c54e4a536df1cd0d6531e4a4934" title="Create a hash that corresponds to Expat xml attribute list atts.">svn_xml_make_att_hash()</a> and svn_xml_make_att_hash_overlaying(). Callers should use those to convert Expat attr lists into hashes when necessary. 
</div>
</div><p>
<a class="anchor" name="57a5745b6c3a8a78f6cf96cec7322593"></a><!-- doxytag: member="svn_xml.h::svn_xml_parse" ref="57a5745b6c3a8a78f6cf96cec7322593" args="(svn_xml_parser_t *svn_parser, const char *buf, apr_size_t len, svn_boolean_t is_final)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_xml_parse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__xml_8h.html#05c7a03105de7809b8760f1425a888da">svn_xml_parser_t</a> *&nbsp;</td>
          <td class="paramname"> <em>svn_parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>is_final</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Push <em>len</em> bytes of xml data in <em>buf</em> at <em>svn_parser</em>. 
<p>
If this is the final push, <em>is_final</em> must be set.<p>
An error will be returned if there was a syntax problem in the XML, or if any of the callbacks set an error using <a class="el" href="svn__xml_8h.html#c42af5bd3d46c569326baf9fe3dee787" title="The way to officially bail out of xml parsing.">svn_xml_signal_bailout()</a>.<p>
If an error is returned, the <code>svn_xml_parser_t</code> will have been freed automatically, so the caller should not call <a class="el" href="svn__xml_8h.html#8aae298d9c4b403502fd03f8c3e491de" title="Free a general Subversion XML parser.">svn_xml_free_parser()</a>. 
</div>
</div><p>
<a class="anchor" name="c42af5bd3d46c569326baf9fe3dee787"></a><!-- doxytag: member="svn_xml.h::svn_xml_signal_bailout" ref="c42af5bd3d46c569326baf9fe3dee787" args="(svn_error_t *error, svn_xml_parser_t *svn_parser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_xml_signal_bailout           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__xml_8h.html#05c7a03105de7809b8760f1425a888da">svn_xml_parser_t</a> *&nbsp;</td>
          <td class="paramname"> <em>svn_parser</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The way to officially bail out of xml parsing. 
<p>
Store <em>error</em> in <em>svn_parser</em> and set all expat callbacks to <code>NULL</code>. 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 24 16:18:29 2008 for Subversion by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
