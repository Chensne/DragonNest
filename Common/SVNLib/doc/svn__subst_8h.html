<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Subversion: svn_subst.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>svn_subst.h File Reference</h1>Data substitution (keywords and EOL style). <a href="#_details">More...</a>
<p>
<code>#include &quot;<a class="el" href="svn__types_8h-source.html">svn_types.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="svn__string_8h-source.html">svn_string.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="svn__io_8h-source.html">svn_io.h</a>&quot;</code><br>

<p>
<a href="svn__subst_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Values used in keyword expansion.  <a href="structsvn__subst__keywords__t.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef enum <a class="el" href="svn__subst_8h.html#160543c34edb8318de8cbe4543bbca28">svn_subst_eol_style</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Valid states for 'svn:eol-style' property.  <a href="#82d6196808784a7a73e098f8d8534edb"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#160543c34edb8318de8cbe4543bbca28">svn_subst_eol_style</a> { <br>
&nbsp;&nbsp;<a class="el" href="svn__subst_8h.html#160543c34edb8318de8cbe4543bbca286e1bf631a8574e3cf1e52b6599785fdf">svn_subst_eol_style_unknown</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="svn__subst_8h.html#160543c34edb8318de8cbe4543bbca28c33cc2b19c97a910b90d4efef275043f">svn_subst_eol_style_none</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="svn__subst_8h.html#160543c34edb8318de8cbe4543bbca282fdd9ef5ba015f6ecc6d59458df5c055">svn_subst_eol_style_native</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="svn__subst_8h.html#160543c34edb8318de8cbe4543bbca286e778790cbc23c4028f73aaaf5524069">svn_subst_eol_style_fixed</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Valid states for 'svn:eol-style' property.  <a href="svn__subst_8h.html#160543c34edb8318de8cbe4543bbca28">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#dee8f25af905f8a450092b61ba79ea5c">svn_subst_eol_style_from_value</a> (<a class="el" href="svn__subst_8h.html#82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a> *style, const char **eol, const char *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*style</em> to the appropriate <code>svn_subst_eol_style_t</code> and <em>*eol</em> to the appropriate cstring for a given svn:eol-style property value.  <a href="#dee8f25af905f8a450092b61ba79ea5c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#8655a649e193b8eb96ba8ea59433a6b3">svn_subst_translation_required</a> (<a class="el" href="svn__subst_8h.html#82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a> style, const char *eol, apr_hash_t *keywords, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> special, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> force_eol_check)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates whether the working copy and normalized versions of a file with the given the parameters differ.  <a href="#8655a649e193b8eb96ba8ea59433a6b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#42f73d2001ac889b1d9883c5601e55f8">svn_subst_build_keywords2</a> (apr_hash_t **kw, const char *keywords_string, const char *rev, const char *url, apr_time_t date, const char *author, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*kw</em> to a new keywords hash filled with the appropriate contents given a <em>keywords_string</em> (the contents of the svn:keywords property for the file in question), the revision <em>rev</em>, the <em>url</em>, the <em>date</em> the file was committed on, and the <em>author</em> of the last commit.  <a href="#42f73d2001ac889b1d9883c5601e55f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#b004042c7b9a26349d68d625128041c8">svn_subst_build_keywords</a> (<a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *kw, const char *keywords_string, const char *rev, const char *url, apr_time_t date, const char *author, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="svn__subst_8h.html#42f73d2001ac889b1d9883c5601e55f8" title="Set *kw to a new keywords hash filled with the appropriate contents given a keywords_string...">svn_subst_build_keywords2()</a> except that it populates an existing structure <em>*kw</em> instead of creating a keywords hash.  <a href="#b004042c7b9a26349d68d625128041c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#c1bd03f2381659cd0358dd74e7f882e5">svn_subst_keywords_differ2</a> (apr_hash_t *a, apr_hash_t *b, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> compare_values, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>TRUE</code> if <em>a</em> and <em>b</em> do not hold the same keywords.  <a href="#c1bd03f2381659cd0358dd74e7f882e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#598cb9236b80298a904c4b8d7b5ab113">svn_subst_keywords_differ</a> (const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *a, const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *b, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> compare_values)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="svn__subst_8h.html#c1bd03f2381659cd0358dd74e7f882e5" title="Return TRUE if a and b do not hold the same keywords.">svn_subst_keywords_differ2()</a> except that it compares two <code><a class="el" href="structsvn__subst__keywords__t.html" title="Values used in keyword expansion.">svn_subst_keywords_t</a></code> structs instead of keyword hashes.  <a href="#598cb9236b80298a904c4b8d7b5ab113"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#823ce051fe6718eb2af8473d9e46a90c">svn_subst_translate_stream3</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *src, <a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *dst, const char *eol_str, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> repair, apr_hash_t *keywords, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> expand, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy and translate the data in stream <em>src</em> into stream <em>dst</em>.  <a href="#823ce051fe6718eb2af8473d9e46a90c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#dd5d644ecc07e3d679c6e69c3ea0f1da">svn_subst_stream_translated</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const char *eol_str, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> repair, apr_hash_t *keywords, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> expand, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a stream which performs eol translation and keyword expansion when read from or written to.  <a href="#dd5d644ecc07e3d679c6e69c3ea0f1da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#4f47ae70ef1b063543924891f3fb71d6">svn_subst_stream_translated_to_normal_form</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **stream, <a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *source, <a class="el" href="svn__subst_8h.html#82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a> eol_style, const char *eol_str, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> always_repair_eols, apr_hash_t *keywords, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a stream which performs eol translation and keyword expansion when read from or written to.  <a href="#4f47ae70ef1b063543924891f3fb71d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#e4e5f664140910fecfce37994ba949dc">svn_subst_stream_from_specialfile</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **stream, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a stream which translates the special file at <em>path</em> to the internal representation for special files when read from.  <a href="#e4e5f664140910fecfce37994ba949dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#06f015a633236b8f33d7c5543c587053">svn_subst_translate_stream2</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *src, <a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *dst, const char *eol_str, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> repair, const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *keywords, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> expand, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="svn__subst_8h.html#823ce051fe6718eb2af8473d9e46a90c" title="Copy and translate the data in stream src into stream dst.">svn_subst_translate_stream3()</a> except relies upon a <code><a class="el" href="structsvn__subst__keywords__t.html" title="Values used in keyword expansion.">svn_subst_keywords_t</a></code> struct instead of a hash for the keywords.  <a href="#06f015a633236b8f33d7c5543c587053"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#8ecd3f591a316f3750a42fc5206790f9">svn_subst_translate_stream</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *src, <a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *dst, const char *eol_str, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> repair, const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *keywords, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> expand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="svn__subst_8h.html#06f015a633236b8f33d7c5543c587053" title="Similar to svn_subst_translate_stream3() except relies upon a svn_subst_keywords_t...">svn_subst_translate_stream2()</a>, but does not take a <em>pool</em> argument, instead creates a temporary subpool of the global pool, and destroys it before returning.  <a href="#8ecd3f591a316f3750a42fc5206790f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#18dbb80be4ef26b2a978454716539d0c">svn_subst_copy_and_translate3</a> (const char *src, const char *dst, const char *eol_str, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> repair, apr_hash_t *keywords, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> expand, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> special, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translates the file at path <em>src</em> into a file at path <em>dst</em>.  <a href="#18dbb80be4ef26b2a978454716539d0c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#9bbccf6a71c3e07a112e1e44f9ecec98">svn_subst_copy_and_translate2</a> (const char *src, const char *dst, const char *eol_str, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> repair, const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *keywords, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> expand, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> special, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="svn__subst_8h.html#18dbb80be4ef26b2a978454716539d0c" title="Translates the file at path src into a file at path dst.">svn_subst_copy_and_translate3()</a> except that <em>keywords</em> is a <code><a class="el" href="structsvn__subst__keywords__t.html" title="Values used in keyword expansion.">svn_subst_keywords_t</a></code> struct instead of a keywords hash.  <a href="#9bbccf6a71c3e07a112e1e44f9ecec98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#a9dfe3fade520c1ca5b1edbe50989658">svn_subst_copy_and_translate</a> (const char *src, const char *dst, const char *eol_str, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> repair, const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *keywords, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> expand, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="svn__subst_8h.html#9bbccf6a71c3e07a112e1e44f9ecec98" title="Similar to svn_subst_copy_and_translate3() except that keywords is a svn_subst_keywords_t...">svn_subst_copy_and_translate2()</a> except that <em>special</em> is always set to <code>FALSE</code>.  <a href="#a9dfe3fade520c1ca5b1edbe50989658"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#9030b641b1ef299e68c35670014ea747">svn_subst_translate_cstring2</a> (const char *src, const char **dst, const char *eol_str, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> repair, apr_hash_t *keywords, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> expand, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience routine: a variant of <a class="el" href="svn__subst_8h.html#823ce051fe6718eb2af8473d9e46a90c" title="Copy and translate the data in stream src into stream dst.">svn_subst_translate_stream3()</a> which operates on cstrings.  <a href="#9030b641b1ef299e68c35670014ea747"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#ab1b28fcddc78254ca6b6ed4ad149b89">svn_subst_translate_cstring</a> (const char *src, const char **dst, const char *eol_str, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> repair, const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *keywords, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> expand, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="svn__subst_8h.html#9030b641b1ef299e68c35670014ea747" title="Convenience routine: a variant of svn_subst_translate_stream3() which operates on...">svn_subst_translate_cstring2()</a> except that <em>keywords</em> is a <code><a class="el" href="structsvn__subst__keywords__t.html" title="Values used in keyword expansion.">svn_subst_keywords_t</a></code> struct instead of a keywords hash.  <a href="#ab1b28fcddc78254ca6b6ed4ad149b89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#ce41f93ffd67e19f15cc705a855e8a98">svn_subst_translate_to_normal_form</a> (const char *src, const char *dst, <a class="el" href="svn__subst_8h.html#82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a> eol_style, const char *eol_str, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> always_repair_eols, apr_hash_t *keywords, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> special, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translates a file <em>src</em> in working copy form to a file <em>dst</em> in normal form.  <a href="#ce41f93ffd67e19f15cc705a855e8a98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#9174c224c4fc71aaba0d2b9e93482df6">svn_subst_stream_detranslated</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **stream_p, const char *src, <a class="el" href="svn__subst_8h.html#82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a> eol_style, const char *eol_str, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> always_repair_eols, apr_hash_t *keywords, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> special, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*stream_p</em> to a stream that detranslates the file <em>src</em> from working copy form to normal form, allocated in <em>pool</em>.  <a href="#9174c224c4fc71aaba0d2b9e93482df6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#626c5dcfbbf5057ebc0e384187f6d330">svn_subst_translate_string</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **new_value, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, const char *encoding, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate the data in <em>value</em> (assumed to be in encoded in charset <em>encoding</em>) to UTF8 and LF line-endings.  <a href="#626c5dcfbbf5057ebc0e384187f6d330"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__subst_8h.html#7b0510e7ebae885c80b227ccc3a13685">svn_subst_detranslate_string</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **new_value, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> for_output, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate the data in <em>value</em> from UTF8 and LF line-endings into native locale and native line-endings, or to the output locale if <em>for_output</em> is TRUE.  <a href="#7b0510e7ebae885c80b227ccc3a13685"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Data substitution (keywords and EOL style). 
<p>

<p>Definition in file <a class="el" href="svn__subst_8h-source.html">svn_subst.h</a>.</p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="82d6196808784a7a73e098f8d8534edb"></a><!-- doxytag: member="svn_subst.h::svn_subst_eol_style_t" ref="82d6196808784a7a73e098f8d8534edb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="svn__subst_8h.html#160543c34edb8318de8cbe4543bbca28">svn_subst_eol_style</a>  <a class="el" href="svn__subst_8h.html#82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Valid states for 'svn:eol-style' property. 
<p>
Property nonexistence is equivalent to 'none'. 
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="160543c34edb8318de8cbe4543bbca28"></a><!-- doxytag: member="svn_subst.h::svn_subst_eol_style" ref="160543c34edb8318de8cbe4543bbca28" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="svn__subst_8h.html#160543c34edb8318de8cbe4543bbca28">svn_subst_eol_style</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Valid states for 'svn:eol-style' property. 
<p>
Property nonexistence is equivalent to 'none'. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="160543c34edb8318de8cbe4543bbca286e1bf631a8574e3cf1e52b6599785fdf"></a><!-- doxytag: member="svn_subst_eol_style_unknown" ref="160543c34edb8318de8cbe4543bbca286e1bf631a8574e3cf1e52b6599785fdf" args="" -->svn_subst_eol_style_unknown</em>&nbsp;</td><td>
An unrecognized style. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="160543c34edb8318de8cbe4543bbca28c33cc2b19c97a910b90d4efef275043f"></a><!-- doxytag: member="svn_subst_eol_style_none" ref="160543c34edb8318de8cbe4543bbca28c33cc2b19c97a910b90d4efef275043f" args="" -->svn_subst_eol_style_none</em>&nbsp;</td><td>
EOL translation is "off" or ignored value. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="160543c34edb8318de8cbe4543bbca282fdd9ef5ba015f6ecc6d59458df5c055"></a><!-- doxytag: member="svn_subst_eol_style_native" ref="160543c34edb8318de8cbe4543bbca282fdd9ef5ba015f6ecc6d59458df5c055" args="" -->svn_subst_eol_style_native</em>&nbsp;</td><td>
Translation is set to client's native eol. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="160543c34edb8318de8cbe4543bbca286e778790cbc23c4028f73aaaf5524069"></a><!-- doxytag: member="svn_subst_eol_style_fixed" ref="160543c34edb8318de8cbe4543bbca286e778790cbc23c4028f73aaaf5524069" args="" -->svn_subst_eol_style_fixed</em>&nbsp;</td><td>
Translation is set to one of LF, CR, CRLF. </td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="svn__subst_8h-source.html#l00041">41</a> of file <a class="el" href="svn__subst_8h-source.html">svn_subst.h</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="b004042c7b9a26349d68d625128041c8"></a><!-- doxytag: member="svn_subst.h::svn_subst_build_keywords" ref="b004042c7b9a26349d68d625128041c8" args="(svn_subst_keywords_t *kw, const char *keywords_string, const char *rev, const char *url, apr_time_t date, const char *author, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_build_keywords           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *&nbsp;</td>
          <td class="paramname"> <em>kw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>keywords_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_time_t&nbsp;</td>
          <td class="paramname"> <em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>author</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to <a class="el" href="svn__subst_8h.html#42f73d2001ac889b1d9883c5601e55f8" title="Set *kw to a new keywords hash filled with the appropriate contents given a keywords_string...">svn_subst_build_keywords2()</a> except that it populates an existing structure <em>*kw</em> instead of creating a keywords hash. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000201">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.2 API. </dd></dl>

</div>
</div><p>
<a class="anchor" name="42f73d2001ac889b1d9883c5601e55f8"></a><!-- doxytag: member="svn_subst.h::svn_subst_build_keywords2" ref="42f73d2001ac889b1d9883c5601e55f8" args="(apr_hash_t **kw, const char *keywords_string, const char *rev, const char *url, apr_time_t date, const char *author, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_build_keywords2           </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&nbsp;</td>
          <td class="paramname"> <em>kw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>keywords_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_time_t&nbsp;</td>
          <td class="paramname"> <em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>author</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*kw</em> to a new keywords hash filled with the appropriate contents given a <em>keywords_string</em> (the contents of the svn:keywords property for the file in question), the revision <em>rev</em>, the <em>url</em>, the <em>date</em> the file was committed on, and the <em>author</em> of the last commit. 
<p>
Any of these can be <code>NULL</code> to indicate that the information is not present, or <code>0</code> for <em>date</em>.<p>
Hash keys are of type <code>const char *</code>. Hash values are of type <code><a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a> *</code>.<p>
All memory is allocated out of <em>pool</em>.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a9dfe3fade520c1ca5b1edbe50989658"></a><!-- doxytag: member="svn_subst.h::svn_subst_copy_and_translate" ref="a9dfe3fade520c1ca5b1edbe50989658" args="(const char *src, const char *dst, const char *eol_str, svn_boolean_t repair, const svn_subst_keywords_t *keywords, svn_boolean_t expand, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_copy_and_translate           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>repair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *&nbsp;</td>
          <td class="paramname"> <em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>expand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to <a class="el" href="svn__subst_8h.html#9bbccf6a71c3e07a112e1e44f9ecec98" title="Similar to svn_subst_copy_and_translate3() except that keywords is a svn_subst_keywords_t...">svn_subst_copy_and_translate2()</a> except that <em>special</em> is always set to <code>FALSE</code>. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000206">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.0 API. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9bbccf6a71c3e07a112e1e44f9ecec98"></a><!-- doxytag: member="svn_subst.h::svn_subst_copy_and_translate2" ref="9bbccf6a71c3e07a112e1e44f9ecec98" args="(const char *src, const char *dst, const char *eol_str, svn_boolean_t repair, const svn_subst_keywords_t *keywords, svn_boolean_t expand, svn_boolean_t special, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_copy_and_translate2           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>repair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *&nbsp;</td>
          <td class="paramname"> <em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>expand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>special</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to <a class="el" href="svn__subst_8h.html#18dbb80be4ef26b2a978454716539d0c" title="Translates the file at path src into a file at path dst.">svn_subst_copy_and_translate3()</a> except that <em>keywords</em> is a <code><a class="el" href="structsvn__subst__keywords__t.html" title="Values used in keyword expansion.">svn_subst_keywords_t</a></code> struct instead of a keywords hash. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000205">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.2 API. </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="18dbb80be4ef26b2a978454716539d0c"></a><!-- doxytag: member="svn_subst.h::svn_subst_copy_and_translate3" ref="18dbb80be4ef26b2a978454716539d0c" args="(const char *src, const char *dst, const char *eol_str, svn_boolean_t repair, apr_hash_t *keywords, svn_boolean_t expand, svn_boolean_t special, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_copy_and_translate3           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>repair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&nbsp;</td>
          <td class="paramname"> <em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>expand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>special</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Translates the file at path <em>src</em> into a file at path <em>dst</em>. 
<p>
The parameters <em>*eol_str</em>, <em>repair</em>, <em>*keywords</em> and <em>expand</em> are defined the same as in <a class="el" href="svn__subst_8h.html#823ce051fe6718eb2af8473d9e46a90c" title="Copy and translate the data in stream src into stream dst.">svn_subst_translate_stream3()</a>.<p>
In addition, it will create a special file from normal form or translate one to normal form if <em>special</em> is <code>TRUE</code>.<p>
Copy the contents of file-path <em>src</em> to file-path <em>dst</em> atomically, either creating <em>dst</em> (or overwriting <em>dst</em> if it exists), possibly performing line ending and keyword translations.<p>
If anything goes wrong during the copy, attempt to delete <em>dst</em> (if it exists).<p>
If <em>eol_str</em> and <em>keywords</em> are <code>NULL</code>, behavior is just a byte-for-byte copy.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b0510e7ebae885c80b227ccc3a13685"></a><!-- doxytag: member="svn_subst.h::svn_subst_detranslate_string" ref="7b0510e7ebae885c80b227ccc3a13685" args="(svn_string_t **new_value, const svn_string_t *value, svn_boolean_t for_output, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_detranslate_string           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__string__t.html">svn_string_t</a> **&nbsp;</td>
          <td class="paramname"> <em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>for_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Translate the data in <em>value</em> from UTF8 and LF line-endings into native locale and native line-endings, or to the output locale if <em>for_output</em> is TRUE. 
<p>
Return the translated data in <em>*new_value</em>, allocated in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="dee8f25af905f8a450092b61ba79ea5c"></a><!-- doxytag: member="svn_subst.h::svn_subst_eol_style_from_value" ref="dee8f25af905f8a450092b61ba79ea5c" args="(svn_subst_eol_style_t *style, const char **eol, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_subst_eol_style_from_value           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__subst_8h.html#82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a> *&nbsp;</td>
          <td class="paramname"> <em>style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>eol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*style</em> to the appropriate <code>svn_subst_eol_style_t</code> and <em>*eol</em> to the appropriate cstring for a given svn:eol-style property value. 
<p>
Set <em>*eol</em> to<p>
<ul>
<li><code>NULL</code> for <code>svn_subst_eol_style_none</code>, or</li></ul>
<p>
<ul>
<li>a NULL-terminated C string containing the native eol marker for this platform, for <code>svn_subst_eol_style_native</code>, or</li></ul>
<p>
<ul>
<li>a NULL-terminated C string containing the eol marker indicated by the property value, for <code>svn_subst_eol_style_fixed</code>.</li></ul>
<p>
If <em>*style</em> is NULL, it is ignored. 
</div>
</div><p>
<a class="anchor" name="598cb9236b80298a904c4b8d7b5ab113"></a><!-- doxytag: member="svn_subst.h::svn_subst_keywords_differ" ref="598cb9236b80298a904c4b8d7b5ab113" args="(const svn_subst_keywords_t *a, const svn_subst_keywords_t *b, svn_boolean_t compare_values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_subst_keywords_differ           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>compare_values</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to <a class="el" href="svn__subst_8h.html#c1bd03f2381659cd0358dd74e7f882e5" title="Return TRUE if a and b do not hold the same keywords.">svn_subst_keywords_differ2()</a> except that it compares two <code><a class="el" href="structsvn__subst__keywords__t.html" title="Values used in keyword expansion.">svn_subst_keywords_t</a></code> structs instead of keyword hashes. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000202">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.2 API. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c1bd03f2381659cd0358dd74e7f882e5"></a><!-- doxytag: member="svn_subst.h::svn_subst_keywords_differ2" ref="c1bd03f2381659cd0358dd74e7f882e5" args="(apr_hash_t *a, apr_hash_t *b, svn_boolean_t compare_values, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_subst_keywords_differ2           </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>compare_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return <code>TRUE</code> if <em>a</em> and <em>b</em> do not hold the same keywords. 
<p>
<em>a</em> and <em>b</em> are hashes of the form produced by <a class="el" href="svn__subst_8h.html#42f73d2001ac889b1d9883c5601e55f8" title="Set *kw to a new keywords hash filled with the appropriate contents given a keywords_string...">svn_subst_build_keywords2()</a>.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.3.</dd></dl>
If <em>compare_values</em> is <code>TRUE</code>, "same" means that the <em>a</em> and <em>b</em> contain exactly the same set of keywords, and the values of corresponding keywords match as well. Else if <em>compare_values</em> is <code>FALSE</code>, then "same" merely means that <em>a</em> and <em>b</em> hold the same set of keywords, although those keywords' values might differ.<p>
<em>a</em> and/or <em>b</em> may be <code>NULL</code>; for purposes of comparison, <code>NULL</code> is equivalent to holding no keywords. 
</div>
</div><p>
<a class="anchor" name="9174c224c4fc71aaba0d2b9e93482df6"></a><!-- doxytag: member="svn_subst.h::svn_subst_stream_detranslated" ref="9174c224c4fc71aaba0d2b9e93482df6" args="(svn_stream_t **stream_p, const char *src, svn_subst_eol_style_t eol_style, const char *eol_str, svn_boolean_t always_repair_eols, apr_hash_t *keywords, svn_boolean_t special, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_stream_detranslated           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&nbsp;</td>
          <td class="paramname"> <em>stream_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__subst_8h.html#82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a>&nbsp;</td>
          <td class="paramname"> <em>eol_style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>always_repair_eols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&nbsp;</td>
          <td class="paramname"> <em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>special</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*stream_p</em> to a stream that detranslates the file <em>src</em> from working copy form to normal form, allocated in <em>pool</em>. 
<p>
The values specified for <em>eol_style</em>, <em>*eol_str</em>, <em>keywords</em> and <em>special</em>, should be the ones used to translate the file to its working copy form. Usually, these are the values specified by the user in the files' properties.<p>
Inconsistent line endings in the file will be automatically repaired (made consistent) for some eol styles. For all others, an error is returned. By setting <em>always_repair_eols</em> to <code>TRUE</code>, eols will be made consistent even for those styles which don't have it by default.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.4. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e4e5f664140910fecfce37994ba949dc"></a><!-- doxytag: member="svn_subst.h::svn_subst_stream_from_specialfile" ref="e4e5f664140910fecfce37994ba949dc" args="(svn_stream_t **stream, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_stream_from_specialfile           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a stream which translates the special file at <em>path</em> to the internal representation for special files when read from. 
<p>
When written to, it does the reverse: creating a special file when the stream is closed.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dd5d644ecc07e3d679c6e69c3ea0f1da"></a><!-- doxytag: member="svn_subst.h::svn_subst_stream_translated" ref="dd5d644ecc07e3d679c6e69c3ea0f1da" args="(svn_stream_t *stream, const char *eol_str, svn_boolean_t repair, apr_hash_t *keywords, svn_boolean_t expand, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_subst_stream_translated           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>repair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&nbsp;</td>
          <td class="paramname"> <em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>expand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a stream which performs eol translation and keyword expansion when read from or written to. 
<p>
The stream <em>stream</em> is used to read and write all data. Make sure you call <a class="el" href="group__svn__io__byte__streams.html#g7d9cdab4d5d8707d59a1b1d3dab95bb4" title="Close a generic stream.">svn_stream_close()</a> on <em>stream</em> to make sure all data are flushed and cleaned up.<p>
Read operations from and write operations to the stream perform the same operation: if <em>expand</em> is <code>FALSE</code>, both contract keywords. One stream supports both read and write operations. Reads and writes may be mixed.<p>
The stream returned is allocated in <em>pool</em>.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.4. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4f47ae70ef1b063543924891f3fb71d6"></a><!-- doxytag: member="svn_subst.h::svn_subst_stream_translated_to_normal_form" ref="4f47ae70ef1b063543924891f3fb71d6" args="(svn_stream_t **stream, svn_stream_t *source, svn_subst_eol_style_t eol_style, const char *eol_str, svn_boolean_t always_repair_eols, apr_hash_t *keywords, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_stream_translated_to_normal_form           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__subst_8h.html#82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a>&nbsp;</td>
          <td class="paramname"> <em>eol_style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>always_repair_eols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&nbsp;</td>
          <td class="paramname"> <em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a stream which performs eol translation and keyword expansion when read from or written to. 
<p>
The stream <em>stream</em> is used to read and write all data. Make sure you call <a class="el" href="group__svn__io__byte__streams.html#g7d9cdab4d5d8707d59a1b1d3dab95bb4" title="Close a generic stream.">svn_stream_close()</a> on <em>stream</em> to make sure all data are flushed and cleaned up.<p>
Read and write operations perform the same transformation: all data is translated to normal form.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="svn__subst_8h.html#ce41f93ffd67e19f15cc705a855e8a98" title="Translates a file src in working copy form to a file dst in normal form.">svn_subst_translate_to_normal_form()</a></dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ab1b28fcddc78254ca6b6ed4ad149b89"></a><!-- doxytag: member="svn_subst.h::svn_subst_translate_cstring" ref="ab1b28fcddc78254ca6b6ed4ad149b89" args="(const char *src, const char **dst, const char *eol_str, svn_boolean_t repair, const svn_subst_keywords_t *keywords, svn_boolean_t expand, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_translate_cstring           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>repair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *&nbsp;</td>
          <td class="paramname"> <em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>expand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to <a class="el" href="svn__subst_8h.html#9030b641b1ef299e68c35670014ea747" title="Convenience routine: a variant of svn_subst_translate_stream3() which operates on...">svn_subst_translate_cstring2()</a> except that <em>keywords</em> is a <code><a class="el" href="structsvn__subst__keywords__t.html" title="Values used in keyword expansion.">svn_subst_keywords_t</a></code> struct instead of a keywords hash. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000207">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.2 API. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9030b641b1ef299e68c35670014ea747"></a><!-- doxytag: member="svn_subst.h::svn_subst_translate_cstring2" ref="9030b641b1ef299e68c35670014ea747" args="(const char *src, const char **dst, const char *eol_str, svn_boolean_t repair, apr_hash_t *keywords, svn_boolean_t expand, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_translate_cstring2           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>repair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&nbsp;</td>
          <td class="paramname"> <em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>expand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience routine: a variant of <a class="el" href="svn__subst_8h.html#823ce051fe6718eb2af8473d9e46a90c" title="Copy and translate the data in stream src into stream dst.">svn_subst_translate_stream3()</a> which operates on cstrings. 
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.3.</dd></dl>
Return a new string in <em>*dst</em>, allocated in <em>pool</em>, by copying the contents of string <em>src</em>, possibly performing line ending and keyword translations.<p>
If <em>eol_str</em> and <em>keywords</em> are <code>NULL</code>, behavior is just a byte-for-byte copy. 
</div>
</div><p>
<a class="anchor" name="8ecd3f591a316f3750a42fc5206790f9"></a><!-- doxytag: member="svn_subst.h::svn_subst_translate_stream" ref="8ecd3f591a316f3750a42fc5206790f9" args="(svn_stream_t *src, svn_stream_t *dst, const char *eol_str, svn_boolean_t repair, const svn_subst_keywords_t *keywords, svn_boolean_t expand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_translate_stream           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>repair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *&nbsp;</td>
          <td class="paramname"> <em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>expand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="svn__subst_8h.html#06f015a633236b8f33d7c5543c587053" title="Similar to svn_subst_translate_stream3() except relies upon a svn_subst_keywords_t...">svn_subst_translate_stream2()</a>, but does not take a <em>pool</em> argument, instead creates a temporary subpool of the global pool, and destroys it before returning. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000204">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.1 API. </dd></dl>

</div>
</div><p>
<a class="anchor" name="06f015a633236b8f33d7c5543c587053"></a><!-- doxytag: member="svn_subst.h::svn_subst_translate_stream2" ref="06f015a633236b8f33d7c5543c587053" args="(svn_stream_t *src, svn_stream_t *dst, const char *eol_str, svn_boolean_t repair, const svn_subst_keywords_t *keywords, svn_boolean_t expand, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_translate_stream2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>repair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__subst__keywords__t.html">svn_subst_keywords_t</a> *&nbsp;</td>
          <td class="paramname"> <em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>expand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to <a class="el" href="svn__subst_8h.html#823ce051fe6718eb2af8473d9e46a90c" title="Copy and translate the data in stream src into stream dst.">svn_subst_translate_stream3()</a> except relies upon a <code><a class="el" href="structsvn__subst__keywords__t.html" title="Values used in keyword expansion.">svn_subst_keywords_t</a></code> struct instead of a hash for the keywords. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000203">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.2 API. </dd></dl>

</div>
</div><p>
<a class="anchor" name="823ce051fe6718eb2af8473d9e46a90c"></a><!-- doxytag: member="svn_subst.h::svn_subst_translate_stream3" ref="823ce051fe6718eb2af8473d9e46a90c" args="(svn_stream_t *src, svn_stream_t *dst, const char *eol_str, svn_boolean_t repair, apr_hash_t *keywords, svn_boolean_t expand, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_translate_stream3           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>repair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&nbsp;</td>
          <td class="paramname"> <em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>expand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy and translate the data in stream <em>src</em> into stream <em>dst</em>. 
<p>
It is assumed that <em>src</em> is a readable stream and <em>dst</em> is a writable stream.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.3.</dd></dl>
If <em>eol_str</em> is non-<code>NULL</code>, replace whatever bytestring <em>src</em> uses to denote line endings with <em>eol_str</em> in the output. If <em>src</em> has an inconsistent line ending style, then: if <em>repair</em> is <code>FALSE</code>, return <code>SVN_ERR_IO_INCONSISTENT_EOL</code>, else if <em>repair</em> is <code>TRUE</code>, convert any line ending in <em>src</em> to <em>eol_str</em> in <em>dst</em>. Recognized line endings are: "\n", "\r", and "\r\n".<p>
Expand and contract keywords using the contents of <em>keywords</em> as the new values. If <em>expand</em> is <code>TRUE</code>, expand contracted keywords and re-expand expanded keywords. If <em>expand</em> is <code>FALSE</code>, contract expanded keywords and ignore contracted ones. Keywords not found in the hash are ignored (not contracted or expanded). If the <em>keywords</em> hash itself is <code>NULL</code>, keyword substitution will be altogether ignored.<p>
Detect only keywords that are no longer than <code>SVN_IO_MAX_KEYWORD_LEN</code> bytes, including the delimiters and the keyword itself.<p>
Note that a translation request is *required*: one of <em>eol_str</em> or <em>keywords</em> must be non-<code>NULL</code>.<p>
Recommendation: if <em>expand</em> is FALSE, then you don't care about the keyword values, so use empty strings as non-NULL signifiers when you build the keywords hash.<p>
Notes:<p>
See svn_wc__get_keywords() and svn_wc__get_eol_style() for a convenient way to get <em>eol_str</em> and <em>keywords</em> if in libsvn_wc. 
</div>
</div><p>
<a class="anchor" name="626c5dcfbbf5057ebc0e384187f6d330"></a><!-- doxytag: member="svn_subst.h::svn_subst_translate_string" ref="626c5dcfbbf5057ebc0e384187f6d330" args="(svn_string_t **new_value, const svn_string_t *value, const char *encoding, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_translate_string           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__string__t.html">svn_string_t</a> **&nbsp;</td>
          <td class="paramname"> <em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Translate the data in <em>value</em> (assumed to be in encoded in charset <em>encoding</em>) to UTF8 and LF line-endings. 
<p>
If <em>encoding</em> is <code>NULL</code>, then assume that <em>value</em> is in the system-default language encoding. Return the translated data in <em>*new_value</em>, allocated in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="ce41f93ffd67e19f15cc705a855e8a98"></a><!-- doxytag: member="svn_subst.h::svn_subst_translate_to_normal_form" ref="ce41f93ffd67e19f15cc705a855e8a98" args="(const char *src, const char *dst, svn_subst_eol_style_t eol_style, const char *eol_str, svn_boolean_t always_repair_eols, apr_hash_t *keywords, svn_boolean_t special, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_subst_translate_to_normal_form           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__subst_8h.html#82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a>&nbsp;</td>
          <td class="paramname"> <em>eol_style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>eol_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>always_repair_eols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&nbsp;</td>
          <td class="paramname"> <em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>special</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Translates a file <em>src</em> in working copy form to a file <em>dst</em> in normal form. 
<p>
The values specified for <em>eol_style</em>, <em>*eol_str</em>, <em>keywords</em> and <em>special</em>, should be the ones used to translate the file to its working copy form. Usually, these are the values specified by the user in the files' properties.<p>
Inconsistent line endings in the file will be automatically repaired (made consistent) for some eol styles. For all others, an error is returned. By setting <em>always_repair_eols</em> to <code>TRUE</code>, eols will be made consistent even for those styles which don't have it by default.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>To translate a file FROM normal form, use <a class="el" href="svn__subst_8h.html#18dbb80be4ef26b2a978454716539d0c" title="Translates the file at path src into a file at path dst.">svn_subst_copy_and_translate3()</a>.</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.4 </dd></dl>

</div>
</div><p>
<a class="anchor" name="8655a649e193b8eb96ba8ea59433a6b3"></a><!-- doxytag: member="svn_subst.h::svn_subst_translation_required" ref="8655a649e193b8eb96ba8ea59433a6b3" args="(svn_subst_eol_style_t style, const char *eol, apr_hash_t *keywords, svn_boolean_t special, svn_boolean_t force_eol_check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_subst_translation_required           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__subst_8h.html#82d6196808784a7a73e098f8d8534edb">svn_subst_eol_style_t</a>&nbsp;</td>
          <td class="paramname"> <em>style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>eol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&nbsp;</td>
          <td class="paramname"> <em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>special</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>force_eol_check</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates whether the working copy and normalized versions of a file with the given the parameters differ. 
<p>
If <em>force_eol_check</em> is TRUE, the routine also accounts for all translations required due to repairing fixed eol styles.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.4 </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 24 16:18:28 2008 for Subversion by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
