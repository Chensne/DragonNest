<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Subversion: svn_delta_editor_t Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>svn_delta_editor_t Struct Reference<br>
<small>
[<a class="el" href="group__svn__delta__tree__deltas.html">Tree deltas</a>]</small>
</h1><!-- doxytag: class="svn_delta_editor_t" -->A structure full of callback functions the delta source will invoke as it produces the delta.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="svn__delta_8h-source.html">svn_delta.h</a>&gt;</code>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#fe2563b815ba75de5e41e3d35487e3cc">set_target_revision</a> )(void *edit_baton, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> target_revision, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the target revision for this edit to <em>target_revision</em>.  <a href="#fe2563b815ba75de5e41e3d35487e3cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#bab4c53be0a96b0c8454efdeb6d2d1ee">open_root</a> )(void *edit_baton, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> base_revision, apr_pool_t *dir_pool, void **root_baton)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*root_baton</em> to a baton for the top directory of the change.  <a href="#bab4c53be0a96b0c8454efdeb6d2d1ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#9e7f99b110f93dd083d81806646b2be5">delete_entry</a> )(const char *path, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> revision, void *parent_baton, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the directory entry named <em>path</em>, a child of the directory represented by <em>parent_baton</em>.  <a href="#9e7f99b110f93dd083d81806646b2be5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#683e42b5d0d8f4850b553798b48b6e9c">add_directory</a> )(const char *path, void *parent_baton, const char *copyfrom_path, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> copyfrom_revision, apr_pool_t *dir_pool, void **child_baton)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">We are going to add a new subdirectory named <em>path</em>.  <a href="#683e42b5d0d8f4850b553798b48b6e9c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#1c529778b425203341fae6ed7f020aa8">open_directory</a> )(const char *path, void *parent_baton, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> base_revision, apr_pool_t *dir_pool, void **child_baton)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">We are going to make changes in a subdirectory (of the directory identified by <em>parent_baton</em>).  <a href="#1c529778b425203341fae6ed7f020aa8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#3fff527b2b013d87b3f58c09ffb4699e">change_dir_prop</a> )(void *dir_baton, const char *name, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the value of a directory's property.  <a href="#3fff527b2b013d87b3f58c09ffb4699e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#9cbb6499ca58b71faeab7f8dc80f3b5f">close_directory</a> )(void *dir_baton, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">We are done processing a subdirectory, whose baton is <em>dir_baton</em> (set by <code>add_directory</code> or <code>open_directory</code>).  <a href="#9cbb6499ca58b71faeab7f8dc80f3b5f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ee9db69324884f6e048b595c4e6ff49d"></a><!-- doxytag: member="svn_delta_editor_t::absent_directory" ref="ee9db69324884f6e048b595c4e6ff49d" args=")(const char *path, void *parent_baton, apr_pool_t *pool)" -->
<a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#ee9db69324884f6e048b595c4e6ff49d">absent_directory</a> )(const char *path, void *parent_baton, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">In the directory represented by <em>parent_baton</em>, indicate that <em>path</em> is present as a subdirectory in the edit source, but cannot be conveyed to the edit consumer (perhaps because of authorization restrictions). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#b68e886d7a579b87054c53a0e4ed73d4">add_file</a> )(const char *path, void *parent_baton, const char *copyfrom_path, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> copyfrom_revision, apr_pool_t *file_pool, void **file_baton)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">We are going to add a new file named <em>path</em>.  <a href="#b68e886d7a579b87054c53a0e4ed73d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#603dc13812b2455dcfc5f750af17592f">open_file</a> )(const char *path, void *parent_baton, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> base_revision, apr_pool_t *file_pool, void **file_baton)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">We are going to make change to a file named <em>path</em>, which resides in the directory identified by <em>parent_baton</em>.  <a href="#603dc13812b2455dcfc5f750af17592f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#4b1779d19327e0b91285f378e86ede4f">apply_textdelta</a> )(void *file_baton, const char *base_checksum, apr_pool_t *pool, <a class="el" href="group__svn__delta__txt__delta.html#g1c0d461a3f244928d7f0339c1cbe3219">svn_txdelta_window_handler_t</a> *handler, void **handler_baton)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply a text delta, yielding the new revision of a file.  <a href="#4b1779d19327e0b91285f378e86ede4f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#1420252f4b00161b9f7c2461e11e0b40">change_file_prop</a> )(void *file_baton, const char *name, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the value of a file's property.  <a href="#1420252f4b00161b9f7c2461e11e0b40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#3851c7e0ac1de721f6f545d2e9a7b473">close_file</a> )(void *file_baton, const char *text_checksum, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">We are done processing a file, whose baton is <em>file_baton</em> (set by <code>add_file</code> or <code>open_file</code>).  <a href="#3851c7e0ac1de721f6f545d2e9a7b473"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aba69bd23d383896255f31d17eda61eb"></a><!-- doxytag: member="svn_delta_editor_t::absent_file" ref="aba69bd23d383896255f31d17eda61eb" args=")(const char *path, void *parent_baton, apr_pool_t *pool)" -->
<a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#aba69bd23d383896255f31d17eda61eb">absent_file</a> )(const char *path, void *parent_baton, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">In the directory represented by <em>parent_baton</em>, indicate that <em>path</em> is present as a file in the edit source, but cannot be conveyed to the edit consumer (perhaps because of authorization restrictions). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#b00ee4fc603197bb3f71156b1bbbd577">close_edit</a> )(void *edit_baton, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All delta processing is done.  <a href="#b00ee4fc603197bb3f71156b1bbbd577"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#12a8990d6e8fbfa3de2f1fa0c68964b8">abort_edit</a> )(void *edit_baton, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The editor-driver has decided to bail out.  <a href="#12a8990d6e8fbfa3de2f1fa0c68964b8"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A structure full of callback functions the delta source will invoke as it produces the delta. 
<p>
<h3>Function Usage</h3>
<p>
Here's how to use these functions to express a tree delta.<p>
The delta consumer implements the callback functions described in this structure, and the delta producer invokes them. So the caller (producer) is pushing tree delta data at the callee (consumer).<p>
At the start of traversal, the consumer provides <em>edit_baton</em>, a baton global to the entire delta edit. If there is a target revision that needs to be set for this operation, the producer should call the <code>set_target_revision</code> function at this point.<p>
Next, if there are any tree deltas to express, the producer should pass the <em>edit_baton</em> to the <code>open_root</code> function, to get a baton representing root of the tree being edited.<p>
Most of the callbacks work in the obvious way:<p>
<code>delete_entry</code> <code>add_file</code> <code>add_directory</code> <code>open_file</code> <code>open_directory</code> <p>
Each of these takes a directory baton, indicating the directory in which the change takes place, and a <em>path</em> argument, giving the path (relative to the root of the edit) of the file, subdirectory, or directory entry to change. Editors will usually want to join this relative path with some base stored in the edit baton (e.g. a URL, a location in the OS filesystem).<p>
Since every call requires a parent directory baton, including <code>add_directory</code> and <code>open_directory</code>, where do we ever get our initial directory baton, to get things started? The <code>open_root</code> function returns a baton for the top directory of the change. In general, the producer needs to invoke the editor's <code>open_root</code> function before it can get anything of interest done.<p>
While <code>open_root</code> provides a directory baton for the root of the tree being changed, the <code>add_directory</code> and <code>open_directory</code> callbacks provide batons for other directories. Like the callbacks above, they take a <em>parent_baton</em> and a relative path <em>path</em>, and then return a new baton for the subdirectory being created / modified --- <em>child_baton</em>. The producer can then use <em>child_baton</em> to make further changes in that subdirectory.<p>
So, if we already have subdirectories named `foo' and `foo/bar', then the producer can create a new file named `foo/bar/baz.c' by calling:<p>
<ul>
<li><code>open_root</code> () --- yielding a baton <em>root</em> for the top directory</li></ul>
<p>
<ul>
<li><code>open_directory</code> (<em>root</em>, "foo") --- yielding a baton <em>f</em> for `foo'</li></ul>
<p>
<ul>
<li><code>open_directory</code> (<em>f</em>, "foo/bar") --- yielding a baton <em>b</em> for `foo/bar'</li></ul>
<p>
<ul>
<li><code>add_file</code> (<em>b</em>, "foo/bar/baz.c")</li></ul>
<p>
When the producer is finished making changes to a directory, it should call <code>close_directory</code>. This lets the consumer do any necessary cleanup, and free the baton's storage.<p>
The <code>add_file</code> and <code>open_file</code> callbacks each return a baton for the file being created or changed. This baton can then be passed to <code>apply_textdelta</code> to change the file's contents, or <code>change_file_prop</code> to change the file's properties. When the producer is finished making changes to a file, it should call <code>close_file</code>, to let the consumer clean up and free the baton.<p>
The <code>add_file</code> and <code>add_directory</code> functions each take arguments <em>copyfrom_path</em> and <em>copyfrom_revision</em>. If <em>copyfrom_path</em> is non-<code>NULL</code>, then <em>copyfrom_path</em> and <em>copyfrom_revision</em> indicate where the file or directory should be copied from (to create the file or directory being added). In that case, <em>copyfrom_path</em> must be either a path relative to the root of the edit, or a URI from the repository being edited. If <em>copyfrom_path</em> is <code>NULL</code>, then <em>copyfrom_revision</em> must be <code>SVN_INVALID_REVNUM</code>; it is invalid to pass a mix of valid and invalid copyfrom arguments.<p>
<h3>Function Call Ordering</h3>
<p>
There are six restrictions on the order in which the producer may use the batons:<p>
1. The producer may call <code>open_directory</code>, <code>add_directory</code>, <code>open_file</code>, <code>add_file</code> at most once on any given directory entry. <code>delete_entry</code> may be called at most once on any given directory entry and may later be followed by <code>add_directory</code> or <code>add_file</code> on the same directory entry. <code>delete_entry</code> may not be called on any directory entry after <code>open_directory</code>, <code>add_directory</code>, <code>open_file</code> or <code>add_file</code> has been called on that directory entry.<p>
2. The producer may not close a directory baton until it has closed all batons for its subdirectories.<p>
3. When a producer calls <code>open_directory</code> or <code>add_directory</code>, it must specify the most recently opened of the currently open directory batons. Put another way, the producer cannot have two sibling directory batons open at the same time.<p>
4. A producer must call <code>change_dir_prop</code> on a directory either before opening any of the directory's subdirs or after closing them, but not in the middle.<p>
5. When the producer calls <code>open_file</code> or <code>add_file</code>, either:<p>
(a) The producer must follow with any changes to the file (<code>change_file_prop</code> and/or <code>apply_textdelta</code>, as applicable), followed by a <code>close_file</code> call, before issuing any other file or directory calls, or<p>
(b) The producer must follow with a <code>change_file_prop</code> call if it is applicable, before issuing any other file or directory calls; later, after all directory batons including the root have been closed, the producer must issue <code>apply_textdelta</code> and <code>close_file</code> calls.<p>
6. When the producer calls <code>apply_textdelta</code>, it must make all of the window handler calls (including the <code>NULL</code> window at the end) before issuing any other <code><a class="el" href="structsvn__delta__editor__t.html" title="A structure full of callback functions the delta source will invoke as it produces...">svn_delta_editor_t</a></code> calls.<p>
So, the producer needs to use directory and file batons as if it is doing a single depth-first traversal of the tree, with the exception that the producer may keep file batons open in order to make <code>apply_textdelta</code> calls at the end.<p>
<h3>Pool Usage</h3>
<p>
Many editor functions are invoked multiple times, in a sequence determined by the editor "driver". The driver is responsible for creating a pool for use on each iteration of the editor function, and clearing that pool between each iteration. The driver passes the appropriate pool on each function invocation.<p>
Based on the requirement of calling the editor functions in a depth-first style, it is usually customary for the driver to similarly nest the pools. However, this is only a safety feature to ensure that pools associated with deeper items are always cleared when the top-level items are also cleared. The interface does not assume, nor require, any particular organization of the pools passed to these functions. In fact, if "postfix deltas" are used for files, the file pools definitely need to live outside the scope of their parent directories' pools.<p>
Note that close_directory can be called *before* a file in that directory has been closed. That is, the directory's baton is closed before the file's baton. The implication is that <code>apply_textdelta</code> and <code>close_file</code> should not refer to a parent directory baton UNLESS the editor has taken precautions to allocate it in a pool of the appropriate lifetime (the <em>dir_pool</em> passed to <code>open_directory</code> and <code>add_directory</code> definitely does not have the proper lifetime). In general, it is recommended to simply avoid keeping a parent directory baton in a file baton.<p>
<h3>Errors</h3>
<p>
At least one implementation of the editor interface is asynchronous; an error from one operation may be detected some number of operations later. As a result, an editor driver must not assume that an error from an editing function resulted from the particular operation being detected. Moreover, once an editing function returns an error, the edit is dead; the only further operation which may be called on the editor is abort_edit. 
<p>Definition at line <a class="el" href="svn__delta_8h-source.html#l00698">698</a> of file <a class="el" href="svn__delta_8h-source.html">svn_delta.h</a>.</p>
<hr><h2>Field Documentation</h2>
<a class="anchor" name="fe2563b815ba75de5e41e3d35487e3cc"></a><!-- doxytag: member="svn_delta_editor_t::set_target_revision" ref="fe2563b815ba75de5e41e3d35487e3cc" args=")(void *edit_baton, svn_revnum_t target_revision, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="structsvn__delta__editor__t.html#fe2563b815ba75de5e41e3d35487e3cc">svn_delta_editor_t::set_target_revision</a>)(void *edit_baton, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> target_revision, apr_pool_t *pool)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the target revision for this edit to <em>target_revision</em>. 
<p>
This call, if used, should precede all other editor calls. 
</div>
</div><p>
<a class="anchor" name="bab4c53be0a96b0c8454efdeb6d2d1ee"></a><!-- doxytag: member="svn_delta_editor_t::open_root" ref="bab4c53be0a96b0c8454efdeb6d2d1ee" args=")(void *edit_baton, svn_revnum_t base_revision, apr_pool_t *dir_pool, void **root_baton)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="structsvn__delta__editor__t.html#bab4c53be0a96b0c8454efdeb6d2d1ee">svn_delta_editor_t::open_root</a>)(void *edit_baton, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> base_revision, apr_pool_t *dir_pool, void **root_baton)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*root_baton</em> to a baton for the top directory of the change. 
<p>
(This is the top of the subtree being changed, not necessarily the root of the filesystem.) As with any other directory baton, the producer should call <code>close_directory</code> on <em>root_baton</em> when done. And as with other <code>open_*</code> calls, the <em>base_revision</em> here is the current revision of the directory (before getting bumped up to the new target revision set with <code>set_target_revision</code>).<p>
Allocations for the returned <em>root_baton</em> should be performed in <em>dir_pool</em>. It is also typical to (possibly) save this pool for later usage by <code>close_directory</code>. 
</div>
</div><p>
<a class="anchor" name="9e7f99b110f93dd083d81806646b2be5"></a><!-- doxytag: member="svn_delta_editor_t::delete_entry" ref="9e7f99b110f93dd083d81806646b2be5" args=")(const char *path, svn_revnum_t revision, void *parent_baton, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="structsvn__delta__editor__t.html#9e7f99b110f93dd083d81806646b2be5">svn_delta_editor_t::delete_entry</a>)(const char *path, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> revision, void *parent_baton, apr_pool_t *pool)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove the directory entry named <em>path</em>, a child of the directory represented by <em>parent_baton</em>. 
<p>
If <em>revision</em> is a valid revision number, it is used as a sanity check to ensure that you are really removing the revision of <em>path</em> that you think you are.<p>
All allocations should be performed in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="683e42b5d0d8f4850b553798b48b6e9c"></a><!-- doxytag: member="svn_delta_editor_t::add_directory" ref="683e42b5d0d8f4850b553798b48b6e9c" args=")(const char *path, void *parent_baton, const char *copyfrom_path, svn_revnum_t copyfrom_revision, apr_pool_t *dir_pool, void **child_baton)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="structsvn__delta__editor__t.html#683e42b5d0d8f4850b553798b48b6e9c">svn_delta_editor_t::add_directory</a>)(const char *path, void *parent_baton, const char *copyfrom_path, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> copyfrom_revision, apr_pool_t *dir_pool, void **child_baton)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
We are going to add a new subdirectory named <em>path</em>. 
<p>
We will use the value this callback stores in <em>*child_baton</em> as the <em>parent_baton</em> for further changes in the new subdirectory.<p>
If <em>copyfrom_path</em> is non-<code>NULL</code>, this add has history (i.e., is a copy), and the origin of the copy may be recorded as <em>copyfrom_path</em> under <em>copyfrom_revision</em>.<p>
Allocations for the returned <em>child_baton</em> should be performed in <em>dir_pool</em>. It is also typical to (possibly) save this pool for later usage by <code>close_directory</code>. 
</div>
</div><p>
<a class="anchor" name="1c529778b425203341fae6ed7f020aa8"></a><!-- doxytag: member="svn_delta_editor_t::open_directory" ref="1c529778b425203341fae6ed7f020aa8" args=")(const char *path, void *parent_baton, svn_revnum_t base_revision, apr_pool_t *dir_pool, void **child_baton)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="structsvn__delta__editor__t.html#1c529778b425203341fae6ed7f020aa8">svn_delta_editor_t::open_directory</a>)(const char *path, void *parent_baton, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> base_revision, apr_pool_t *dir_pool, void **child_baton)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
We are going to make changes in a subdirectory (of the directory identified by <em>parent_baton</em>). 
<p>
The subdirectory is specified by <em>path</em>. The callback must store a value in <em>*child_baton</em> that should be used as the <em>parent_baton</em> for subsequent changes in this subdirectory. If a valid revnum, <em>base_revision</em> is the current revision of the subdirectory.<p>
Allocations for the returned <em>child_baton</em> should be performed in <em>dir_pool</em>. It is also typical to (possibly) save this pool for later usage by <code>close_directory</code>. 
</div>
</div><p>
<a class="anchor" name="3fff527b2b013d87b3f58c09ffb4699e"></a><!-- doxytag: member="svn_delta_editor_t::change_dir_prop" ref="3fff527b2b013d87b3f58c09ffb4699e" args=")(void *dir_baton, const char *name, const svn_string_t *value, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="structsvn__delta__editor__t.html#3fff527b2b013d87b3f58c09ffb4699e">svn_delta_editor_t::change_dir_prop</a>)(void *dir_baton, const char *name, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, apr_pool_t *pool)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change the value of a directory's property. 
<p>
<ul>
<li><em>dir_baton</em> specifies the directory whose property should change.</li><li><em>name</em> is the name of the property to change.</li><li><em>value</em> is the new (final) value of the property, or <code>NULL</code> if the property should be removed altogether.</li></ul>
<p>
The callback is guaranteed to be called exactly once for each property whose value differs between the start and the end of the edit.<p>
All allocations should be performed in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="9cbb6499ca58b71faeab7f8dc80f3b5f"></a><!-- doxytag: member="svn_delta_editor_t::close_directory" ref="9cbb6499ca58b71faeab7f8dc80f3b5f" args=")(void *dir_baton, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="structsvn__delta__editor__t.html#9cbb6499ca58b71faeab7f8dc80f3b5f">svn_delta_editor_t::close_directory</a>)(void *dir_baton, apr_pool_t *pool)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
We are done processing a subdirectory, whose baton is <em>dir_baton</em> (set by <code>add_directory</code> or <code>open_directory</code>). 
<p>
We won't be using the baton any more, so whatever resources it refers to may now be freed. 
</div>
</div><p>
<a class="anchor" name="b68e886d7a579b87054c53a0e4ed73d4"></a><!-- doxytag: member="svn_delta_editor_t::add_file" ref="b68e886d7a579b87054c53a0e4ed73d4" args=")(const char *path, void *parent_baton, const char *copyfrom_path, svn_revnum_t copyfrom_revision, apr_pool_t *file_pool, void **file_baton)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="structsvn__delta__editor__t.html#b68e886d7a579b87054c53a0e4ed73d4">svn_delta_editor_t::add_file</a>)(const char *path, void *parent_baton, const char *copyfrom_path, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> copyfrom_revision, apr_pool_t *file_pool, void **file_baton)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
We are going to add a new file named <em>path</em>. 
<p>
The callback can store a baton for this new file in <em>**file_baton</em>; whatever value it stores there should be passed through to <code>apply_textdelta</code>.<p>
If <em>copyfrom_path</em> is non-<code>NULL</code>, this add has history (i.e., is a copy), and the origin of the copy may be recorded as <em>copyfrom_path</em> under <em>copyfrom_revision</em>.<p>
Allocations for the returned <em>file_baton</em> should be performed in <em>file_pool</em>. It is also typical to save this pool for later usage by <code>apply_textdelta</code> and possibly <code>close_file</code>. 
</div>
</div><p>
<a class="anchor" name="603dc13812b2455dcfc5f750af17592f"></a><!-- doxytag: member="svn_delta_editor_t::open_file" ref="603dc13812b2455dcfc5f750af17592f" args=")(const char *path, void *parent_baton, svn_revnum_t base_revision, apr_pool_t *file_pool, void **file_baton)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="structsvn__delta__editor__t.html#603dc13812b2455dcfc5f750af17592f">svn_delta_editor_t::open_file</a>)(const char *path, void *parent_baton, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> base_revision, apr_pool_t *file_pool, void **file_baton)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
We are going to make change to a file named <em>path</em>, which resides in the directory identified by <em>parent_baton</em>. 
<p>
The callback can store a baton for this new file in <em>**file_baton</em>; whatever value it stores there should be passed through to <code>apply_textdelta</code>. If a valid revnum, <em>base_revision</em> is the current revision of the file.<p>
Allocations for the returned <em>file_baton</em> should be performed in <em>file_pool</em>. It is also typical to save this pool for later usage by <code>apply_textdelta</code> and possibly <code>close_file</code>. 
</div>
</div><p>
<a class="anchor" name="4b1779d19327e0b91285f378e86ede4f"></a><!-- doxytag: member="svn_delta_editor_t::apply_textdelta" ref="4b1779d19327e0b91285f378e86ede4f" args=")(void *file_baton, const char *base_checksum, apr_pool_t *pool, svn_txdelta_window_handler_t *handler, void **handler_baton)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="structsvn__delta__editor__t.html#4b1779d19327e0b91285f378e86ede4f">svn_delta_editor_t::apply_textdelta</a>)(void *file_baton, const char *base_checksum, apr_pool_t *pool, <a class="el" href="group__svn__delta__txt__delta.html#g1c0d461a3f244928d7f0339c1cbe3219">svn_txdelta_window_handler_t</a> *handler, void **handler_baton)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply a text delta, yielding the new revision of a file. 
<p>
<em>file_baton</em> indicates the file we're creating or updating, and the ancestor file on which it is based; it is the baton set by some prior <code>add_file</code> or <code>open_file</code> callback.<p>
The callback should set <em>*handler</em> to a text delta window handler; we will then call <em>*handler</em> on successive text delta windows as we receive them. The callback should set <em>*handler_baton</em> to the value we should pass as the <em>baton</em> argument to <em>*handler</em>.<p>
<em>base_checksum</em> is the hex MD5 digest for the base text against which the delta is being applied; it is ignored if NULL, and may be ignored even if not NULL. If it is not ignored, it must match the checksum of the base text against which svndiff data is being applied; if it does not, <code>apply_textdelta</code> or the <em>*handler</em> call which detects the mismatch will return the error SVN_ERR_CHECKSUM_MISMATCH (if there is no base text, there may still be an error if <em>base_checksum</em> is neither NULL nor the hex MD5 checksum of the empty string). 
</div>
</div><p>
<a class="anchor" name="1420252f4b00161b9f7c2461e11e0b40"></a><!-- doxytag: member="svn_delta_editor_t::change_file_prop" ref="1420252f4b00161b9f7c2461e11e0b40" args=")(void *file_baton, const char *name, const svn_string_t *value, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="structsvn__delta__editor__t.html#1420252f4b00161b9f7c2461e11e0b40">svn_delta_editor_t::change_file_prop</a>)(void *file_baton, const char *name, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, apr_pool_t *pool)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change the value of a file's property. 
<p>
<ul>
<li><em>file_baton</em> specifies the file whose property should change.</li><li><em>name</em> is the name of the property to change.</li><li><em>value</em> is the new (final) value of the property, or <code>NULL</code> if the property should be removed altogether.</li></ul>
<p>
The callback is guaranteed to be called exactly once for each property whose value differs between the start and the end of the edit.<p>
All allocations should be performed in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="3851c7e0ac1de721f6f545d2e9a7b473"></a><!-- doxytag: member="svn_delta_editor_t::close_file" ref="3851c7e0ac1de721f6f545d2e9a7b473" args=")(void *file_baton, const char *text_checksum, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="structsvn__delta__editor__t.html#3851c7e0ac1de721f6f545d2e9a7b473">svn_delta_editor_t::close_file</a>)(void *file_baton, const char *text_checksum, apr_pool_t *pool)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
We are done processing a file, whose baton is <em>file_baton</em> (set by <code>add_file</code> or <code>open_file</code>). 
<p>
We won't be using the baton any more, so whatever resources it refers to may now be freed.<p>
<em>text_checksum</em> is the hex MD5 digest for the fulltext that resulted from a delta application, see <code>apply_textdelta</code>. The checksum is ignored if NULL. If not null, it is compared to the checksum of the new fulltext, and the error SVN_ERR_CHECKSUM_MISMATCH is returned if they do not match. If there is no new fulltext, <em>text_checksum</em> is ignored. 
</div>
</div><p>
<a class="anchor" name="b00ee4fc603197bb3f71156b1bbbd577"></a><!-- doxytag: member="svn_delta_editor_t::close_edit" ref="b00ee4fc603197bb3f71156b1bbbd577" args=")(void *edit_baton, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="structsvn__delta__editor__t.html#b00ee4fc603197bb3f71156b1bbbd577">svn_delta_editor_t::close_edit</a>)(void *edit_baton, apr_pool_t *pool)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
All delta processing is done. 
<p>
Call this, with the <em>edit_baton</em> for the entire edit. 
</div>
</div><p>
<a class="anchor" name="12a8990d6e8fbfa3de2f1fa0c68964b8"></a><!-- doxytag: member="svn_delta_editor_t::abort_edit" ref="12a8990d6e8fbfa3de2f1fa0c68964b8" args=")(void *edit_baton, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="structsvn__delta__editor__t.html#12a8990d6e8fbfa3de2f1fa0c68964b8">svn_delta_editor_t::abort_edit</a>)(void *edit_baton, apr_pool_t *pool)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The editor-driver has decided to bail out. 
<p>
Allow the editor to gracefully clean up things if it needs to. 
</div>
</div><p>
<hr>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="svn__delta_8h-source.html">svn_delta.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 24 16:18:30 2008 for Subversion by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
