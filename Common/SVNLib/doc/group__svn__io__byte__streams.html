<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Subversion: Generic byte streams</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Generic byte streams</h1>Generic byte-streams.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An abstract stream of bytes--either incoming or outgoing or both.  <a href="#g06d6291c397e63f895deb92a2c14e6af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g9a8939b5258b070a48aa1e0cd154909a">svn_read_fn_t</a> )(void *baton, char *buffer, apr_size_t *len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read handler function for a generic stream.  <a href="#g9a8939b5258b070a48aa1e0cd154909a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ga79398b116a9209eb3a79947a6066f54">svn_write_fn_t</a> )(void *baton, const char *data, apr_size_t *len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write handler function for a generic stream.  <a href="#ga79398b116a9209eb3a79947a6066f54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g576facc62f51e98c14cb440df1e58cd9">svn_close_fn_t</a> )(void *baton)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close handler function for a generic stream.  <a href="#g576facc62f51e98c14cb440df1e58cd9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gdc3e897290c9479c6b903876d18dc87c">svn_stream_create</a> (void *baton, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a generic stream.  <a href="#gdc3e897290c9479c6b903876d18dc87c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g0ff601f7fb4a7c8c92770edd7376b052"></a><!-- doxytag: member="svn_io_byte_streams::svn_stream_set_baton" ref="g0ff601f7fb4a7c8c92770edd7376b052" args="(svn_stream_t *stream, void *baton)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g0ff601f7fb4a7c8c92770edd7376b052">svn_stream_set_baton</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, void *baton)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>stream's</em> baton to <em>baton</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ge9ebdcf950b897d9c0cb89c331262aed"></a><!-- doxytag: member="svn_io_byte_streams::svn_stream_set_read" ref="ge9ebdcf950b897d9c0cb89c331262aed" args="(svn_stream_t *stream, svn_read_fn_t read_fn)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#ge9ebdcf950b897d9c0cb89c331262aed">svn_stream_set_read</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#g9a8939b5258b070a48aa1e0cd154909a">svn_read_fn_t</a> read_fn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>stream's</em> read function to <em>read_fn</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gea19e182974e64a77d3f949a25f496a1"></a><!-- doxytag: member="svn_io_byte_streams::svn_stream_set_write" ref="gea19e182974e64a77d3f949a25f496a1" args="(svn_stream_t *stream, svn_write_fn_t write_fn)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gea19e182974e64a77d3f949a25f496a1">svn_stream_set_write</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#ga79398b116a9209eb3a79947a6066f54">svn_write_fn_t</a> write_fn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>stream's</em> write function to <em>write_fn</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g090c93a72964b78a00de75fa10fc5078"></a><!-- doxytag: member="svn_io_byte_streams::svn_stream_set_close" ref="g090c93a72964b78a00de75fa10fc5078" args="(svn_stream_t *stream, svn_close_fn_t close_fn)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g090c93a72964b78a00de75fa10fc5078">svn_stream_set_close</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="group__svn__io__byte__streams.html#g576facc62f51e98c14cb440df1e58cd9">svn_close_fn_t</a> close_fn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>stream's</em> close function to <em>close_fn</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g9f0acad4da18e90c1dc5250643af7049">svn_stream_empty</a> (apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a stream that is empty for reading and infinite for writing.  <a href="#g9f0acad4da18e90c1dc5250643af7049"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g61c69116290c1f5e5fedd91ed7bed5ca">svn_stream_disown</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a stream allocated in <em>pool</em> which forwards all requests to <em>stream</em>.  <a href="#g61c69116290c1f5e5fedd91ed7bed5ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gdf2971328919edf3fed5ef8353a90525">svn_stream_from_aprfile2</a> (apr_file_t *file, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> disown, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a stream from an APR file.  <a href="#gdf2971328919edf3fed5ef8353a90525"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gd12a2e4cbc23bcf8ee3f650966b8c43b">svn_stream_from_aprfile</a> (apr_file_t *file, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="group__svn__io__byte__streams.html#gdf2971328919edf3fed5ef8353a90525" title="Create a stream from an APR file.">svn_stream_from_aprfile2()</a>, except that the file will always be disowned.  <a href="#gd12a2e4cbc23bcf8ee3f650966b8c43b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g64eca282d3b75b431a6f8ae5a6637fbb">svn_stream_for_stdout</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **out, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*out</em> to a generic stream connected to stdout, allocated in <em>pool</em>.  <a href="#g64eca282d3b75b431a6f8ae5a6637fbb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gbe260b52fa278bc63ba75ea695e54303">svn_stream_from_stringbuf</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *str, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a generic stream connected to stringbuf <em>str</em>.  <a href="#gbe260b52fa278bc63ba75ea695e54303"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g10756ab562fd20d32fb880c859607b4c">svn_stream_compressed</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a stream that decompresses all data read and compresses all data written.  <a href="#g10756ab562fd20d32fb880c859607b4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gdda74c8a8bf6d4dc64488979aa197afc">svn_stream_checksummed</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const unsigned char **read_digest, const unsigned char **write_digest, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> read_all, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a stream that calculates checksums for all data read and written.  <a href="#gdda74c8a8bf6d4dc64488979aa197afc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g241e8929f8f7631a629142bd749b25fc">svn_stream_read</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, char *buffer, apr_size_t *len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read from a generic stream.  <a href="#g241e8929f8f7631a629142bd749b25fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g0094764a89afdedecac79df9ad1ebccb">svn_stream_write</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const char *data, apr_size_t *len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to a generic stream.  <a href="#g0094764a89afdedecac79df9ad1ebccb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g7d9cdab4d5d8707d59a1b1d3dab95bb4">svn_stream_close</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a generic stream.  <a href="#g7d9cdab4d5d8707d59a1b1d3dab95bb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g288ac398ebf52240457408a18ca0479f"></a><!-- doxytag: member="svn_io_byte_streams::svn_stream_printf" ref="g288ac398ebf52240457408a18ca0479f" args="(svn_stream_t *stream, apr_pool_t *pool, const char *fmt,...) __attribute__((format(printf" -->
<a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g288ac398ebf52240457408a18ca0479f">svn_stream_printf</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, apr_pool_t *pool, const char *fmt,...) __attribute__((format(printf</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to <em>stream</em> using a printf-style <em>fmt</em> specifier, passed through apr_psprintf() using memory from <em>pool</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> <a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g4ca0edf4a668ba821d7dc5356361c658">svn_stream_printf_from_utf8</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, const char *encoding, apr_pool_t *pool, const char *fmt,...) __attribute__((format(printf</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to <em>stream</em> using a printf-style <em>fmt</em> specifier, passed through apr_psprintf() using memory from <em>pool</em>.  <a href="#g4ca0edf4a668ba821d7dc5356361c658"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> <a class="el" href="structsvn__error__t.html">svn_error_t</a> <br>
<a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#gac6d0a2e4bd56065397a058f792899e9">svn_stream_readline</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream, <a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **stringbuf, const char *eol, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *eof, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate <em>*stringbuf</em> in <em>pool</em>, and read into it one line (terminated by <em>eol</em>) from <em>stream</em>.  <a href="#gac6d0a2e4bd56065397a058f792899e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g1960de4b4eb0cf1a69a5ba5e11aaa6be">svn_stream_copy2</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *from, <a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *to, <a class="el" href="svn__types_8h.html#ddaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the contents of the readable stream <em>from</em> and write them to the writable stream <em>to</em> calling <em>cancel_func</em> before copying each chunk.  <a href="#g1960de4b4eb0cf1a69a5ba5e11aaa6be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g444db383401ed714a240ff6ca5ca76b3">svn_stream_copy</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *from, <a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *to, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="group__svn__io__byte__streams.html#g1960de4b4eb0cf1a69a5ba5e11aaa6be" title="Read the contents of the readable stream from and write them to the writable stream...">svn_stream_copy2()</a>, but without the cancellation function.  <a href="#g444db383401ed714a240ff6ca5ca76b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__io__byte__streams.html#g14b9375f4e0300888b853650e15a987a">svn_stream_contents_same</a> (<a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *same, <a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream1, <a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *stream2, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*same</em> to TRUE if <em>stream1</em> and <em>stream2</em> have the same contents, else set it to FALSE.  <a href="#g14b9375f4e0300888b853650e15a987a"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Generic byte-streams. 
<p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g576facc62f51e98c14cb440df1e58cd9"></a><!-- doxytag: member="svn_io.h::svn_close_fn_t" ref="g576facc62f51e98c14cb440df1e58cd9" args=")(void *baton)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="group__svn__io__byte__streams.html#g576facc62f51e98c14cb440df1e58cd9">svn_close_fn_t</a>)(void *baton)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close handler function for a generic stream. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of bytes--either incoming or outgoing or both.">svn_stream_t</a>. </dd></dl>

<p>Definition at line <a class="el" href="svn__io_8h-source.html#l00562">562</a> of file <a class="el" href="svn__io_8h-source.html">svn_io.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="g9a8939b5258b070a48aa1e0cd154909a"></a><!-- doxytag: member="svn_io.h::svn_read_fn_t" ref="g9a8939b5258b070a48aa1e0cd154909a" args=")(void *baton, char *buffer, apr_size_t *len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="group__svn__io__byte__streams.html#g9a8939b5258b070a48aa1e0cd154909a">svn_read_fn_t</a>)(void *baton, char *buffer, apr_size_t *len)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read handler function for a generic stream. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of bytes--either incoming or outgoing or both.">svn_stream_t</a>. </dd></dl>

<p>Definition at line <a class="el" href="svn__io_8h-source.html#l00552">552</a> of file <a class="el" href="svn__io_8h-source.html">svn_io.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="g06d6291c397e63f895deb92a2c14e6af"></a><!-- doxytag: member="svn_io.h::svn_stream_t" ref="g06d6291c397e63f895deb92a2c14e6af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> <a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An abstract stream of bytes--either incoming or outgoing or both. 
<p>
The creator of a stream sets functions to handle read and write. Both of these handlers accept a baton whose value is determined at stream creation time; this baton can point to a structure containing data associated with the stream. If a caller attempts to invoke a handler which has not been set, it will generate a runtime assertion failure. The creator can also set a handler for close requests so that it can flush buffered data or whatever; if a close handler is not specified, a close request on the stream will simply be ignored. Note that <a class="el" href="group__svn__io__byte__streams.html#g7d9cdab4d5d8707d59a1b1d3dab95bb4" title="Close a generic stream.">svn_stream_close()</a> does not deallocate the memory used to allocate the stream structure; free the pool you created the stream in to free that memory.<p>
The read and write handlers accept length arguments via pointer. On entry to the handler, the pointed-to value should be the amount of data which can be read or the amount of data to write. When the handler returns, the value is reset to the amount of data actually read or written. Handlers are obliged to complete a read or write to the maximum extent possible; thus, a short read with no associated error implies the end of the input stream, and a short write should never occur without an associated error. 
<p>Definition at line <a class="el" href="svn__io_8h-source.html#l00547">547</a> of file <a class="el" href="svn__io_8h-source.html">svn_io.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="ga79398b116a9209eb3a79947a6066f54"></a><!-- doxytag: member="svn_io.h::svn_write_fn_t" ref="ga79398b116a9209eb3a79947a6066f54" args=")(void *baton, const char *data, apr_size_t *len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* <a class="el" href="group__svn__io__byte__streams.html#ga79398b116a9209eb3a79947a6066f54">svn_write_fn_t</a>)(void *baton, const char *data, apr_size_t *len)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write handler function for a generic stream. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of bytes--either incoming or outgoing or both.">svn_stream_t</a>. </dd></dl>

<p>Definition at line <a class="el" href="svn__io_8h-source.html#l00557">557</a> of file <a class="el" href="svn__io_8h-source.html">svn_io.h</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gdda74c8a8bf6d4dc64488979aa197afc"></a><!-- doxytag: member="svn_io.h::svn_stream_checksummed" ref="gdda74c8a8bf6d4dc64488979aa197afc" args="(svn_stream_t *stream, const unsigned char **read_digest, const unsigned char **write_digest, svn_boolean_t read_all, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_checksummed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char **&nbsp;</td>
          <td class="paramname"> <em>read_digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char **&nbsp;</td>
          <td class="paramname"> <em>write_digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>read_all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a stream that calculates checksums for all data read and written. 
<p>
The stream <em>stream</em> is used to read and write all data. The stream and the resulting digests are allocated in <em>pool</em>.<p>
When the stream is closed, <em>read_digest</em> and <em>write_digest</em> are set to point to the resulting digests.<p>
Both <em>read_digest</em> and <em>write_digest</em> can be <code>NULL</code>, in which case the respective checksum isn't calculated.<p>
If <em>read_all</em> is TRUE, make sure that all data available on <em>stream</em> is read (and checksummed) when the stream is closed.<p>
Read and write operations can be mixed without interfering.<p>
The <em>stream</em> passed into this function is closed when the created stream is closed.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.4. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7d9cdab4d5d8707d59a1b1d3dab95bb4"></a><!-- doxytag: member="svn_io.h::svn_stream_close" ref="g7d9cdab4d5d8707d59a1b1d3dab95bb4" args="(svn_stream_t *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_close           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close a generic stream. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of bytes--either incoming or outgoing or both.">svn_stream_t</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g10756ab562fd20d32fb880c859607b4c"></a><!-- doxytag: member="svn_io.h::svn_stream_compressed" ref="g10756ab562fd20d32fb880c859607b4c" args="(svn_stream_t *stream, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_compressed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a stream that decompresses all data read and compresses all data written. 
<p>
The stream <em>stream</em> is used to read and write all compressed data. All compression data structures are allocated on <em>pool</em>. If compression support is not compiled in then <a class="el" href="group__svn__io__byte__streams.html#g10756ab562fd20d32fb880c859607b4c" title="Return a stream that decompresses all data read and compresses all data written.">svn_stream_compressed()</a> returns <em>stream</em> unmodified. Make sure you call <a class="el" href="group__svn__io__byte__streams.html#g7d9cdab4d5d8707d59a1b1d3dab95bb4" title="Close a generic stream.">svn_stream_close()</a> on the stream returned by this function, so that all data are flushed and cleaned up.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>From 1.4, compression support is always compiled in. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g14b9375f4e0300888b853650e15a987a"></a><!-- doxytag: member="svn_io.h::svn_stream_contents_same" ref="g14b9375f4e0300888b853650e15a987a" args="(svn_boolean_t *same, svn_stream_t *stream1, svn_stream_t *stream2, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_contents_same           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&nbsp;</td>
          <td class="paramname"> <em>same</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stream1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stream2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*same</em> to TRUE if <em>stream1</em> and <em>stream2</em> have the same contents, else set it to FALSE. 
<p>
Use <em>pool</em> for temporary allocations.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.4. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g444db383401ed714a240ff6ca5ca76b3"></a><!-- doxytag: member="svn_io.h::svn_stream_copy" ref="g444db383401ed714a240ff6ca5ca76b3" args="(svn_stream_t *from, svn_stream_t *to, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_copy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="group__svn__io__byte__streams.html#g1960de4b4eb0cf1a69a5ba5e11aaa6be" title="Read the contents of the readable stream from and write them to the writable stream...">svn_stream_copy2()</a>, but without the cancellation function. 
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000124">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.4 API. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1960de4b4eb0cf1a69a5ba5e11aaa6be"></a><!-- doxytag: member="svn_io.h::svn_stream_copy2" ref="g1960de4b4eb0cf1a69a5ba5e11aaa6be" args="(svn_stream_t *from, svn_stream_t *to, svn_cancel_func_t cancel_func, void *cancel_baton, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_copy2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#ddaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a>&nbsp;</td>
          <td class="paramname"> <em>cancel_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cancel_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read the contents of the readable stream <em>from</em> and write them to the writable stream <em>to</em> calling <em>cancel_func</em> before copying each chunk. 
<p>
<em>cancel_func</em> may be <code>NULL</code>.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gdc3e897290c9479c6b903876d18dc87c"></a><!-- doxytag: member="svn_io.h::svn_stream_create" ref="gdc3e897290c9479c6b903876d18dc87c" args="(void *baton, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_create           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a generic stream. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of bytes--either incoming or outgoing or both.">svn_stream_t</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g61c69116290c1f5e5fedd91ed7bed5ca"></a><!-- doxytag: member="svn_io.h::svn_stream_disown" ref="g61c69116290c1f5e5fedd91ed7bed5ca" args="(svn_stream_t *stream, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_disown           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a stream allocated in <em>pool</em> which forwards all requests to <em>stream</em>. 
<p>
Destruction is explicitly excluded from forwarding.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>notes/destruction-of-stacked-resources</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.4. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9f0acad4da18e90c1dc5250643af7049"></a><!-- doxytag: member="svn_io.h::svn_stream_empty" ref="g9f0acad4da18e90c1dc5250643af7049" args="(apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_empty           </td>
          <td>(</td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a stream that is empty for reading and infinite for writing. 
<p>

</div>
</div><p>
<a class="anchor" name="g64eca282d3b75b431a6f8ae5a6637fbb"></a><!-- doxytag: member="svn_io.h::svn_stream_for_stdout" ref="g64eca282d3b75b431a6f8ae5a6637fbb" args="(svn_stream_t **out, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_for_stdout           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*out</em> to a generic stream connected to stdout, allocated in <em>pool</em>. 
<p>
The stream and its underlying APR handle will be closed when <em>pool</em> is cleared or destroyed. 
</div>
</div><p>
<a class="anchor" name="gd12a2e4cbc23bcf8ee3f650966b8c43b"></a><!-- doxytag: member="svn_io.h::svn_stream_from_aprfile" ref="gd12a2e4cbc23bcf8ee3f650966b8c43b" args="(apr_file_t *file, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_from_aprfile           </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to <a class="el" href="group__svn__io__byte__streams.html#gdf2971328919edf3fed5ef8353a90525" title="Create a stream from an APR file.">svn_stream_from_aprfile2()</a>, except that the file will always be disowned. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The stream returned is not considered to "own" the underlying file, meaning that <a class="el" href="group__svn__io__byte__streams.html#g7d9cdab4d5d8707d59a1b1d3dab95bb4" title="Close a generic stream.">svn_stream_close()</a> on the stream will not close the file.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000123">Deprecated:</a></b></dt><dd>Provided for backward compatibility with the 1.3 API. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gdf2971328919edf3fed5ef8353a90525"></a><!-- doxytag: member="svn_io.h::svn_stream_from_aprfile2" ref="gdf2971328919edf3fed5ef8353a90525" args="(apr_file_t *file, svn_boolean_t disown, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_from_aprfile2           </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>disown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a stream from an APR file. 
<p>
For convenience, if <em>file</em> is <code>NULL</code>, an empty stream created by <a class="el" href="group__svn__io__byte__streams.html#g9f0acad4da18e90c1dc5250643af7049" title="Create a stream that is empty for reading and infinite for writing.">svn_stream_empty()</a> is returned.<p>
This function should normally be called with <em>disown</em> set to FALSE, in which case closing the stream will also close the underlying file.<p>
If <em>disown</em> is TRUE, the stream will disown the underlying file, meaning that <a class="el" href="group__svn__io__byte__streams.html#g7d9cdab4d5d8707d59a1b1d3dab95bb4" title="Close a generic stream.">svn_stream_close()</a> will not close the file.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.4. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbe260b52fa278bc63ba75ea695e54303"></a><!-- doxytag: member="svn_io.h::svn_stream_from_stringbuf" ref="gbe260b52fa278bc63ba75ea695e54303" args="(svn_stringbuf_t *str, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a>* svn_stream_from_stringbuf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a generic stream connected to stringbuf <em>str</em>. 
<p>
Allocate the stream in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="g4ca0edf4a668ba821d7dc5356361c658"></a><!-- doxytag: member="svn_io.h::svn_stream_printf_from_utf8" ref="g4ca0edf4a668ba821d7dc5356361c658" args="(svn_stream_t *stream, const char *encoding, apr_pool_t *pool, const char *fmt,...) __attribute__((format(printf" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a> <a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_printf_from_utf8           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write to <em>stream</em> using a printf-style <em>fmt</em> specifier, passed through apr_psprintf() using memory from <em>pool</em>. 
<p>
The resulting string will be translated to <em>encoding</em> before it is sent to <em>stream</em>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Use <code>APR_LOCALE_CHARSET</code> to translate to the encoding of the current locale.</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g241e8929f8f7631a629142bd749b25fc"></a><!-- doxytag: member="svn_io.h::svn_stream_read" ref="g241e8929f8f7631a629142bd749b25fc" args="(svn_stream_t *stream, char *buffer, apr_size_t *len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_read           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read from a generic stream. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of bytes--either incoming or outgoing or both.">svn_stream_t</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gac6d0a2e4bd56065397a058f792899e9"></a><!-- doxytag: member="svn_io.h::svn_stream_readline" ref="gac6d0a2e4bd56065397a058f792899e9" args="(svn_stream_t *stream, svn_stringbuf_t **stringbuf, const char *eol, svn_boolean_t *eof, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a> <a class="el" href="structsvn__error__t.html">svn_error_t</a> <a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_readline           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> **&nbsp;</td>
          <td class="paramname"> <em>stringbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>eol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&nbsp;</td>
          <td class="paramname"> <em>eof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate <em>*stringbuf</em> in <em>pool</em>, and read into it one line (terminated by <em>eol</em>) from <em>stream</em>. 
<p>
The line-terminator is read from the stream, but is not added to the end of the stringbuf. Instead, the stringbuf ends with a usual '\0'.<p>
If <em>stream</em> runs out of bytes before encountering a line-terminator, then set <em>*eof</em> to <code>TRUE</code>, otherwise set <em>*eof</em> to FALSE. 
</div>
</div><p>
<a class="anchor" name="g0094764a89afdedecac79df9ad1ebccb"></a><!-- doxytag: member="svn_io.h::svn_stream_write" ref="g0094764a89afdedecac79df9ad1ebccb" args="(svn_stream_t *stream, const char *data, apr_size_t *len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_stream_write           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write to a generic stream. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af" title="An abstract stream of bytes--either incoming or outgoing or both.">svn_stream_t</a>. </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 24 16:18:30 2008 for Subversion by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
