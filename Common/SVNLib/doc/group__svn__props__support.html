<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Subversion: Properties management utilities</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Properties management utilities</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__prop__visible__props.html">Visible properties</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visible properties. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__prop__invisible__props.html">Invisible properties</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">WC props are props that are invisible to users: they're generated by an RA layer, and stored in secret parts of .svn/. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__revision__props.html">Revision properties</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">These are reserved properties attached to a "revision" object in the repository filesystem. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__prop__t.html">svn_prop_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A general in-memory representation of a single property.  <a href="structsvn__prop__t.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#g17fe0cc2c221f33d00a2c917ad66bfd4">SVN_PROP_PREFIX</a>&nbsp;&nbsp;&nbsp;&quot;svn:&quot;</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All Subversion property names start with this.  <a href="#g17fe0cc2c221f33d00a2c917ad66bfd4"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef enum <a class="el" href="group__svn__props__support.html#ga0c97177ba40e8e33fd850e602ddb1dd">svn_prop_kind</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#g8fc9e0c3d9592228a6201fb0427300f2">svn_prop_kind_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subversion distinguishes among several kinds of properties, particularly on the client-side.  <a href="#g8fc9e0c3d9592228a6201fb0427300f2"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#ga0c97177ba40e8e33fd850e602ddb1dd">svn_prop_kind</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__svn__props__support.html#gga0c97177ba40e8e33fd850e602ddb1dd0e8d7ebcccd8f8e93d6e841fe99d1555">svn_prop_entry_kind</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__svn__props__support.html#gga0c97177ba40e8e33fd850e602ddb1ddfdb8cf1192f05d6a527af2a01162b731">svn_prop_wc_kind</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__svn__props__support.html#gga0c97177ba40e8e33fd850e602ddb1dde9812bbe73d1c26ebd4ff4bee9a29c55">svn_prop_regular_kind</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subversion distinguishes among several kinds of properties, particularly on the client-side.  <a href="group__svn__props__support.html#ga0c97177ba40e8e33fd850e602ddb1dd">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__prop__t.html">svn_prop_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#g5114675d164192281792515618c35b05">svn_prop_dup</a> (const <a class="el" href="structsvn__prop__t.html">svn_prop_t</a> *prop, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a duplicate of <em>prop</em>, allocated in <em>pool</em>.  <a href="#g5114675d164192281792515618c35b05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">apr_array_header_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#g62cf1379430ffe507fbcf87e3366ec1e">svn_prop_array_dup</a> (const apr_array_header_t *array, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate an <em>array</em> of <a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a> items using <em>pool</em>.  <a href="#g62cf1379430ffe507fbcf87e3366ec1e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">apr_array_header_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#g319fb0697c00fbf428bbf4f99f2986c7">svn_prop_hash_to_array</a> (apr_hash_t *hash, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a hash (keys <code>const char *</code> and values <code>const <a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a></code>) of properties, returns an array of <a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a> items using <em>pool</em>.  <a href="#g319fb0697c00fbf428bbf4f99f2986c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g19f2e2d408625f203ffc15e891d42685"></a><!-- doxytag: member="svn_props_support::svn_property_kind" ref="g19f2e2d408625f203ffc15e891d42685" args="(int *prefix_len, const char *prop_name)" -->
<a class="el" href="group__svn__props__support.html#g8fc9e0c3d9592228a6201fb0427300f2">svn_prop_kind_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#g19f2e2d408625f203ffc15e891d42685">svn_property_kind</a> (int *prefix_len, const char *prop_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the prop kind of a property named <em>prop_name</em>, and (if <em>prefix_len</em> is non-<code>NULL</code>) set <em>*prefix_len</em> to the length of the prefix of <em>prop_name</em> that was sufficient to distinguish its kind. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g58cc19cd57bb0447ef863a85317927ee"></a><!-- doxytag: member="svn_props_support::svn_prop_is_svn_prop" ref="g58cc19cd57bb0447ef863a85317927ee" args="(const char *prop_name)" -->
<a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#g58cc19cd57bb0447ef863a85317927ee">svn_prop_is_svn_prop</a> (const char *prop_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>TRUE</code> iff <em>prop_name</em> represents the name of a Subversion property. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#g7a794c955cff9856de467f37b8ab7652">svn_prop_has_svn_prop</a> (const apr_hash_t *props, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>TRUE</code> iff <em>props</em> has at least one property whose name represents the name of a Subversion property.  <a href="#g7a794c955cff9856de467f37b8ab7652"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#gd4ae64b1be310c63ce845b20c41bdd3e">svn_prop_is_boolean</a> (const char *prop_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>TRUE</code> iff <em>prop_name</em> is a Subversion property whose value is interpreted as a boolean.  <a href="#gd4ae64b1be310c63ce845b20c41bdd3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#g2b23f5fbe4e1736ccced93b538df782d">svn_prop_needs_translation</a> (const char *prop_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <em>prop_name</em> requires that its value be stored as UTF8/LF in the repository, then return <code>TRUE</code>.  <a href="#g2b23f5fbe4e1736ccced93b538df782d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#ge806e7d928a297de625414f2859fb9ba">svn_categorize_props</a> (const apr_array_header_t *proplist, apr_array_header_t **entry_props, apr_array_header_t **wc_props, apr_array_header_t **regular_props, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a <em>proplist</em> array of <code><a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a></code> structures, allocate three new arrays in <em>pool</em>.  <a href="#ge806e7d928a297de625414f2859fb9ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#g3f0bef17700d7f2b500272814d6fb905">svn_prop_diffs</a> (apr_array_header_t **propdiffs, apr_hash_t *target_props, apr_hash_t *source_props, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given two property hashes (<code>const char *name</code> -&gt; <code>const <a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a> *value</code>), deduce the differences between them (from <em>source_props</em> -&gt; <code>target_props</code>).  <a href="#g3f0bef17700d7f2b500272814d6fb905"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__props__support.html#gac6f7d19c68fa4865d0adea1ee741e4a">svn_prop_name_is_valid</a> (const char *prop_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>TRUE</code> iff <em>prop_name</em> is a valid property name.  <a href="#gac6f7d19c68fa4865d0adea1ee741e4a"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="g17fe0cc2c221f33d00a2c917ad66bfd4"></a><!-- doxytag: member="svn_props.h::SVN_PROP_PREFIX" ref="g17fe0cc2c221f33d00a2c917ad66bfd4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SVN_PROP_PREFIX&nbsp;&nbsp;&nbsp;&quot;svn:&quot;          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
All Subversion property names start with this. 
<p>

<p>Definition at line <a class="el" href="svn__props_8h-source.html#l00207">207</a> of file <a class="el" href="svn__props_8h-source.html">svn_props.h</a>.</p>

</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g8fc9e0c3d9592228a6201fb0427300f2"></a><!-- doxytag: member="svn_props.h::svn_prop_kind_t" ref="g8fc9e0c3d9592228a6201fb0427300f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group__svn__props__support.html#ga0c97177ba40e8e33fd850e602ddb1dd">svn_prop_kind</a>  <a class="el" href="group__svn__props__support.html#g8fc9e0c3d9592228a6201fb0427300f2">svn_prop_kind_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subversion distinguishes among several kinds of properties, particularly on the client-side. 
<p>
There is no "unknown" kind; if there's nothing special about a property name, the default category is <code>svn_prop_regular_kind</code>. 
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="ga0c97177ba40e8e33fd850e602ddb1dd"></a><!-- doxytag: member="svn_props.h::svn_prop_kind" ref="ga0c97177ba40e8e33fd850e602ddb1dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__svn__props__support.html#ga0c97177ba40e8e33fd850e602ddb1dd">svn_prop_kind</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subversion distinguishes among several kinds of properties, particularly on the client-side. 
<p>
There is no "unknown" kind; if there's nothing special about a property name, the default category is <code>svn_prop_regular_kind</code>. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gga0c97177ba40e8e33fd850e602ddb1dd0e8d7ebcccd8f8e93d6e841fe99d1555"></a><!-- doxytag: member="svn_prop_entry_kind" ref="gga0c97177ba40e8e33fd850e602ddb1dd0e8d7ebcccd8f8e93d6e841fe99d1555" args="" -->svn_prop_entry_kind</em>&nbsp;</td><td>
In .svn/entries, i.e., author, date, etc. 
<p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga0c97177ba40e8e33fd850e602ddb1ddfdb8cf1192f05d6a527af2a01162b731"></a><!-- doxytag: member="svn_prop_wc_kind" ref="gga0c97177ba40e8e33fd850e602ddb1ddfdb8cf1192f05d6a527af2a01162b731" args="" -->svn_prop_wc_kind</em>&nbsp;</td><td>
Client-side only, stored by specific RA layer. 
<p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga0c97177ba40e8e33fd850e602ddb1dde9812bbe73d1c26ebd4ff4bee9a29c55"></a><!-- doxytag: member="svn_prop_regular_kind" ref="gga0c97177ba40e8e33fd850e602ddb1dde9812bbe73d1c26ebd4ff4bee9a29c55" args="" -->svn_prop_regular_kind</em>&nbsp;</td><td>
Seen if user does "svn proplist"; note that this includes some "svn:" props and all user props, i.e. 
<p>
ones stored in the repository fs. </td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="svn__props_8h-source.html#l00095">95</a> of file <a class="el" href="svn__props_8h-source.html">svn_props.h</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ge806e7d928a297de625414f2859fb9ba"></a><!-- doxytag: member="svn_props.h::svn_categorize_props" ref="ge806e7d928a297de625414f2859fb9ba" args="(const apr_array_header_t *proplist, apr_array_header_t **entry_props, apr_array_header_t **wc_props, apr_array_header_t **regular_props, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_categorize_props           </td>
          <td>(</td>
          <td class="paramtype">const apr_array_header_t *&nbsp;</td>
          <td class="paramname"> <em>proplist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_array_header_t **&nbsp;</td>
          <td class="paramname"> <em>entry_props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_array_header_t **&nbsp;</td>
          <td class="paramname"> <em>wc_props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_array_header_t **&nbsp;</td>
          <td class="paramname"> <em>regular_props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a <em>proplist</em> array of <code><a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a></code> structures, allocate three new arrays in <em>pool</em>. 
<p>
Categorize each property and then create new <code><a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a></code> structures in the proper lists. Each new <code><a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a></code> structure's fields will point to the same data within <em>proplist's</em> structures.<p>
Callers may pass NULL for each of the property lists in which they are uninterested. If no props exist in a certain category, and the property list argument for that category is non-NULL, then that array will come back with <code>-&gt;nelts == 0</code>.<p>
### Hmmm, maybe a better future interface is to return an array of arrays, where the index into the array represents the index into <code>svn_prop_kind_t</code>. That way we can add more prop kinds in the future without changing this interface... 
</div>
</div><p>
<a class="anchor" name="g62cf1379430ffe507fbcf87e3366ec1e"></a><!-- doxytag: member="svn_props.h::svn_prop_array_dup" ref="g62cf1379430ffe507fbcf87e3366ec1e" args="(const apr_array_header_t *array, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_array_header_t* svn_prop_array_dup           </td>
          <td>(</td>
          <td class="paramtype">const apr_array_header_t *&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Duplicate an <em>array</em> of <a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a> items using <em>pool</em>. 
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3f0bef17700d7f2b500272814d6fb905"></a><!-- doxytag: member="svn_props.h::svn_prop_diffs" ref="g3f0bef17700d7f2b500272814d6fb905" args="(apr_array_header_t **propdiffs, apr_hash_t *target_props, apr_hash_t *source_props, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_prop_diffs           </td>
          <td>(</td>
          <td class="paramtype">apr_array_header_t **&nbsp;</td>
          <td class="paramname"> <em>propdiffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&nbsp;</td>
          <td class="paramname"> <em>target_props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&nbsp;</td>
          <td class="paramname"> <em>source_props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given two property hashes (<code>const char *name</code> -&gt; <code>const <a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a> *value</code>), deduce the differences between them (from <em>source_props</em> -&gt; <code>target_props</code>). 
<p>
Return these changes as a series of <code><a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a></code> structures stored in <em>propdiffs</em>, allocated from <em>pool</em>.<p>
For note, here's a quick little table describing the logic of this routine:<p>
<div class="fragment"><pre class="fragment">
   basehash        localhash         event
   --------        ---------         -----
   value = foo     value = NULL      Deletion occurred.
   value = foo     value = bar       Set occurred (modification)
   value = NULL    value = baz       Set occurred (creation) </pre></div> 
</div>
</div><p>
<a class="anchor" name="g5114675d164192281792515618c35b05"></a><!-- doxytag: member="svn_props.h::svn_prop_dup" ref="g5114675d164192281792515618c35b05" args="(const svn_prop_t *prop, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__prop__t.html">svn_prop_t</a>* svn_prop_dup           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsvn__prop__t.html">svn_prop_t</a> *&nbsp;</td>
          <td class="paramname"> <em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a duplicate of <em>prop</em>, allocated in <em>pool</em>. 
<p>
No part of the new structure will be shared with <em>prop</em>.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7a794c955cff9856de467f37b8ab7652"></a><!-- doxytag: member="svn_props.h::svn_prop_has_svn_prop" ref="g7a794c955cff9856de467f37b8ab7652" args="(const apr_hash_t *props, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_prop_has_svn_prop           </td>
          <td>(</td>
          <td class="paramtype">const apr_hash_t *&nbsp;</td>
          <td class="paramname"> <em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return <code>TRUE</code> iff <em>props</em> has at least one property whose name represents the name of a Subversion property. 
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g319fb0697c00fbf428bbf4f99f2986c7"></a><!-- doxytag: member="svn_props.h::svn_prop_hash_to_array" ref="g319fb0697c00fbf428bbf4f99f2986c7" args="(apr_hash_t *hash, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_array_header_t* svn_prop_hash_to_array           </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t *&nbsp;</td>
          <td class="paramname"> <em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a hash (keys <code>const char *</code> and values <code>const <a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a></code>) of properties, returns an array of <a class="el" href="structsvn__prop__t.html" title="A general in-memory representation of a single property.">svn_prop_t</a> items using <em>pool</em>. 
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd4ae64b1be310c63ce845b20c41bdd3e"></a><!-- doxytag: member="svn_props.h::svn_prop_is_boolean" ref="gd4ae64b1be310c63ce845b20c41bdd3e" args="(const char *prop_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_prop_is_boolean           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>prop_name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return <code>TRUE</code> iff <em>prop_name</em> is a Subversion property whose value is interpreted as a boolean. 
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gac6f7d19c68fa4865d0adea1ee741e4a"></a><!-- doxytag: member="svn_props.h::svn_prop_name_is_valid" ref="gac6f7d19c68fa4865d0adea1ee741e4a" args="(const char *prop_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_prop_name_is_valid           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>prop_name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return <code>TRUE</code> iff <em>prop_name</em> is a valid property name. 
<p>
For now, "valid" means the ASCII subset of an XML "Name". XML "Name" is defined at <a href="http://www.w3.org/TR/REC-xml#sec-common-syn">http://www.w3.org/TR/REC-xml#sec-common-syn</a><p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2b23f5fbe4e1736ccced93b538df782d"></a><!-- doxytag: member="svn_props.h::svn_prop_needs_translation" ref="g2b23f5fbe4e1736ccced93b538df782d" args="(const char *prop_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_prop_needs_translation           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>prop_name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If <em>prop_name</em> requires that its value be stored as UTF8/LF in the repository, then return <code>TRUE</code>. 
<p>
Else return <code>FALSE</code>. This is for users of libsvn_client or libsvn_fs, since it their responsibility to do this translation in both directions. (See <a class="el" href="svn__subst_8h.html#626c5dcfbbf5057ebc0e384187f6d330" title="Translate the data in value (assumed to be in encoded in charset encoding) to UTF8...">svn_subst_translate_string()</a>/svn_subst_detranslate_string() for help with this task.) 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 24 16:18:30 2008 for Subversion by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
