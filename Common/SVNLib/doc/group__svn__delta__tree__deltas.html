<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Subversion: Tree deltas</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Tree deltas<br>
<small>
[<a class="el" href="group__delta__support.html">Delta generation and handling</a>]</small>
</h1>Traversing tree deltas.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html">svn_delta_editor_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A structure full of callback functions the delta source will invoke as it produces the delta.  <a href="structsvn__delta__editor__t.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__delta__editor__t.html">svn_delta_editor_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__delta__tree__deltas.html#gb15253a8fcc50b7813844832016641a2">svn_delta_default_editor</a> (apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a default delta editor template, allocated in <em>pool</em>.  <a href="#gb15253a8fcc50b7813844832016641a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__delta__tree__deltas.html#g277d961312294cd385710ee4d32d7f3d">svn_delta_noop_window_handler</a> (<a class="el" href="structsvn__txdelta__window__t.html">svn_txdelta_window_t</a> *window, void *baton)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A text-delta window handler which does nothing.  <a href="#g277d961312294cd385710ee4d32d7f3d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__delta__tree__deltas.html#g8f1c0290d6cea00bb1919e8a23087650">svn_delta_get_cancellation_editor</a> (<a class="el" href="svn__types_8h.html#ddaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, const <a class="el" href="structsvn__delta__editor__t.html">svn_delta_editor_t</a> *wrapped_editor, void *wrapped_baton, const <a class="el" href="structsvn__delta__editor__t.html">svn_delta_editor_t</a> **editor, void **edit_baton, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*editor</em> and <em>*edit_baton</em> to a cancellation editor that wraps <em>wrapped_editor</em> and <em>wrapped_baton</em>.  <a href="#g8f1c0290d6cea00bb1919e8a23087650"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__delta__tree__deltas.html#gbbbc5a169982cca58a3b87bc425d50c1">svn_delta_depth_filter_editor</a> (const <a class="el" href="structsvn__delta__editor__t.html">svn_delta_editor_t</a> **editor, void **edit_baton, const <a class="el" href="structsvn__delta__editor__t.html">svn_delta_editor_t</a> *wrapped_editor, void *wrapped_edit_baton, <a class="el" href="svn__types_8h.html#21dd8b080111fa6fb5d59156299f3a2c">svn_depth_t</a> requested_depth, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> has_target, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*editor</em> and <em>*edit_baton</em> to an depth-based filtering editor that wraps <em>wrapped_editor</em> and <em>wrapped_baton</em>.  <a href="#gbbbc5a169982cca58a3b87bc425d50c1"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Traversing tree deltas. 
<p>
In Subversion, we've got various producers and consumers of tree deltas.<p>
In processing a `commit' command:<ul>
<li>The client examines its working copy data, and produces a tree delta describing the changes to be committed.</li><li>The client networking library consumes that delta, and sends them across the wire as an equivalent series of network requests (for example, to svnserve as an ra_svn protocol stream, or to an Apache httpd server as WebDAV commands)</li><li>The server receives those requests and produces a tree delta --- hopefully equivalent to the one the client produced above.</li><li>The Subversion server module consumes that delta and commits an appropriate transaction to the filesystem.</li></ul>
<p>
In processing an `update' command, the process is reversed:<ul>
<li>The Subversion server module talks to the filesystem and produces a tree delta describing the changes necessary to bring the client's working copy up to date.</li><li>The server consumes this delta, and assembles a reply representing the appropriate changes.</li><li>The client networking library receives that reply, and produces a tree delta --- hopefully equivalent to the one the Subversion server produced above.</li><li>The working copy library consumes that delta, and makes the appropriate changes to the working copy.</li></ul>
<p>
The simplest approach would be to represent tree deltas using the obvious data structure. To do an update, the server would construct a delta structure, and the working copy library would apply that structure to the working copy; the network layer's job would simply be to get the structure across the net intact.<p>
However, we expect that these deltas will occasionally be too large to fit in a typical workstation's swap area. For example, in checking out a 200Mb source tree, the entire source tree is represented by a single tree delta. So it's important to handle deltas that are too large to fit in swap all at once.<p>
So instead of representing the tree delta explicitly, we define a standard way for a consumer to process each piece of a tree delta as soon as the producer creates it. The <code><a class="el" href="structsvn__delta__editor__t.html" title="A structure full of callback functions the delta source will invoke as it produces...">svn_delta_editor_t</a></code> structure is a set of callback functions to be defined by a delta consumer, and invoked by a delta producer. Each invocation of a callback function describes a piece of the delta --- a file's contents changing, something being renamed, etc. <hr><h2>Function Documentation</h2>
<a class="anchor" name="gb15253a8fcc50b7813844832016641a2"></a><!-- doxytag: member="svn_delta.h::svn_delta_default_editor" ref="gb15253a8fcc50b7813844832016641a2" args="(apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__delta__editor__t.html">svn_delta_editor_t</a>* svn_delta_default_editor           </td>
          <td>(</td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a default delta editor template, allocated in <em>pool</em>. 
<p>
The editor functions in the template do only the most basic baton-swapping: each editor function that produces a baton does so by copying its incoming baton into the outgoing baton reference.<p>
This editor is not intended to be useful by itself, but is meant to be the basis for a useful editor. After getting a default editor, you substitute in your own implementations for the editor functions you care about. The ones you don't care about, you don't have to implement -- you can rely on the template's implementation to safely do nothing of consequence. 
</div>
</div><p>
<a class="anchor" name="gbbbc5a169982cca58a3b87bc425d50c1"></a><!-- doxytag: member="svn_delta.h::svn_delta_depth_filter_editor" ref="gbbbc5a169982cca58a3b87bc425d50c1" args="(const svn_delta_editor_t **editor, void **edit_baton, const svn_delta_editor_t *wrapped_editor, void *wrapped_edit_baton, svn_depth_t requested_depth, svn_boolean_t has_target, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_delta_depth_filter_editor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsvn__delta__editor__t.html">svn_delta_editor_t</a> **&nbsp;</td>
          <td class="paramname"> <em>editor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>edit_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__delta__editor__t.html">svn_delta_editor_t</a> *&nbsp;</td>
          <td class="paramname"> <em>wrapped_editor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>wrapped_edit_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#21dd8b080111fa6fb5d59156299f3a2c">svn_depth_t</a>&nbsp;</td>
          <td class="paramname"> <em>requested_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>has_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*editor</em> and <em>*edit_baton</em> to an depth-based filtering editor that wraps <em>wrapped_editor</em> and <em>wrapped_baton</em>. 
<p>
The <em>editor</em> will track the depth of this drive against the <em>requested_depth</em>, taking into account whether not the edit drive is making use of a target (via <em>has_target</em>), and forward editor calls which operate "within" the request depth range through to <em>wrapped_editor</em>.<p>
<em>requested_depth</em> must be one of the following depth values: <code>svn_depth_infinity</code>, <code>svn_depth_empty</code>, <code>svn_depth_files</code>, <code>svn_depth_immediates</code>, or <code>svn_depth_unknown</code>.<p>
If filtering is deemed unncessary (or if <em>requested_depth</em> is <code>svn_depth_unknown</code>), <em>*editor</em> and <em>*edit_baton</em> will be set to <em>wrapped_editor</em> and <em>wrapped_baton</em>, respectively; otherwise, they'll be set to new objects allocated from <em>pool</em>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Because the <a class="el" href="structsvn__delta__editor__t.html" title="A structure full of callback functions the delta source will invoke as it produces...">svn_delta_editor_t</a> interface's <code>delete_entry()</code> function doesn't carry node kind information, a depth-based filtering editor being asked to filter for <code>svn_depth_files</code> but receiving a <code>delete_entry()</code> call on an immediate child of the editor's target is unable to know if that deletion should be allowed or filtered out -- a delete of a top-level file is okay in this case, a delete of a top-level subdirectory is not. As such, this filtering editor takes a conservative approach, and ignores top-level deletion requests when filtering for <code>svn_depth_files</code>. Fortunately, most non-depth-aware (pre-1.5) Subversion editor drivers can be told to drive non-recursively (where non-recursive means essentially <code>svn_depth_files</code>), which means they won't transmit out-of-scope editor commands anyway.</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8f1c0290d6cea00bb1919e8a23087650"></a><!-- doxytag: member="svn_delta.h::svn_delta_get_cancellation_editor" ref="g8f1c0290d6cea00bb1919e8a23087650" args="(svn_cancel_func_t cancel_func, void *cancel_baton, const svn_delta_editor_t *wrapped_editor, void *wrapped_baton, const svn_delta_editor_t **editor, void **edit_baton, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_delta_get_cancellation_editor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#ddaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a>&nbsp;</td>
          <td class="paramname"> <em>cancel_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cancel_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__delta__editor__t.html">svn_delta_editor_t</a> *&nbsp;</td>
          <td class="paramname"> <em>wrapped_editor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>wrapped_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__delta__editor__t.html">svn_delta_editor_t</a> **&nbsp;</td>
          <td class="paramname"> <em>editor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>edit_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*editor</em> and <em>*edit_baton</em> to a cancellation editor that wraps <em>wrapped_editor</em> and <em>wrapped_baton</em>. 
<p>
The <em>editor</em> will call <em>cancel_func</em> with <em>cancel_baton</em> when each of its functions is called, continuing on to call the corresponding wrapped function if <em>cancel_func</em> returns <code>SVN_NO_ERROR</code>.<p>
If <em>cancel_func</em> is <code>NULL</code>, set <em>*editor</em> to <em>wrapped_editor</em> and <em>*edit_baton</em> to <em>wrapped_baton</em>. 
</div>
</div><p>
<a class="anchor" name="g277d961312294cd385710ee4d32d7f3d"></a><!-- doxytag: member="svn_delta.h::svn_delta_noop_window_handler" ref="g277d961312294cd385710ee4d32d7f3d" args="(svn_txdelta_window_t *window, void *baton)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_delta_noop_window_handler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__txdelta__window__t.html">svn_txdelta_window_t</a> *&nbsp;</td>
          <td class="paramname"> <em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>baton</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A text-delta window handler which does nothing. 
<p>
Editors can return this handler from <code>apply_textdelta</code> if they don't care about text delta windows. 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 24 16:18:29 2008 for Subversion by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
