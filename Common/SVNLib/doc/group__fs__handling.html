<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Subversion: Filesystem interaction subsystem</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Filesystem interaction subsystem</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__bdb.html">Berkeley DB filesystems</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subversion filesystems based on Berkeley DB. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__access__ctx.html">Filesystem access contexts</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Filesystem Access Contexts. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__nodes.html">Filesystem nodes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Filesystem Nodes. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__txns.html">Filesystem transactions</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Filesystem Transactions. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__roots.html">Filesystem roots</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Roots. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__directories.html">Filesystem directories</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Directory entry names and directory paths. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__fs__locks.html">Filesystem locks</a></td></tr>

<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__fs__dirent__t.html">svn_fs_dirent_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of a Subversion directory entry.  <a href="structsvn__fs__dirent__t.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An object representing a Subversion filesystem.  <a href="#g2419fff1bb2c1e523b00e276ed3862e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gfa2c790fffb1abbd103c954a5d983646">svn_fs_warning_callback_t</a> )(void *baton, <a class="el" href="structsvn__error__t.html">svn_error_t</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of a warning callback function.  <a href="#gfa2c790fffb1abbd103c954a5d983646"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <a class="el" href="group__fs__handling.html#ga31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An opaque node history object.  <a href="#ga31b679ed9ca7b53241ebda04c035140"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gf3bce1e26521c4432f14f3adfc617f17">svn_fs_initialize</a> (apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callers should invoke this function to initialize global state in the FS library before creating FS objects.  <a href="#gf3bce1e26521c4432f14f3adfc617f17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gbc881c866ebe2cbd41767374264532e8">svn_fs_set_warning_func</a> (<a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, <a class="el" href="group__fs__handling.html#gfa2c790fffb1abbd103c954a5d983646">svn_fs_warning_callback_t</a> warning, void *warning_baton)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provide a callback function, <em>warning</em>, that <em>fs</em> should use to report (non-fatal) errors.  <a href="#gbc881c866ebe2cbd41767374264532e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g24b9cee11c6d584ddb0b9d74efca5dd5">svn_fs_create</a> (<a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> **fs_p, const char *path, apr_hash_t *fs_config, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new, empty Subversion filesystem, stored in the directory <em>path</em>, and return a pointer to it in <em>*fs_p</em>.  <a href="#g24b9cee11c6d584ddb0b9d74efca5dd5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gf31aff19f6ddd70e665235ff1857fc35">svn_fs_open</a> (<a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> **fs_p, const char *path, apr_hash_t *fs_config, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a Subversion filesystem located in the directory <em>path</em>, and return a pointer to it in <em>*fs_p</em>.  <a href="#gf31aff19f6ddd70e665235ff1857fc35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g64cb2a37367de523f56b89e5ec603a73">svn_fs_upgrade</a> (const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Upgrade the Subversion filesystem located in the directory <em>path</em> to the latest version supported by this library.  <a href="#g64cb2a37367de523f56b89e5ec603a73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ge771342c2800751277423c552cfeee48">svn_fs_type</a> (const char **fs_type, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return, in <em>*fs_type</em>, a string identifying the back-end type of the Subversion filesystem located in <em>path</em>.  <a href="#ge771342c2800751277423c552cfeee48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ga1a79172a1faa38b234d365240079c3a">svn_fs_path</a> (<a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the path to <em>fs's</em> repository, allocated in <em>pool</em>.  <a href="#ga1a79172a1faa38b234d365240079c3a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g6d1642cd31bc5e860d521c8c80058058">svn_fs_delete_fs</a> (const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete the filesystem at <em>path</em>.  <a href="#g6d1642cd31bc5e860d521c8c80058058"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g2909d84e561fbfd8b0f321dbded129b6">svn_fs_hotcopy</a> (const char *src_path, const char *dest_path, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> clean, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a possibly live Subversion filesystem from <em>src_path</em> to <em>dest_path</em>.  <a href="#g2909d84e561fbfd8b0f321dbded129b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gf6f1f42958e3f56326185b91fc1ae679">svn_fs_recover</a> (const char *path, <a class="el" href="svn__types_8h.html#ddaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a> cancel_func, void *cancel_baton, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform any necessary non-catastrophic recovery on the Subversion filesystem located at <em>path</em>.  <a href="#gf6f1f42958e3f56326185b91fc1ae679"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g8795c6c2a696353b550c2f733787a015">svn_fs_check_path</a> (<a class="el" href="svn__types_8h.html#c3ca125707a8ca1289c73236b5ce7f9a">svn_node_kind_t</a> *kind_p, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*kind_p</em> to the type of node present at <em>path</em> under <em>root</em>.  <a href="#g8795c6c2a696353b550c2f733787a015"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g2412ddc868b0ef6cdbbe3b682827885e">svn_fs_node_history</a> (<a class="el" href="group__fs__handling.html#ga31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> **history_p, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*history_p</em> to an opaque node history object which represents <em>path</em> under <em>root</em>.  <a href="#g2412ddc868b0ef6cdbbe3b682827885e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g58dd5d7dc74bef946a4dc1129c342038">svn_fs_history_prev</a> (<a class="el" href="group__fs__handling.html#ga31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> **prev_history_p, <a class="el" href="group__fs__handling.html#ga31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> *history, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> cross_copies, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*prev_history_p</em> to an opaque node history object which represents the previous (or "next oldest") interesting history location for the filesystem node represented by <em>history</em>, or <code>NULL</code> if no such previous history exists.  <a href="#g58dd5d7dc74bef946a4dc1129c342038"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g266d0597466eb198dc4b593fcd44490e">svn_fs_history_location</a> (const char **path, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *revision, <a class="el" href="group__fs__handling.html#ga31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> *history, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*path</em> and <em>*revision</em> to the path and revision, respectively, of the <em>history</em> object.  <a href="#g266d0597466eb198dc4b593fcd44490e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g1a5ecfab7f53876e9ad6def4265df7e6">svn_fs_is_dir</a> (<a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *is_dir, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*is_dir</em> to <code>TRUE</code> iff <em>path</em> in <em>root</em> is a directory.  <a href="#g1a5ecfab7f53876e9ad6def4265df7e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g84b9e2f502354e16162edd12e8f5cc5b">svn_fs_is_file</a> (<a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *is_file, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*is_file</em> to <code>TRUE</code> iff <em>path</em> in <em>root</em> is a file.  <a href="#g84b9e2f502354e16162edd12e8f5cc5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gf59a66cf510e6da06dadfe2b3bb372e1">svn_fs_node_id</a> (const <a class="el" href="group__svn__fs__nodes.html#geca8f1c373c50ca7bb08e3417242b106">svn_fs_id_t</a> **id_p, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the id of a node.  <a href="#gf59a66cf510e6da06dadfe2b3bb372e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gd3be25cd08e898319e14cce69580992e">svn_fs_node_created_rev</a> (<a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *revision, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*revision</em> to the revision in which <em>path</em> under <em>root</em> was created.  <a href="#gd3be25cd08e898319e14cce69580992e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gf26ebca946019f3761f48ad8dadd6eaa">svn_fs_node_origin_rev</a> (<a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *revision, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*revision</em> to the revision in which the line of history represented by <em>path</em> under <em>root</em> originated.  <a href="#gf26ebca946019f3761f48ad8dadd6eaa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gf25b3de3d8930d857cf6c94777ce9bca">svn_fs_node_created_path</a> (const char **created_path, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*created_path</em> to the path at which <em>path</em> under <em>root</em> was created.  <a href="#gf25b3de3d8930d857cf6c94777ce9bca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g830b554597da876e1b6256f2836cf349">svn_fs_node_prop</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **value_p, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, const char *propname, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*value_p</em> to the value of the property named <em>propname</em> of <em>path</em> in <em>root</em>.  <a href="#g830b554597da876e1b6256f2836cf349"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g079534da68d59ac24307ae171189dd61">svn_fs_node_proplist</a> (apr_hash_t **table_p, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*table_p</em> to the entire property list of <em>path</em> in <em>root</em>, as an APR hash table allocated in <em>pool</em>.  <a href="#g079534da68d59ac24307ae171189dd61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g75ce7073e254911b82f9acc4825d4247">svn_fs_change_node_prop</a> (<a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, const char *name, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change a node's property's value, or add/delete a property.  <a href="#g75ce7073e254911b82f9acc4825d4247"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gac7c1a6f4732d24a8ee387abb33e33dc">svn_fs_props_changed</a> (<a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *changed_p, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root1, const char *path1, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root2, const char *path2, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if the properties of two path/root combinations are different.  <a href="#gac7c1a6f4732d24a8ee387abb33e33dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#ged6116279287a80ec4f7de380a732f45">svn_fs_copied_from</a> (<a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *rev_p, const char **path_p, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discover a node's copy ancestry, if any.  <a href="#ged6116279287a80ec4f7de380a732f45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g9d7839028ca775d36c6fdc851973f9ac">svn_fs_closest_copy</a> (<a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> **root_p, const char **path_p, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*root_p</em> and <em>*path_p</em> to the revision root and path of the destination of the most recent copy event that caused <em>path</em> to exist where it does in <em>root</em>, or to NULL if no such copy exists.  <a href="#g9d7839028ca775d36c6fdc851973f9ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g2976ec837ee7caa7771e61ed266933b5">svn_fs_get_mergeinfo</a> (svn_mergeinfo_catalog_t *catalog, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const apr_array_header_t *paths, <a class="el" href="svn__mergeinfo_8h.html#cd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a> inherit, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> include_descendants, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve mergeinfo for multiple nodes.  <a href="#g2976ec837ee7caa7771e61ed266933b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gfc5df16564312635dc97077a29e73d8e">svn_fs_merge</a> (const char **conflict_p, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *source_root, const char *source_path, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *target_root, const char *target_path, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *ancestor_root, const char *ancestor_path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merge changes between two nodes into a third node.  <a href="#gfc5df16564312635dc97077a29e73d8e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gd254aea2a12fbd7c8c62c8aaa3c4624c">svn_fs_dir_entries</a> (apr_hash_t **entries_p, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*entries_p</em> to a newly allocated APR hash table containing the entries of the directory at <em>path</em> in <em>root</em>.  <a href="#gd254aea2a12fbd7c8c62c8aaa3c4624c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g8484e37e57a52bb38e5067c38bf41e16">svn_fs_make_dir</a> (<a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new directory named <em>path</em> in <em>root</em>.  <a href="#g8484e37e57a52bb38e5067c38bf41e16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g528e3cf9010e463b511584f4143b6a72">svn_fs_delete</a> (<a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete the node named <em>path</em> in <em>root</em>.  <a href="#g528e3cf9010e463b511584f4143b6a72"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g9da8e22bd1058f877a275099699bb86b">svn_fs_copy</a> (<a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *from_root, const char *from_path, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *to_root, const char *to_path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a copy of <em>from_path</em> in <em>from_root</em> named <em>to_path</em> in <em>to_root</em>.  <a href="#g9da8e22bd1058f877a275099699bb86b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gddd7ec5b6e3306c609e46d4f5a2b8a5c">svn_fs_revision_link</a> (<a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *from_root, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *to_root, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="group__fs__handling.html#g9da8e22bd1058f877a275099699bb86b" title="Create a copy of from_path in from_root named to_path in to_root.">svn_fs_copy()</a>, but doesn't record copy history, and preserves the PATH.  <a href="#gddd7ec5b6e3306c609e46d4f5a2b8a5c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gbd675ec4bc28c7f4e72a121feeb60059">svn_fs_file_length</a> (<a class="el" href="svn__types_8h.html#726e581898461c1d3e7dbdb16d99dad0">svn_filesize_t</a> *length_p, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*length_p</em> to the length of the file <em>path</em> in <em>root</em>, in bytes.  <a href="#gbd675ec4bc28c7f4e72a121feeb60059"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g9dfe5ed9f63bb8b222d2adb2b96f0220">svn_fs_file_md5_checksum</a> (unsigned char digest[], <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put the MD5 checksum of file <em>path</em> into <em>digest</em>, which points to <code>APR_MD5_DIGESTSIZE</code> bytes of storage.  <a href="#g9dfe5ed9f63bb8b222d2adb2b96f0220"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gfe8eadb1c6950e3bfdca49bbb497d6fb">svn_fs_file_contents</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **contents, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*contents</em> to a readable generic stream that will yield the contents of the file <em>path</em> in <em>root</em>.  <a href="#gfe8eadb1c6950e3bfdca49bbb497d6fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gc760753f1ae74fc19991d5dab7cb643c">svn_fs_make_file</a> (<a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new file named <em>path</em> in <em>root</em>.  <a href="#gc760753f1ae74fc19991d5dab7cb643c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g8ae7391b579009b76e238fe9ef5b8053">svn_fs_apply_textdelta</a> (<a class="el" href="group__svn__delta__txt__delta.html#g1c0d461a3f244928d7f0339c1cbe3219">svn_txdelta_window_handler_t</a> *contents_p, void **contents_baton_p, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, const char *base_checksum, const char *result_checksum, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply a text delta to the file <em>path</em> in <em>root</em>.  <a href="#g8ae7391b579009b76e238fe9ef5b8053"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g61f5a039a4ad8818de163578b9c054f7">svn_fs_apply_text</a> (<a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **contents_p, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root, const char *path, const char *result_checksum, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write data directly to the file <em>path</em> in <em>root</em>.  <a href="#g61f5a039a4ad8818de163578b9c054f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gede66ee7850d389bcdeb5ddef1540fdc">svn_fs_contents_changed</a> (<a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *changed_p, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root1, const char *path1, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *root2, const char *path2, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the contents of two root/path combos have changed.  <a href="#gede66ee7850d389bcdeb5ddef1540fdc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g4af11f84095941c21fad6e22f62dd31d">svn_fs_youngest_rev</a> (<a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *youngest_p, <a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*youngest_p</em> to the number of the youngest revision in filesystem <em>fs</em>.  <a href="#g4af11f84095941c21fad6e22f62dd31d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g3f29dd4915629fc66ea1af713b659ce5">svn_fs_deltify_revision</a> (<a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> revision, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deltify predecessors of paths modified in <em>revision</em> in filesystem <em>fs</em>.  <a href="#g3f29dd4915629fc66ea1af713b659ce5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g0cd6959ee54cd16768477d608fd33c34">svn_fs_revision_prop</a> (<a class="el" href="structsvn__string__t.html">svn_string_t</a> **value_p, <a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> rev, const char *propname, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*value_p</em> to the value of the property named <em>propname</em> on revision <em>rev</em> in the filesystem <em>fs</em>.  <a href="#g0cd6959ee54cd16768477d608fd33c34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g423da8c30eacc9787ec7bc3dd1b9e351">svn_fs_revision_proplist</a> (apr_hash_t **table_p, <a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> rev, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*table_p</em> to the entire property list of revision <em>rev</em> in filesystem <em>fs</em>, as an APR hash table allocated in <em>pool</em>.  <a href="#g423da8c30eacc9787ec7bc3dd1b9e351"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gb368d97a4f5093e8c71f8082f4664937">svn_fs_change_rev_prop</a> (<a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, <a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> rev, const char *name, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change a revision's property's value, or add/delete a property.  <a href="#gb368d97a4f5093e8c71f8082f4664937"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gd2d4b1fa18c0bbda6719d4414b52f4c2">svn_fs_get_file_delta_stream</a> (<a class="el" href="group__svn__delta__txt__delta.html#gf599af000e3c3b976c17fd4e101ff7cf">svn_txdelta_stream_t</a> **stream_p, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *source_root, const char *source_path, <a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *target_root, const char *target_path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <em>*stream_p</em> to a pointer to a delta stream that will turn the contents of the file <em>source</em> into the contents of the file <em>target</em>.  <a href="#gd2d4b1fa18c0bbda6719d4414b52f4c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g2ce6bd7610fc7201f4ea6b4e20e49e67">svn_fs_get_uuid</a> (<a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, const char **uuid, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Populate <em>*uuid</em> with the UUID associated with <em>fs</em>.  <a href="#g2ce6bd7610fc7201f4ea6b4e20e49e67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#gbec2453f61fb9356db9526d4c56f3a62">svn_fs_set_uuid</a> (<a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *fs, const char *uuid, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If not <code>NULL</code>, associate <em>*uuid</em> with <em>fs</em>.  <a href="#gbec2453f61fb9356db9526d4c56f3a62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__handling.html#g26cf98c986a0f71fe9d86be0f73266b6">svn_fs_print_modules</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *output, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a textual list of all available FS modules to the stringbuf <em>output</em>.  <a href="#g26cf98c986a0f71fe9d86be0f73266b6"></a><br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="ga31b679ed9ca7b53241ebda04c035140"></a><!-- doxytag: member="svn_fs.h::svn_fs_history_t" ref="ga31b679ed9ca7b53241ebda04c035140" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__fs__handling.html#ga31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> <a class="el" href="group__fs__handling.html#ga31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An opaque node history object. 
<p>

<p>Definition at line <a class="el" href="svn__fs_8h-source.html#l01037">1037</a> of file <a class="el" href="svn__fs_8h-source.html">svn_fs.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="g2419fff1bb2c1e523b00e276ed3862e3"></a><!-- doxytag: member="svn_fs.h::svn_fs_t" ref="g2419fff1bb2c1e523b00e276ed3862e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> <a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An object representing a Subversion filesystem. 
<p>

<p>Definition at line <a class="el" href="svn__fs_8h-source.html#l00057">57</a> of file <a class="el" href="svn__fs_8h-source.html">svn_fs.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="gfa2c790fffb1abbd103c954a5d983646"></a><!-- doxytag: member="svn_fs.h::svn_fs_warning_callback_t" ref="gfa2c790fffb1abbd103c954a5d983646" args=")(void *baton, svn_error_t *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="group__fs__handling.html#gfa2c790fffb1abbd103c954a5d983646">svn_fs_warning_callback_t</a>)(void *baton, <a class="el" href="structsvn__error__t.html">svn_error_t</a> *err)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type of a warning callback function. 
<p>
<em>baton</em> is the value specified in the call to <a class="el" href="group__fs__handling.html#gbc881c866ebe2cbd41767374264532e8" title="Provide a callback function, warning, that fs should use to report (non-fatal) errors...">svn_fs_set_warning_func()</a>; the filesystem passes it through to the callback. <em>err</em> contains the warning message.<p>
The callback function should not clear the error that is passed to it; its caller should do that. 
<p>Definition at line <a class="el" href="svn__fs_8h-source.html#l00123">123</a> of file <a class="el" href="svn__fs_8h-source.html">svn_fs.h</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g61f5a039a4ad8818de163578b9c054f7"></a><!-- doxytag: member="svn_fs.h::svn_fs_apply_text" ref="g61f5a039a4ad8818de163578b9c054f7" args="(svn_stream_t **contents_p, svn_fs_root_t *root, const char *path, const char *result_checksum, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_apply_text           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&nbsp;</td>
          <td class="paramname"> <em>contents_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>result_checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write data directly to the file <em>path</em> in <em>root</em>. 
<p>
<em>root</em> must be the root of a transaction, not a revision.<p>
Set <em>*contents_p</em> to a stream ready to receive full textual data. When the caller closes this stream, the data replaces the previous contents of the file. The caller must write all file data and close the stream before making further changes to the transaction.<p>
If <em>path</em> does not exist in <em>root</em>, return an error. (You cannot use this routine to create new files; use <a class="el" href="group__fs__handling.html#gc760753f1ae74fc19991d5dab7cb643c" title="Create a new file named path in root.">svn_fs_make_file()</a> to create an empty file first.)<p>
<em>result_checksum</em> is the hex MD5 digest for the final fulltext written to the stream. It is ignored if NULL, but if not null, it must match the checksum of the result; if it does not, then the <em>*contents_p</em> call which detects the mismatch will return the error <code>SVN_ERR_CHECKSUM_MISMATCH</code>.<p>
Do any necessary temporary allocation in <em>pool</em>.<p>
### This is like <a class="el" href="group__fs__handling.html#g8ae7391b579009b76e238fe9ef5b8053" title="Apply a text delta to the file path in root.">svn_fs_apply_textdelta()</a>, but takes the text straight. It is currently used only by the loader, see libsvn_repos/load.c. It should accept a checksum, of course, which would come from an (optional) header in the dump file. See <a href="http://subversion.tigris.org/issues/show_bug.cgi?id=1102">http://subversion.tigris.org/issues/show_bug.cgi?id=1102</a> for more. 
</div>
</div><p>
<a class="anchor" name="g8ae7391b579009b76e238fe9ef5b8053"></a><!-- doxytag: member="svn_fs.h::svn_fs_apply_textdelta" ref="g8ae7391b579009b76e238fe9ef5b8053" args="(svn_txdelta_window_handler_t *contents_p, void **contents_baton_p, svn_fs_root_t *root, const char *path, const char *base_checksum, const char *result_checksum, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_apply_textdelta           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__delta__txt__delta.html#g1c0d461a3f244928d7f0339c1cbe3219">svn_txdelta_window_handler_t</a> *&nbsp;</td>
          <td class="paramname"> <em>contents_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>contents_baton_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>base_checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>result_checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply a text delta to the file <em>path</em> in <em>root</em>. 
<p>
<em>root</em> must be the root of a transaction, not a revision.<p>
Set <em>*contents_p</em> to a function ready to receive text delta windows describing how to change the file's contents, relative to its current contents. Set <em>*contents_baton_p</em> to a baton to pass to <em>*contents_p</em>.<p>
If <em>path</em> does not exist in <em>root</em>, return an error. (You cannot use this routine to create new files; use <a class="el" href="group__fs__handling.html#gc760753f1ae74fc19991d5dab7cb643c" title="Create a new file named path in root.">svn_fs_make_file()</a> to create an empty file first.)<p>
<em>base_checksum</em> is the hex MD5 digest for the base text against which the delta is to be applied; it is ignored if NULL, and may be ignored even if not NULL. If it is not ignored, it must match the checksum of the base text against which svndiff data is being applied; if not, <a class="el" href="group__fs__handling.html#g8ae7391b579009b76e238fe9ef5b8053" title="Apply a text delta to the file path in root.">svn_fs_apply_textdelta()</a> or the <em>*contents_p</em> call which detects the mismatch will return the error <code>SVN_ERR_CHECKSUM_MISMATCH</code> (if there is no base text, there may still be an error if <em>base_checksum</em> is neither NULL nor the checksum of the empty string).<p>
<em>result_checksum</em> is the hex MD5 digest for the fulltext that results from this delta application. It is ignored if NULL, but if not NULL, it must match the checksum of the result; if it does not, then the <em>*contents_p</em> call which detects the mismatch will return the error <code>SVN_ERR_CHECKSUM_MISMATCH</code>.<p>
The caller must send all delta windows including the terminating NULL window to <em>*contents_p</em> before making further changes to the transaction.<p>
Do temporary allocation in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="g75ce7073e254911b82f9acc4825d4247"></a><!-- doxytag: member="svn_fs.h::svn_fs_change_node_prop" ref="g75ce7073e254911b82f9acc4825d4247" args="(svn_fs_root_t *root, const char *path, const char *name, const svn_string_t *value, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_change_node_prop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change a node's property's value, or add/delete a property. 
<p>
<ul>
<li><em>root</em> and <em>path</em> indicate the node whose property should change. <em>root</em> must be the root of a transaction, not the root of a revision.</li><li><em>name</em> is the name of the property to change.</li><li><em>value</em> is the new value of the property, or zero if the property should be removed altogether. Do any necessary temporary allocation in <em>pool</em>. </li></ul>

</div>
</div><p>
<a class="anchor" name="gb368d97a4f5093e8c71f8082f4664937"></a><!-- doxytag: member="svn_fs.h::svn_fs_change_rev_prop" ref="gb368d97a4f5093e8c71f8082f4664937" args="(svn_fs_t *fs, svn_revnum_t rev, const char *name, const svn_string_t *value, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_change_rev_prop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&nbsp;</td>
          <td class="paramname"> <em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change a revision's property's value, or add/delete a property. 
<p>
<ul>
<li><em>fs</em> is a filesystem, and <em>rev</em> is the revision in that filesystem whose property should change.</li><li><em>name</em> is the name of the property to change.</li><li><em>value</em> is the new value of the property, or zero if the property should be removed altogether.</li></ul>
<p>
Note that revision properties are non-historied --- you can change them after the revision has been committed. They are not protected via transactions.<p>
Do any necessary temporary allocation in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="g8795c6c2a696353b550c2f733787a015"></a><!-- doxytag: member="svn_fs.h::svn_fs_check_path" ref="g8795c6c2a696353b550c2f733787a015" args="(svn_node_kind_t *kind_p, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_check_path           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#c3ca125707a8ca1289c73236b5ce7f9a">svn_node_kind_t</a> *&nbsp;</td>
          <td class="paramname"> <em>kind_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*kind_p</em> to the type of node present at <em>path</em> under <em>root</em>. 
<p>
If <em>path</em> does not exist under <em>root</em>, set <em>*kind_p</em> to <code>svn_node_none</code>. Use <em>pool</em> for temporary allocation. 
</div>
</div><p>
<a class="anchor" name="g9d7839028ca775d36c6fdc851973f9ac"></a><!-- doxytag: member="svn_fs.h::svn_fs_closest_copy" ref="g9d7839028ca775d36c6fdc851973f9ac" args="(svn_fs_root_t **root_p, const char **path_p, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_closest_copy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> **&nbsp;</td>
          <td class="paramname"> <em>root_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>path_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*root_p</em> and <em>*path_p</em> to the revision root and path of the destination of the most recent copy event that caused <em>path</em> to exist where it does in <em>root</em>, or to NULL if no such copy exists. 
<p>
When non-NULL, allocate <em>*root_p</em> and <em>*path_p</em> in <em>pool</em>.<p>
<em>*path_p</em> might be a parent of <em>path</em>, rather than <em>path</em> itself. However, it will always be the deepest relevant path. That is, if a copy occurs underneath another copy in the same txn, this function makes sure to set <em>*path_p</em> to the longest copy destination path that is still a parent of or equal to <em>path</em>.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gede66ee7850d389bcdeb5ddef1540fdc"></a><!-- doxytag: member="svn_fs.h::svn_fs_contents_changed" ref="gede66ee7850d389bcdeb5ddef1540fdc" args="(svn_boolean_t *changed_p, svn_fs_root_t *root1, const char *path1, svn_fs_root_t *root2, const char *path2, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_contents_changed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&nbsp;</td>
          <td class="paramname"> <em>changed_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the contents of two root/path combos have changed. 
<p>
Set <em>*changed_p</em> to 1 if the contents at <em>path1</em> under <em>root1</em> differ from those at <em>path2</em> under <em>root2</em>, or set it to 0 if they are the same. Both paths must exist under their respective roots, and both roots must be in the same filesystem. 
</div>
</div><p>
<a class="anchor" name="ged6116279287a80ec4f7de380a732f45"></a><!-- doxytag: member="svn_fs.h::svn_fs_copied_from" ref="ged6116279287a80ec4f7de380a732f45" args="(svn_revnum_t *rev_p, const char **path_p, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_copied_from           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rev_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>path_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Discover a node's copy ancestry, if any. 
<p>
If the node at <em>path</em> in <em>root</em> was copied from some other node, set <em>*rev_p</em> and <em>*path_p</em> to the revision and path of the other node, allocating <em>*path_p</em> in <em>pool</em>.<p>
Else if there is no copy ancestry for the node, set <em>*rev_p</em> to <code>SVN_INVALID_REVNUM</code> and <em>*path_p</em> to NULL.<p>
If an error is returned, the values of <em>*rev_p</em> and <em>*path_p</em> are undefined, but otherwise, if one of them is set as described above, you may assume the other is set correspondingly.<p>
<em>root</em> may be a revision root or a transaction root.<p>
Notes:<ul>
<li>Copy ancestry does not descend. After copying directory D to E, E will have copy ancestry referring to D, but E's children may not. See also <a class="el" href="group__fs__handling.html#g9da8e22bd1058f877a275099699bb86b" title="Create a copy of from_path in from_root named to_path in to_root.">svn_fs_copy()</a>.</li></ul>
<p>
<ul>
<li>Copy ancestry *under* a copy is preserved. That is, if you copy /A/D/G/pi to /A/D/G/pi2, and then copy /A/D/G to /G, then /G/pi2 will still have copy ancestry pointing to /A/D/G/pi. We don't know if this is a feature or a bug yet; if it turns out to be a bug, then the fix is to make <a class="el" href="group__fs__handling.html#ged6116279287a80ec4f7de380a732f45" title="Discover a node&#39;s copy ancestry, if any.">svn_fs_copied_from()</a> observe the following logic, which currently callers may choose to follow themselves: if node X has copy history, but its ancestor A also has copy history, then you may ignore X's history if X's revision-of-origin is earlier than A's -- because that would mean that X's copy history was preserved in a copy-under-a-copy scenario. If X's revision-of-origin is the same as A's, then it was copied under A during the same transaction that created A. (X's revision-of-origin cannot be greater than A's, if X has copy history.) <dl compact><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>See how people like this, it can always be hidden behind the curtain if necessary.</dd></dl>
</li><li>Copy ancestry is not stored as a regular subversion property because it is not inherited. Copying foo to bar results in a revision of bar with copy ancestry; but committing a text change to bar right after that results in a new revision of bar without copy ancestry. </li></ul>

</div>
</div><p>
<a class="anchor" name="g9da8e22bd1058f877a275099699bb86b"></a><!-- doxytag: member="svn_fs.h::svn_fs_copy" ref="g9da8e22bd1058f877a275099699bb86b" args="(svn_fs_root_t *from_root, const char *from_path, svn_fs_root_t *to_root, const char *to_path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_copy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>from_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>from_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>to_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>to_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a copy of <em>from_path</em> in <em>from_root</em> named <em>to_path</em> in <em>to_root</em>. 
<p>
If <em>from_path</em> in <em>from_root</em> is a directory, copy the tree it refers to recursively.<p>
The copy will remember its source; use <a class="el" href="group__fs__handling.html#ged6116279287a80ec4f7de380a732f45" title="Discover a node&#39;s copy ancestry, if any.">svn_fs_copied_from()</a> to access this information.<p>
<em>to_root</em> must be the root of a transaction; <em>from_root</em> must be the root of a revision. (Requiring <em>from_root</em> to be the root of a revision makes the implementation trivial: there is no detectable difference (modulo node revision ID's) between copying <em>from</em> and simply adding a reference to it. So the operation takes place in constant time. However, there's no reason not to extend this to mutable nodes --- it's just more code.) Further, <em>to_root</em> and <em>from_root</em> must represent the same filesystem.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>To do a copy without preserving copy history, use <a class="el" href="group__fs__handling.html#gddd7ec5b6e3306c609e46d4f5a2b8a5c" title="Like svn_fs_copy(), but doesn&#39;t record copy history, and preserves the PATH.">svn_fs_revision_link()</a>.</dd></dl>
Do any necessary temporary allocation in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="g24b9cee11c6d584ddb0b9d74efca5dd5"></a><!-- doxytag: member="svn_fs.h::svn_fs_create" ref="g24b9cee11c6d584ddb0b9d74efca5dd5" args="(svn_fs_t **fs_p, const char *path, apr_hash_t *fs_config, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_create           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> **&nbsp;</td>
          <td class="paramname"> <em>fs_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&nbsp;</td>
          <td class="paramname"> <em>fs_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new, empty Subversion filesystem, stored in the directory <em>path</em>, and return a pointer to it in <em>*fs_p</em>. 
<p>
<em>path</em> must not currently exist, but its parent must exist. If <em>fs_config</em> is not <code>NULL</code>, the options it contains modify the behavior of the filesystem. The interpretation of <em>fs_config</em> is specific to the filesystem back-end. The new filesystem may be closed by destroying <em>pool</em>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The lifetime of <em>fs_config</em> must not be shorter than <em>pool's</em>. It's a good idea to allocate <em>fs_config</em> from <em>pool</em> or one of its ancestors.</dd></dl>
If <em>fs_config</em> contains a value for <code>SVN_FS_CONFIG_FS_TYPE</code>, that value determines the filesystem type for the new filesystem. Currently defined values are:<p>
SVN_FS_TYPE_BDB Berkeley-DB implementation SVN_FS_TYPE_FSFS Native-filesystem implementation<p>
If <em>fs_config</em> is <code>NULL</code> or does not contain a value for <code>SVN_FS_CONFIG_FS_TYPE</code> then the default filesystem type will be used. This will typically be BDB for version 1.1 and FSFS for later versions, though the caller should not rely upon any particular default if they wish to ensure that a filesystem of a specific type is created.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g528e3cf9010e463b511584f4143b6a72"></a><!-- doxytag: member="svn_fs.h::svn_fs_delete" ref="g528e3cf9010e463b511584f4143b6a72" args="(svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_delete           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete the node named <em>path</em> in <em>root</em>. 
<p>
If the node being deleted is a directory, its contents will be deleted recursively. <em>root</em> must be the root of a transaction, not of a revision. Use <em>pool</em> for temporary allocation.<p>
This function may be more efficient than making the equivalent series of calls to <a class="el" href="group__fs__handling.html#g528e3cf9010e463b511584f4143b6a72" title="Delete the node named path in root.">svn_fs_delete()</a>, because it takes advantage of the fact that, to delete an immutable subtree, shared with some committed revision, you need only remove the directory entry. The dumb algorithm would recurse into the subtree and end up cloning each non-empty directory it contains, only to delete it later.<p>
If return <code>SVN_ERR_FS_NO_SUCH_ENTRY</code>, then the basename of <em>path</em> is missing from its parent, that is, the final target of the deletion is missing.<p>
Attempting to remove the root dir also results in an error, <code>SVN_ERR_FS_ROOT_DIR</code>, even if the dir is empty. 
</div>
</div><p>
<a class="anchor" name="g6d1642cd31bc5e860d521c8c80058058"></a><!-- doxytag: member="svn_fs.h::svn_fs_delete_fs" ref="g6d1642cd31bc5e860d521c8c80058058" args="(const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_delete_fs           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete the filesystem at <em>path</em>. 
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3f29dd4915629fc66ea1af713b659ce5"></a><!-- doxytag: member="svn_fs.h::svn_fs_deltify_revision" ref="g3f29dd4915629fc66ea1af713b659ce5" args="(svn_fs_t *fs, svn_revnum_t revision, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_deltify_revision           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&nbsp;</td>
          <td class="paramname"> <em>revision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deltify predecessors of paths modified in <em>revision</em> in filesystem <em>fs</em>. 
<p>
Use <em>pool</em> for all allocations.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This can be a time-consuming process, depending the breadth of the changes made in <em>revision</em>, and the depth of the history of those changed paths. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd254aea2a12fbd7c8c62c8aaa3c4624c"></a><!-- doxytag: member="svn_fs.h::svn_fs_dir_entries" ref="gd254aea2a12fbd7c8c62c8aaa3c4624c" args="(apr_hash_t **entries_p, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_dir_entries           </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&nbsp;</td>
          <td class="paramname"> <em>entries_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*entries_p</em> to a newly allocated APR hash table containing the entries of the directory at <em>path</em> in <em>root</em>. 
<p>
The keys of the table are entry names, as byte strings, excluding the final NULL character; the table's values are pointers to <code><a class="el" href="structsvn__fs__dirent__t.html" title="The type of a Subversion directory entry.">svn_fs_dirent_t</a></code> structures. Allocate the table and its contents in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="gfe8eadb1c6950e3bfdca49bbb497d6fb"></a><!-- doxytag: member="svn_fs.h::svn_fs_file_contents" ref="gfe8eadb1c6950e3bfdca49bbb497d6fb" args="(svn_stream_t **contents, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_file_contents           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__io__byte__streams.html#g06d6291c397e63f895deb92a2c14e6af">svn_stream_t</a> **&nbsp;</td>
          <td class="paramname"> <em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*contents</em> to a readable generic stream that will yield the contents of the file <em>path</em> in <em>root</em>. 
<p>
Allocate the stream in <em>pool</em>. You can only use <em>*contents</em> for as long as the underlying filesystem is open. If <em>path</em> is not a file, return <code>SVN_ERR_FS_NOT_FILE</code>.<p>
If <em>root</em> is the root of a transaction, it is possible that the contents of the file <em>path</em> will change between calls to <a class="el" href="group__fs__handling.html#gfe8eadb1c6950e3bfdca49bbb497d6fb" title="Set *contents to a readable generic stream that will yield the contents of the file...">svn_fs_file_contents()</a>. In that case, the result of reading from <em>*contents</em> is undefined.<p>
### <dl compact><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>kff: I am worried about lifetime issues with this pool vs the trail created farther down the call stack. Trace this function to investigate... </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbd675ec4bc28c7f4e72a121feeb60059"></a><!-- doxytag: member="svn_fs.h::svn_fs_file_length" ref="gbd675ec4bc28c7f4e72a121feeb60059" args="(svn_filesize_t *length_p, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_file_length           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#726e581898461c1d3e7dbdb16d99dad0">svn_filesize_t</a> *&nbsp;</td>
          <td class="paramname"> <em>length_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*length_p</em> to the length of the file <em>path</em> in <em>root</em>, in bytes. 
<p>
Do any necessary temporary allocation in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="g9dfe5ed9f63bb8b222d2adb2b96f0220"></a><!-- doxytag: member="svn_fs.h::svn_fs_file_md5_checksum" ref="g9dfe5ed9f63bb8b222d2adb2b96f0220" args="(unsigned char digest[], svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_file_md5_checksum           </td>
          <td>(</td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>digest</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Put the MD5 checksum of file <em>path</em> into <em>digest</em>, which points to <code>APR_MD5_DIGESTSIZE</code> bytes of storage. 
<p>
Use <em>pool</em> only for temporary allocations.<p>
If the filesystem does not have a prerecorded checksum for <em>path</em>, do not calculate a checksum dynamically, just put all 0's into <em>digest</em>. (By convention, the all-zero checksum is considered to match any checksum.)<p>
Notes:<p>
You might wonder, why do we only provide this interface for file contents, and not for properties or directories?<p>
The answer is that property lists and directory entry lists are essentially data structures, not text. We serialize them for transmission, but there is no guarantee that the consumer will parse them into the same form, or even the same order, as the producer. It's difficult to find a checksumming method that reaches the same result given such variation in input. (I suppose we could calculate an independent MD5 sum for each propname and value, and XOR them together; same with directory entry names. Maybe that's the solution?) Anyway, for now we punt. The most important data, and the only data that goes through svndiff processing, is file contents, so that's what we provide checksumming for.<p>
Internally, of course, the filesystem checksums everything, because it has access to the lowest level storage forms: strings behind representations. 
</div>
</div><p>
<a class="anchor" name="gd2d4b1fa18c0bbda6719d4414b52f4c2"></a><!-- doxytag: member="svn_fs.h::svn_fs_get_file_delta_stream" ref="gd2d4b1fa18c0bbda6719d4414b52f4c2" args="(svn_txdelta_stream_t **stream_p, svn_fs_root_t *source_root, const char *source_path, svn_fs_root_t *target_root, const char *target_path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_get_file_delta_stream           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__delta__txt__delta.html#gf599af000e3c3b976c17fd4e101ff7cf">svn_txdelta_stream_t</a> **&nbsp;</td>
          <td class="paramname"> <em>stream_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>source_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>source_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>target_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>target_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*stream_p</em> to a pointer to a delta stream that will turn the contents of the file <em>source</em> into the contents of the file <em>target</em>. 
<p>
If <em>source_root</em> is zero, use a file with zero length as the source.<p>
This function does not compare the two files' properties.<p>
Allocate <em>*stream_p</em>, and do any necessary temporary allocation, in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="g2976ec837ee7caa7771e61ed266933b5"></a><!-- doxytag: member="svn_fs.h::svn_fs_get_mergeinfo" ref="g2976ec837ee7caa7771e61ed266933b5" args="(svn_mergeinfo_catalog_t *catalog, svn_fs_root_t *root, const apr_array_header_t *paths, svn_mergeinfo_inheritance_t inherit, svn_boolean_t include_descendants, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_get_mergeinfo           </td>
          <td>(</td>
          <td class="paramtype">svn_mergeinfo_catalog_t *&nbsp;</td>
          <td class="paramname"> <em>catalog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&nbsp;</td>
          <td class="paramname"> <em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__mergeinfo_8h.html#cd81e9d0f5bcc4eec4df7b8a140f435c">svn_mergeinfo_inheritance_t</a>&nbsp;</td>
          <td class="paramname"> <em>inherit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>include_descendants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve mergeinfo for multiple nodes. 
<p>
<em>*catalog</em> is a catalog for <em>paths</em>. It will never be <code>NULL</code>, but may be empty.<p>
<em>root</em> is revision root to use when looking up paths.<p>
<em>paths</em> are the paths you are requesting information for.<p>
<em>inherit</em> indicates whether to retrieve explicit, explicit-or-inherited, or only inherited mergeinfo.<p>
If <em>include_descendants</em> is TRUE, then additionally return the mergeinfo for any descendant of any element of <em>paths</em> which has the <code>SVN_PROP_MERGEINFO</code> property explicitly set on it. (Note that inheritance is only taken into account for the elements in <em>paths</em>; descendants of the elements in <em>paths</em> which get their mergeinfo via inheritance are not included in <em>*mergeoutput</em>.)<p>
Do any necessary temporary allocation in <em>pool</em>.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2ce6bd7610fc7201f4ea6b4e20e49e67"></a><!-- doxytag: member="svn_fs.h::svn_fs_get_uuid" ref="g2ce6bd7610fc7201f4ea6b4e20e49e67" args="(svn_fs_t *fs, const char **uuid, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_get_uuid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Populate <em>*uuid</em> with the UUID associated with <em>fs</em>. 
<p>
Allocate <em>*uuid</em> in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="g266d0597466eb198dc4b593fcd44490e"></a><!-- doxytag: member="svn_fs.h::svn_fs_history_location" ref="g266d0597466eb198dc4b593fcd44490e" args="(const char **path, svn_revnum_t *revision, svn_fs_history_t *history, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_history_location           </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *&nbsp;</td>
          <td class="paramname"> <em>revision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> *&nbsp;</td>
          <td class="paramname"> <em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*path</em> and <em>*revision</em> to the path and revision, respectively, of the <em>history</em> object. 
<p>
Use <em>pool</em> for all allocations. 
</div>
</div><p>
<a class="anchor" name="g58dd5d7dc74bef946a4dc1129c342038"></a><!-- doxytag: member="svn_fs.h::svn_fs_history_prev" ref="g58dd5d7dc74bef946a4dc1129c342038" args="(svn_fs_history_t **prev_history_p, svn_fs_history_t *history, svn_boolean_t cross_copies, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_history_prev           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> **&nbsp;</td>
          <td class="paramname"> <em>prev_history_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> *&nbsp;</td>
          <td class="paramname"> <em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>cross_copies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*prev_history_p</em> to an opaque node history object which represents the previous (or "next oldest") interesting history location for the filesystem node represented by <em>history</em>, or <code>NULL</code> if no such previous history exists. 
<p>
If <em>cross_copies</em> is <code>FALSE</code>, also return <code>NULL</code> if stepping backwards in history to <em>*prev_history_p</em> would cross a filesystem copy operation.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If this is the first call to <a class="el" href="group__fs__handling.html#g58dd5d7dc74bef946a4dc1129c342038" title="Set *prev_history_p to an opaque node history object which represents the previous...">svn_fs_history_prev()</a> for the <em>history</em> object, it could return a history object whose location is the same as the original. This will happen if the original location was an interesting one (where the node was modified, or took place in a copy event). This behavior allows looping callers to avoid the calling <a class="el" href="group__fs__handling.html#g266d0597466eb198dc4b593fcd44490e" title="Set *path and *revision to the path and revision, respectively, of the history object...">svn_fs_history_location()</a> on the object returned by <a class="el" href="group__fs__handling.html#g2412ddc868b0ef6cdbbe3b682827885e" title="Set *history_p to an opaque node history object which represents path under root...">svn_fs_node_history()</a>, and instead go ahead and begin calling <a class="el" href="group__fs__handling.html#g58dd5d7dc74bef946a4dc1129c342038" title="Set *prev_history_p to an opaque node history object which represents the previous...">svn_fs_history_prev()</a>.<p>
This function uses node-id ancestry alone to determine modifiedness, and therefore does NOT claim that in any of the returned revisions file contents changed, properties changed, directory entries lists changed, etc.<p>
The revisions returned for <em>path</em> will be older than or the same age as the revision of that path in <em>root</em>. That is, if <em>root</em> is a revision root based on revision X, and <em>path</em> was modified in some revision(s) younger than X, those revisions younger than X will not be included for <em>path</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2909d84e561fbfd8b0f321dbded129b6"></a><!-- doxytag: member="svn_fs.h::svn_fs_hotcopy" ref="g2909d84e561fbfd8b0f321dbded129b6" args="(const char *src_path, const char *dest_path, svn_boolean_t clean, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_hotcopy           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dest_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>clean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy a possibly live Subversion filesystem from <em>src_path</em> to <em>dest_path</em>. 
<p>
If <em>clean</em> is <code>TRUE</code>, perform cleanup on the source filesystem as part of the copy operation; currently, this means deleting copied, unused logfiles for a Berkeley DB source filesystem.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf3bce1e26521c4432f14f3adfc617f17"></a><!-- doxytag: member="svn_fs.h::svn_fs_initialize" ref="gf3bce1e26521c4432f14f3adfc617f17" args="(apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_initialize           </td>
          <td>(</td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callers should invoke this function to initialize global state in the FS library before creating FS objects. 
<p>
If this function is invoked, no FS objects may be created in another thread at the same time as this invocation, and the provided <em>pool</em> must last longer than any FS object created subsequently.<p>
If this function is not called, the FS library will make a best effort to bootstrap a mutex for protecting data common to FS objects; however, there is a small window of failure. Also, a small amount of data will be leaked if the Subversion FS library is dynamically unloaded, and using the bdb FS can potentially segfault or invoke other undefined behavior if this function is not called with an appropriate pool (such as the pool the module was loaded into) when loaded dynamically.<p>
If this function is called multiple times before the pool passed to the first call is destroyed or cleared, the later calls will have no effect.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.2. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1a5ecfab7f53876e9ad6def4265df7e6"></a><!-- doxytag: member="svn_fs.h::svn_fs_is_dir" ref="g1a5ecfab7f53876e9ad6def4265df7e6" args="(svn_boolean_t *is_dir, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_is_dir           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&nbsp;</td>
          <td class="paramname"> <em>is_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*is_dir</em> to <code>TRUE</code> iff <em>path</em> in <em>root</em> is a directory. 
<p>
Do any necessary temporary allocation in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="g84b9e2f502354e16162edd12e8f5cc5b"></a><!-- doxytag: member="svn_fs.h::svn_fs_is_file" ref="g84b9e2f502354e16162edd12e8f5cc5b" args="(svn_boolean_t *is_file, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_is_file           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&nbsp;</td>
          <td class="paramname"> <em>is_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*is_file</em> to <code>TRUE</code> iff <em>path</em> in <em>root</em> is a file. 
<p>
Do any necessary temporary allocation in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="g8484e37e57a52bb38e5067c38bf41e16"></a><!-- doxytag: member="svn_fs.h::svn_fs_make_dir" ref="g8484e37e57a52bb38e5067c38bf41e16" args="(svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_make_dir           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new directory named <em>path</em> in <em>root</em>. 
<p>
The new directory has no entries, and no properties. <em>root</em> must be the root of a transaction, not a revision.<p>
Do any necessary temporary allocation in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="gc760753f1ae74fc19991d5dab7cb643c"></a><!-- doxytag: member="svn_fs.h::svn_fs_make_file" ref="gc760753f1ae74fc19991d5dab7cb643c" args="(svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_make_file           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new file named <em>path</em> in <em>root</em>. 
<p>
The file's initial contents are the empty string, and it has no properties. <em>root</em> must be the root of a transaction, not a revision.<p>
Do any necessary temporary allocation in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="gfc5df16564312635dc97077a29e73d8e"></a><!-- doxytag: member="svn_fs.h::svn_fs_merge" ref="gfc5df16564312635dc97077a29e73d8e" args="(const char **conflict_p, svn_fs_root_t *source_root, const char *source_path, svn_fs_root_t *target_root, const char *target_path, svn_fs_root_t *ancestor_root, const char *ancestor_path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_merge           </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>conflict_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>source_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>source_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>target_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>target_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ancestor_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ancestor_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Merge changes between two nodes into a third node. 
<p>
Given nodes <em>source</em> and <em>target</em>, and a common ancestor <em>ancestor</em>, modify <em>target</em> to contain all the changes made between <em>ancestor</em> and <em>source</em>, as well as the changes made between <em>ancestor</em> and <em>target</em>. <em>target_root</em> must be the root of a transaction, not a revision.<p>
<em>source</em>, <em>target</em>, and <em>ancestor</em> are generally directories; this function recursively merges the directories' contents. If they are files, this function simply returns an error whenever <em>source</em>, <em>target</em>, and <em>ancestor</em> are all distinct node revisions.<p>
If there are differences between <em>ancestor</em> and <em>source</em> that conflict with changes between <em>ancestor</em> and <em>target</em>, this function returns an <code>SVN_ERR_FS_CONFLICT</code> error.<p>
If the merge is successful, <em>target</em> is left in the merged state, and the base root of <em>target's</em> txn is set to the root node of <em>source</em>. If an error is returned (whether for conflict or otherwise), <em>target</em> is left unaffected.<p>
If <em>conflict_p</em> is non-NULL, then: a conflict error sets <em>*conflict_p</em> to the name of the node in <em>target</em> which couldn't be merged, otherwise, success sets <em>*conflict_p</em> to NULL.<p>
Do any necessary temporary allocation in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="gf25b3de3d8930d857cf6c94777ce9bca"></a><!-- doxytag: member="svn_fs.h::svn_fs_node_created_path" ref="gf25b3de3d8930d857cf6c94777ce9bca" args="(const char **created_path, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_created_path           </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>created_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*created_path</em> to the path at which <em>path</em> under <em>root</em> was created. 
<p>
Use <em>pool</em> for all allocations. Callers may use this function in conjunction with <a class="el" href="group__fs__handling.html#gd3be25cd08e898319e14cce69580992e" title="Set *revision to the revision in which path under root was created.">svn_fs_node_created_rev()</a> to perform a reverse lookup of the mapping of (path, revision) -&gt; node-id that <a class="el" href="group__fs__handling.html#gf59a66cf510e6da06dadfe2b3bb372e1" title="Get the id of a node.">svn_fs_node_id()</a> performs. 
</div>
</div><p>
<a class="anchor" name="gd3be25cd08e898319e14cce69580992e"></a><!-- doxytag: member="svn_fs.h::svn_fs_node_created_rev" ref="gd3be25cd08e898319e14cce69580992e" args="(svn_revnum_t *revision, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_created_rev           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *&nbsp;</td>
          <td class="paramname"> <em>revision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*revision</em> to the revision in which <em>path</em> under <em>root</em> was created. 
<p>
Use <em>pool</em> for any temporary allocations. <em>*revision</em> will be set to <code>SVN_INVALID_REVNUM</code> for uncommitted nodes (i.e. modified nodes under a transaction root). Note that the root of an unmodified transaction is not itself considered to be modified; in that case, return the revision upon which the transaction was based. 
</div>
</div><p>
<a class="anchor" name="g2412ddc868b0ef6cdbbe3b682827885e"></a><!-- doxytag: member="svn_fs.h::svn_fs_node_history" ref="g2412ddc868b0ef6cdbbe3b682827885e" args="(svn_fs_history_t **history_p, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_history           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#ga31b679ed9ca7b53241ebda04c035140">svn_fs_history_t</a> **&nbsp;</td>
          <td class="paramname"> <em>history_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*history_p</em> to an opaque node history object which represents <em>path</em> under <em>root</em>. 
<p>
<em>root</em> must be a revision root. Use <em>pool</em> for all allocations. 
</div>
</div><p>
<a class="anchor" name="gf59a66cf510e6da06dadfe2b3bb372e1"></a><!-- doxytag: member="svn_fs.h::svn_fs_node_id" ref="gf59a66cf510e6da06dadfe2b3bb372e1" args="(const svn_fs_id_t **id_p, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_id           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__svn__fs__nodes.html#geca8f1c373c50ca7bb08e3417242b106">svn_fs_id_t</a> **&nbsp;</td>
          <td class="paramname"> <em>id_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the id of a node. 
<p>
Set <em>*id_p</em> to the node revision ID of <em>path</em> in <em>root</em>, allocated in <em>pool</em>.<p>
If <em>root</em> is the root of a transaction, keep in mind that other changes to the transaction can change which node <em>path</em> refers to, and even whether the path exists at all. 
</div>
</div><p>
<a class="anchor" name="gf26ebca946019f3761f48ad8dadd6eaa"></a><!-- doxytag: member="svn_fs.h::svn_fs_node_origin_rev" ref="gf26ebca946019f3761f48ad8dadd6eaa" args="(svn_revnum_t *revision, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_origin_rev           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *&nbsp;</td>
          <td class="paramname"> <em>revision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*revision</em> to the revision in which the line of history represented by <em>path</em> under <em>root</em> originated. 
<p>
Use <em>pool</em> for any temporary allocations. If <em>root</em> is a transaction root, <em>*revision</em> will be set to <code>SVN_INVALID_REVNUM</code> for any nodes newly added in that transaction (brand new files or directories created using <code>svn_fs_make_dir</code> or <code>svn_fs_make_file</code>).<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g830b554597da876e1b6256f2836cf349"></a><!-- doxytag: member="svn_fs.h::svn_fs_node_prop" ref="g830b554597da876e1b6256f2836cf349" args="(svn_string_t **value_p, svn_fs_root_t *root, const char *path, const char *propname, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_prop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__string__t.html">svn_string_t</a> **&nbsp;</td>
          <td class="paramname"> <em>value_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>propname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*value_p</em> to the value of the property named <em>propname</em> of <em>path</em> in <em>root</em>. 
<p>
If the node has no property by that name, set <em>*value_p</em> to zero. Allocate the result in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="g079534da68d59ac24307ae171189dd61"></a><!-- doxytag: member="svn_fs.h::svn_fs_node_proplist" ref="g079534da68d59ac24307ae171189dd61" args="(apr_hash_t **table_p, svn_fs_root_t *root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_node_proplist           </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&nbsp;</td>
          <td class="paramname"> <em>table_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*table_p</em> to the entire property list of <em>path</em> in <em>root</em>, as an APR hash table allocated in <em>pool</em>. 
<p>
The resulting table maps property names to pointers to <code><a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a></code> objects containing the property value. 
</div>
</div><p>
<a class="anchor" name="gf31aff19f6ddd70e665235ff1857fc35"></a><!-- doxytag: member="svn_fs.h::svn_fs_open" ref="gf31aff19f6ddd70e665235ff1857fc35" args="(svn_fs_t **fs_p, const char *path, apr_hash_t *fs_config, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_open           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> **&nbsp;</td>
          <td class="paramname"> <em>fs_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_hash_t *&nbsp;</td>
          <td class="paramname"> <em>fs_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open a Subversion filesystem located in the directory <em>path</em>, and return a pointer to it in <em>*fs_p</em>. 
<p>
If <em>fs_config</em> is not <code>NULL</code>, the options it contains modify the behavior of the filesystem. The interpretation of <em>fs_config</em> is specific to the filesystem back-end. The opened filesystem may be closed by destroying <em>pool</em>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The lifetime of <em>fs_config</em> must not be shorter than <em>pool's</em>. It's a good idea to allocate <em>fs_config</em> from <em>pool</em> or one of its ancestors.</dd></dl>
Only one thread may operate on any given filesystem object at once. Two threads may access the same filesystem simultaneously only if they open separate filesystem objects.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>You probably don't want to use this directly. Take a look at <a class="el" href="svn__repos_8h.html#2703b5e8f427145961f794c1abe4fa11" title="Set *repos_p to a repository object for the repository at path.">svn_repos_open()</a> instead.</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga1a79172a1faa38b234d365240079c3a"></a><!-- doxytag: member="svn_fs.h::svn_fs_path" ref="ga1a79172a1faa38b234d365240079c3a" args="(svn_fs_t *fs, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_fs_path           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the path to <em>fs's</em> repository, allocated in <em>pool</em>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This is just what was passed to <a class="el" href="group__fs__handling.html#g24b9cee11c6d584ddb0b9d74efca5dd5" title="Create a new, empty Subversion filesystem, stored in the directory path, and return...">svn_fs_create()</a> or <a class="el" href="group__fs__handling.html#gf31aff19f6ddd70e665235ff1857fc35" title="Open a Subversion filesystem located in the directory path, and return a pointer...">svn_fs_open()</a> -- might be absolute, might not.</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g26cf98c986a0f71fe9d86be0f73266b6"></a><!-- doxytag: member="svn_fs.h::svn_fs_print_modules" ref="g26cf98c986a0f71fe9d86be0f73266b6" args="(svn_stringbuf_t *output, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_print_modules           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append a textual list of all available FS modules to the stringbuf <em>output</em>. 
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.2. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gac7c1a6f4732d24a8ee387abb33e33dc"></a><!-- doxytag: member="svn_fs.h::svn_fs_props_changed" ref="gac7c1a6f4732d24a8ee387abb33e33dc" args="(svn_boolean_t *changed_p, svn_fs_root_t *root1, const char *path1, svn_fs_root_t *root2, const char *path2, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_props_changed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> *&nbsp;</td>
          <td class="paramname"> <em>changed_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>root2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine if the properties of two path/root combinations are different. 
<p>
Set <em>*changed_p</em> to 1 if the properties at <em>path1</em> under <em>root1</em> differ from those at <em>path2</em> under <em>root2</em>, or set it to 0 if they are the same. Both paths must exist under their respective roots, and both roots must be in the same filesystem. 
</div>
</div><p>
<a class="anchor" name="gf6f1f42958e3f56326185b91fc1ae679"></a><!-- doxytag: member="svn_fs.h::svn_fs_recover" ref="gf6f1f42958e3f56326185b91fc1ae679" args="(const char *path, svn_cancel_func_t cancel_func, void *cancel_baton, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_recover           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#ddaab83431a3d41b6c62e9d501cd5ecc">svn_cancel_func_t</a>&nbsp;</td>
          <td class="paramname"> <em>cancel_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cancel_baton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform any necessary non-catastrophic recovery on the Subversion filesystem located at <em>path</em>. 
<p>
If <em>cancel_func</em> is not <code>NULL</code>, it is called periodically with <em>cancel_baton</em> as argument to see if the client wishes to cancel recovery. BDB filesystems do not currently support cancellation.<p>
Do any necessary allocation within <em>pool</em>.<p>
For FSFS filesystems, recovery is currently limited to recreating the db/current file, and does not require exclusive access.<p>
For BDB filesystems, recovery requires exclusive access, and is described in detail below.<p>
After an unexpected server exit, due to a server crash or a system crash, a Subversion filesystem based on Berkeley DB needs to run recovery procedures to bring the database back into a consistent state and release any locks that were held by the deceased process. The recovery procedures require exclusive access to the database --- while they execute, no other process or thread may access the database.<p>
In a server with multiple worker processes, like Apache, if a worker process accessing the filesystem dies, you must stop the other worker processes, and run recovery. Then, the other worker processes can re-open the database and resume work.<p>
If the server exited cleanly, there is no need to run recovery, but there is no harm in it, either, and it take very little time. So it's a fine idea to run recovery when the server process starts, before it begins handling any requests.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gddd7ec5b6e3306c609e46d4f5a2b8a5c"></a><!-- doxytag: member="svn_fs.h::svn_fs_revision_link" ref="gddd7ec5b6e3306c609e46d4f5a2b8a5c" args="(svn_fs_root_t *from_root, svn_fs_root_t *to_root, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_revision_link           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>from_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__svn__fs__roots.html#ga0616aebbe57398ec86bcb8a432248cd">svn_fs_root_t</a> *&nbsp;</td>
          <td class="paramname"> <em>to_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="group__fs__handling.html#g9da8e22bd1058f877a275099699bb86b" title="Create a copy of from_path in from_root named to_path in to_root.">svn_fs_copy()</a>, but doesn't record copy history, and preserves the PATH. 
<p>
You cannot use <a class="el" href="group__fs__handling.html#ged6116279287a80ec4f7de380a732f45" title="Discover a node&#39;s copy ancestry, if any.">svn_fs_copied_from()</a> later to find out where this copy came from.<p>
Use <a class="el" href="group__fs__handling.html#gddd7ec5b6e3306c609e46d4f5a2b8a5c" title="Like svn_fs_copy(), but doesn&#39;t record copy history, and preserves the PATH.">svn_fs_revision_link()</a> in situations where you don't care about the copy history, and where <em>to_path</em> and <em>from_path</em> are the same, because it is cheaper than <a class="el" href="group__fs__handling.html#g9da8e22bd1058f877a275099699bb86b" title="Create a copy of from_path in from_root named to_path in to_root.">svn_fs_copy()</a>. 
</div>
</div><p>
<a class="anchor" name="g0cd6959ee54cd16768477d608fd33c34"></a><!-- doxytag: member="svn_fs.h::svn_fs_revision_prop" ref="g0cd6959ee54cd16768477d608fd33c34" args="(svn_string_t **value_p, svn_fs_t *fs, svn_revnum_t rev, const char *propname, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_revision_prop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__string__t.html">svn_string_t</a> **&nbsp;</td>
          <td class="paramname"> <em>value_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&nbsp;</td>
          <td class="paramname"> <em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>propname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*value_p</em> to the value of the property named <em>propname</em> on revision <em>rev</em> in the filesystem <em>fs</em>. 
<p>
If <em>rev</em> has no property by that name, set <em>*value_p</em> to zero. Allocate the result in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="g423da8c30eacc9787ec7bc3dd1b9e351"></a><!-- doxytag: member="svn_fs.h::svn_fs_revision_proplist" ref="g423da8c30eacc9787ec7bc3dd1b9e351" args="(apr_hash_t **table_p, svn_fs_t *fs, svn_revnum_t rev, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_revision_proplist           </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&nbsp;</td>
          <td class="paramname"> <em>table_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a>&nbsp;</td>
          <td class="paramname"> <em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*table_p</em> to the entire property list of revision <em>rev</em> in filesystem <em>fs</em>, as an APR hash table allocated in <em>pool</em>. 
<p>
The table maps <code>char *</code> property names to <code><a class="el" href="structsvn__string__t.html" title="A simple counted string.">svn_string_t</a></code> * values; the names and values are allocated in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="gbec2453f61fb9356db9526d4c56f3a62"></a><!-- doxytag: member="svn_fs.h::svn_fs_set_uuid" ref="gbec2453f61fb9356db9526d4c56f3a62" args="(svn_fs_t *fs, const char *uuid, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_set_uuid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If not <code>NULL</code>, associate <em>*uuid</em> with <em>fs</em>. 
<p>
Otherwise (if <em>uuid</em> is <code>NULL</code>), generate a new UUID for <em>fs</em>. Use <em>pool</em> for any scratchwork. 
</div>
</div><p>
<a class="anchor" name="gbc881c866ebe2cbd41767374264532e8"></a><!-- doxytag: member="svn_fs.h::svn_fs_set_warning_func" ref="gbc881c866ebe2cbd41767374264532e8" args="(svn_fs_t *fs, svn_fs_warning_callback_t warning, void *warning_baton)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_fs_set_warning_func           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#gfa2c790fffb1abbd103c954a5d983646">svn_fs_warning_callback_t</a>&nbsp;</td>
          <td class="paramname"> <em>warning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>warning_baton</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provide a callback function, <em>warning</em>, that <em>fs</em> should use to report (non-fatal) errors. 
<p>
To print an error, the filesystem will call <em>warning</em>, passing it <em>warning_baton</em> and the error.<p>
By default, this is set to a function that will crash the process. Dumping to <code>stderr</code> or <code>/dev/tty</code> is not acceptable default behavior for server processes, since those may both be equivalent to <code>/dev/null</code>. 
</div>
</div><p>
<a class="anchor" name="ge771342c2800751277423c552cfeee48"></a><!-- doxytag: member="svn_fs.h::svn_fs_type" ref="ge771342c2800751277423c552cfeee48" args="(const char **fs_type, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_type           </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>fs_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return, in <em>*fs_type</em>, a string identifying the back-end type of the Subversion filesystem located in <em>path</em>. 
<p>
Allocate <em>*fs_type</em> in <em>pool</em>.<p>
The string should be equal to one of the <code>SVN_FS_TYPE_*</code> defined constants, unless the filesystem is a new back-end type added in a later version of Subversion.<p>
In general, the type should make no difference in the filesystem's semantics, but there are a few situations (such as backups) where it might matter.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g64cb2a37367de523f56b89e5ec603a73"></a><!-- doxytag: member="svn_fs.h::svn_fs_upgrade" ref="g64cb2a37367de523f56b89e5ec603a73" args="(const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_upgrade           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Upgrade the Subversion filesystem located in the directory <em>path</em> to the latest version supported by this library. 
<p>
Return <code>SVN_ERR_FS_UNSUPPORTED_UPGRADE</code> and make no changes to the filesystem if the requested upgrade is not supported. Use <em>pool</em> for necessary allocations.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>You probably don't want to use this directly. Take a look at <a class="el" href="svn__repos_8h.html#fa89fd30c6a04e09d025bcf1e30148cd" title="Upgrade the Subversion repository (and its underlying versioned filesystem) located...">svn_repos_upgrade()</a> instead.</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4af11f84095941c21fad6e22f62dd31d"></a><!-- doxytag: member="svn_fs.h::svn_fs_youngest_rev" ref="g4af11f84095941c21fad6e22f62dd31d" args="(svn_revnum_t *youngest_p, svn_fs_t *fs, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_fs_youngest_rev           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#f16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> *&nbsp;</td>
          <td class="paramname"> <em>youngest_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fs__handling.html#g2419fff1bb2c1e523b00e276ed3862e3">svn_fs_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <em>*youngest_p</em> to the number of the youngest revision in filesystem <em>fs</em>. 
<p>
Use <em>pool</em> for all temporary allocation.<p>
The oldest revision in any filesystem is numbered zero. 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 24 16:18:29 2008 for Subversion by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
