<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Subversion: svn_path.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>svn_path.h File Reference</h1>A path manipulation library. <a href="#_details">More...</a>
<p>
<code>#include &lt;apr_pools.h&gt;</code><br>
<code>#include &lt;apr_tables.h&gt;</code><br>
<code>#include &quot;<a class="el" href="svn__string_8h-source.html">svn_string.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="svn__error_8h-source.html">svn_error.h</a>&quot;</code><br>

<p>
<a href="svn__path_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#9b002c8492b3f42010ce194bc4fe9674">svn_path_internal_style</a> (const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert <em>path</em> from the local style to the canonical internal style.  <a href="#9b002c8492b3f42010ce194bc4fe9674"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#12c6078657e62c3fa5a7c27c842f533e">svn_path_local_style</a> (const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert <em>path</em> from the canonical internal style to the local style.  <a href="#12c6078657e62c3fa5a7c27c842f533e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#a2d6c1ad05e2e71d91981b63a313a9d9">svn_path_join</a> (const char *base, const char *component, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Join a base path (<em>base</em>) with a component (<em>component</em>), allocated in <em>pool</em>.  <a href="#a2d6c1ad05e2e71d91981b63a313a9d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#8b124175ae26b1a3b04964cb3b4fce47">svn_path_join_many</a> (apr_pool_t *pool, const char *base,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Join multiple components onto a <em>base</em> path, allocated in <em>pool</em>.  <a href="#8b124175ae26b1a3b04964cb3b4fce47"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#5f92b0550594a647cb1aa2bf459905a0">svn_path_basename</a> (const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the basename of the specified canonicalized <em>path</em>.  <a href="#5f92b0550594a647cb1aa2bf459905a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#27b1486db97591805fb513a1c73014c3">svn_path_dirname</a> (const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the dirname of the specified canonicalized <em>path</em>, defined as the path with its basename removed.  <a href="#27b1486db97591805fb513a1c73014c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#9213e8c2c819ef1e78376bdeece0610f">svn_path_splitext</a> (const char **path_root, const char **path_ext, const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split <em>path</em> into a root portion and an extension such that the root + the extension = the original path, and where the extension contains no period (.  <a href="#9213e8c2c819ef1e78376bdeece0610f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">apr_size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#e917e0db36f1e329e210ef3192b4deaf">svn_path_component_count</a> (const char *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of components in the canonicalized <em>path</em>.  <a href="#e917e0db36f1e329e210ef3192b4deaf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#f9aa1a5c802b9adaeffdf7cfb742350f">svn_path_add_component</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *path, const char *component)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a <em>component</em> (a NULL-terminated C-string) to the canonicalized <em>path</em>.  <a href="#f9aa1a5c802b9adaeffdf7cfb742350f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#a8cd686d60f29900e6f2400650c9b65d">svn_path_remove_component</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove one component off the end of the canonicalized <em>path</em>.  <a href="#a8cd686d60f29900e6f2400650c9b65d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#deabdc440c35448dc47d540a0fe71a12">svn_path_remove_components</a> (<a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *path, apr_size_t n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove <em>n</em> components off the end of the canonicalized <em>path</em>.  <a href="#deabdc440c35448dc47d540a0fe71a12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#0bc6d306f3c26daa29a689ce0c8173aa">svn_path_split</a> (const char *path, const char **dirpath, const char **base_name, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Divide the canonicalized <em>path</em> into <em>*dirpath</em> and <em>*base_name</em>, allocated in <em>pool</em>.  <a href="#0bc6d306f3c26daa29a689ce0c8173aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="86520f916cb63f8923af5aa40f43e091"></a><!-- doxytag: member="svn_path.h::svn_path_is_empty" ref="86520f916cb63f8923af5aa40f43e091" args="(const char *path)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#86520f916cb63f8923af5aa40f43e091">svn_path_is_empty</a> (const char *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return non-zero iff <em>path</em> is empty ("") or represents the current directory -- that is, if prepending it as a component to an existing path would result in no meaningful change. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#b28eb607dfb4fe7137b2e633f9e0604f">svn_dirent_is_root</a> (const char *dirent, apr_size_t len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return TRUE if <em>directory</em> is considered a root directory on the platform at hand, amongst which '/' on all platforms or 'X:/', '\\?\X:/', '\\.  <a href="#b28eb607dfb4fe7137b2e633f9e0604f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#71d5716a18e04df175633a65ddac7809">svn_path_canonicalize</a> (const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a new path (or URL) like <em>path</em>, but transformed such that some types of path specification redundancies are removed.  <a href="#71d5716a18e04df175633a65ddac7809"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#ee225e4d7950ad37dc1d2aad8f8411ef">svn_path_is_canonical</a> (const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>TRUE</code> iff path is canonical.  <a href="#ee225e4d7950ad37dc1d2aad8f8411ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="64b511c3c7ba94ab18090effbb5b8714"></a><!-- doxytag: member="svn_path.h::svn_path_compare_paths" ref="64b511c3c7ba94ab18090effbb5b8714" args="(const char *path1, const char *path2)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#64b511c3c7ba94ab18090effbb5b8714">svn_path_compare_paths</a> (const char *path1, const char *path2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an integer greater than, equal to, or less than 0, according as <em>path1</em> is greater than, equal to, or less than <em>path2</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#fc8d6c6604ebbe04537a5cfe0405138e">svn_path_get_longest_ancestor</a> (const char *path1, const char *path2, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the longest common path shared by two canonicalized paths, <em>path1</em> and <em>path2</em>.  <a href="#fc8d6c6604ebbe04537a5cfe0405138e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#d485d86ddbb7f8b07857a4992e243aae">svn_path_get_absolute</a> (const char **pabsolute, const char *relative, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert <em>relative</em> canonicalized path to an absolute path and return the results in <em>*pabsolute</em>, allocated in <em>pool</em>.  <a href="#d485d86ddbb7f8b07857a4992e243aae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#116fa3935551000e0ad1a478fdb42057">svn_path_split_if_file</a> (const char *path, const char **pdirectory, const char **pfile, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the path part of the canonicalized <em>path</em> in <em>*pdirectory</em>, and the file part in <em>*pfile</em>.  <a href="#116fa3935551000e0ad1a478fdb42057"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#336e77861107b3b14ac3e42c356727ab">svn_path_condense_targets</a> (const char **pcommon, apr_array_header_t **pcondensed_targets, const apr_array_header_t *targets, <a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> remove_redundancies, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the common prefix of the canonicalized paths in <em>targets</em> (an array of <code>const char *</code>'s), and remove redundant paths if <em>remove_redundancies</em> is TRUE.  <a href="#336e77861107b3b14ac3e42c356727ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#fa349ae99101a8be8fec7c2b514e3d8f">svn_path_remove_redundancies</a> (apr_array_header_t **pcondensed_targets, const apr_array_header_t *targets, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a list of canonicalized <em>targets</em>, one at a time, into <em>pcondensed_targets</em>, omitting any targets that are found earlier in the list, or whose ancestor is found earlier in the list.  <a href="#fa349ae99101a8be8fec7c2b514e3d8f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">apr_array_header_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#ed307c7a409271407b44c6edc50a4313">svn_path_decompose</a> (const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decompose the canonicalized <em>path</em> into an array of <code>const char *</code> components, allocated in <em>pool</em>.  <a href="#ed307c7a409271407b44c6edc50a4313"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#2c2280945af53502c92180e12cb23365">svn_path_compose</a> (const apr_array_header_t *components, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Join an array of <code>const char *</code> components into a '/' separated path, allocated in <em>pool</em>.  <a href="#2c2280945af53502c92180e12cb23365"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#0fba1793cc2fd35254b86dbfdfd5bd10">svn_path_is_single_path_component</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test that <em>name</em> is a single path component, that is:<ul>
<li>not <code>NULL</code> or empty. </li></ul>
 <a href="#0fba1793cc2fd35254b86dbfdfd5bd10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#2e27f0f689e3cd85f023b43c2a02158d">svn_path_is_backpath_present</a> (const char *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test to see if a backpath, i.e.  <a href="#2e27f0f689e3cd85f023b43c2a02158d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#723fa9b91b516a3f4057877396f17c85">svn_path_is_child</a> (const char *path1, const char *path2, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if <em>path2</em> is a child of <em>path1</em>.  <a href="#723fa9b91b516a3f4057877396f17c85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#a3f82e432465ad05ea28dcb9ab3d231e">svn_path_is_ancestor</a> (const char *path1, const char *path2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return TRUE if <em>path1</em> is an ancestor of <em>path2</em> or the paths are equal and FALSE otherwise.  <a href="#a3f82e432465ad05ea28dcb9ab3d231e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svn__path_8h.html#66126b95ddaa72ad601b2262c6cd2f6c">svn_path_check_valid</a> (const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether <em>path</em> is a valid Subversion path.  <a href="#66126b95ddaa72ad601b2262c6cd2f6c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__uri__stuff.html#gdc3807ba2b493fcbfcf21d783ea916c0">svn_path_is_url</a> (const char *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return TRUE iff <em>path</em> looks like a valid absolute URL.  <a href="group__svn__path__uri__stuff.html#gdc3807ba2b493fcbfcf21d783ea916c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__uri__stuff.html#g4cf332a76cc511b00ef847b9b59633ee">svn_path_is_uri_safe</a> (const char *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>TRUE</code> iff <em>path</em> is URI-safe, <code>FALSE</code> otherwise.  <a href="group__svn__path__uri__stuff.html#g4cf332a76cc511b00ef847b9b59633ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__uri__stuff.html#g1f2ce01ef7e239a37baad42b40d556e5">svn_path_uri_encode</a> (const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a URI-encoded copy of <em>path</em>, allocated in <em>pool</em>.  <a href="group__svn__path__uri__stuff.html#g1f2ce01ef7e239a37baad42b40d556e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__uri__stuff.html#ge7cd4fc1524784c72709fd55f1d79c88">svn_path_uri_decode</a> (const char *path, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a URI-decoded copy of <em>path</em>, allocated in <em>pool</em>.  <a href="group__svn__path__uri__stuff.html#ge7cd4fc1524784c72709fd55f1d79c88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__uri__stuff.html#g1522f308378a4a74c3d53565f627145f">svn_path_url_add_component</a> (const char *url, const char *component, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extend <em>url</em> by <em>component</em>, URI-encoding that <em>component</em> before adding it to the <em>url</em>; return the new <em>url</em>, allocated in <em>pool</em>.  <a href="group__svn__path__uri__stuff.html#g1522f308378a4a74c3d53565f627145f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__uri__stuff.html#g4c2ae9dba439035b284799fd1f5f1395">svn_path_uri_from_iri</a> (const char *iri, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert <em>iri</em> (Internationalized URI) to an URI.  <a href="group__svn__path__uri__stuff.html#g4c2ae9dba439035b284799fd1f5f1395"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__uri__stuff.html#gcd52658595e60c5b6a7d989e8f92ecef">svn_path_uri_autoescape</a> (const char *uri, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">URI-encode certain characters in <em>uri</em> that are not valid in an URI, but doesn't have any special meaning in <em>uri</em> at their positions.  <a href="group__svn__path__uri__stuff.html#gcd52658595e60c5b6a7d989e8f92ecef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__charset__stuff.html#g1188b3d68c589e2ef820d785627813e3">svn_path_cstring_from_utf8</a> (const char **path_apr, const char *path_utf8, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert <em>path_utf8</em> from UTF-8 to the internal encoding used by APR.  <a href="group__svn__path__charset__stuff.html#g1188b3d68c589e2ef820d785627813e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__svn__path__charset__stuff.html#g624b2bd834e1dcbd4d7c05b348f5e5f6">svn_path_cstring_to_utf8</a> (const char **path_utf8, const char *path_apr, apr_pool_t *pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert <em>path_apr</em> from the internal encoding used by APR to UTF-8.  <a href="group__svn__path__charset__stuff.html#g624b2bd834e1dcbd4d7c05b348f5e5f6"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A path manipulation library. 
<p>
All incoming and outgoing paths are non-NULL and in UTF-8, unless otherwise documented.<p>
No result path ever ends with a separator, no matter whether the path is a file or directory, because we always canonicalize() it.<p>
Nearly all the <code>svn_path_xxx</code> functions expect paths passed into them to be in canonical form as defined by the Subversion path library itself. The only functions which do *not* have such expectations are:<p>
<ul>
<li><code><a class="el" href="svn__path_8h.html#71d5716a18e04df175633a65ddac7809" title="Return a new path (or URL) like path, but transformed such that some types of path...">svn_path_canonicalize()</a></code> </li><li><code><a class="el" href="svn__path_8h.html#ee225e4d7950ad37dc1d2aad8f8411ef" title="Return TRUE iff path is canonical.">svn_path_is_canonical()</a></code> </li><li><code><a class="el" href="svn__path_8h.html#9b002c8492b3f42010ce194bc4fe9674" title="Convert path from the local style to the canonical internal style.">svn_path_internal_style()</a></code> </li></ul>
<p>
For the most part, we mean what most anyone would mean when talking about canonical paths, but to be on the safe side, you must run your paths through <code><a class="el" href="svn__path_8h.html#71d5716a18e04df175633a65ddac7809" title="Return a new path (or URL) like path, but transformed such that some types of path...">svn_path_canonicalize()</a></code> before passing them to other functions in this API. 
<p>Definition in file <a class="el" href="svn__path_8h-source.html">svn_path.h</a>.</p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="b28eb607dfb4fe7137b2e633f9e0604f"></a><!-- doxytag: member="svn_path.h::svn_dirent_is_root" ref="b28eb607dfb4fe7137b2e633f9e0604f" args="(const char *dirent, apr_size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_dirent_is_root           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dirent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return TRUE if <em>directory</em> is considered a root directory on the platform at hand, amongst which '/' on all platforms or 'X:/', '\\?\X:/', '\\. 
<p>
\..', '\\server\share' on Windows.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f9aa1a5c802b9adaeffdf7cfb742350f"></a><!-- doxytag: member="svn_path.h::svn_path_add_component" ref="f9aa1a5c802b9adaeffdf7cfb742350f" args="(svn_stringbuf_t *path, const char *component)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_path_add_component           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>component</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a <em>component</em> (a NULL-terminated C-string) to the canonicalized <em>path</em>. 
<p>
<em>component</em> is allowed to contain directory separators.<p>
If <em>path</em> is non-empty, append the appropriate directory separator character, and then <em>component</em>. If <em>path</em> is empty, simply set it to <em>component</em>; don't add any separator character.<p>
If the result ends in a separator character, then remove the separator. 
</div>
</div><p>
<a class="anchor" name="5f92b0550594a647cb1aa2bf459905a0"></a><!-- doxytag: member="svn_path.h::svn_path_basename" ref="5f92b0550594a647cb1aa2bf459905a0" args="(const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* svn_path_basename           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the basename of the specified canonicalized <em>path</em>. 
<p>
The basename is defined as the last component of the path (ignoring any trailing slashes). If the <em>path</em> is root ("/"), then that is returned. Otherwise, the returned value will have no slashes in it.<p>
Example: svn_path_basename("/foo/bar") -&gt; "bar"<p>
The returned basename will be allocated in <em>pool</em>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If an empty string is passed, then an empty string will be returned. </dd></dl>

</div>
</div><p>
<a class="anchor" name="71d5716a18e04df175633a65ddac7809"></a><!-- doxytag: member="svn_path.h::svn_path_canonicalize" ref="71d5716a18e04df175633a65ddac7809" args="(const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_path_canonicalize           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a new path (or URL) like <em>path</em>, but transformed such that some types of path specification redundancies are removed. 
<p>
This involves collapsing redundant "/./" elements, removing multiple adjacent separator characters, removing trailing separator characters, and possibly other semantically inoperative transformations.<p>
The returned path may be statically allocated, equal to <em>path</em>, or allocated from <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="66126b95ddaa72ad601b2262c6cd2f6c"></a><!-- doxytag: member="svn_path.h::svn_path_check_valid" ref="66126b95ddaa72ad601b2262c6cd2f6c" args="(const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_path_check_valid           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check whether <em>path</em> is a valid Subversion path. 
<p>
A valid Subversion pathname is a UTF-8 string without control characters. "Valid" means Subversion can store the pathname in a repository. There may be other, OS-specific, limitations on what paths can be represented in a working copy.<p>
ASSUMPTION: <em>path</em> is a valid UTF-8 string. This function does not check UTF-8 validity.<p>
Return <code>SVN_NO_ERROR</code> if valid and <code>SVN_ERR_FS_PATH_SYNTAX</code> if invalid.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.2. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e917e0db36f1e329e210ef3192b4deaf"></a><!-- doxytag: member="svn_path.h::svn_path_component_count" ref="e917e0db36f1e329e210ef3192b4deaf" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_size_t svn_path_component_count           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of components in the canonicalized <em>path</em>. 
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2c2280945af53502c92180e12cb23365"></a><!-- doxytag: member="svn_path.h::svn_path_compose" ref="2c2280945af53502c92180e12cb23365" args="(const apr_array_header_t *components, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_path_compose           </td>
          <td>(</td>
          <td class="paramtype">const apr_array_header_t *&nbsp;</td>
          <td class="paramname"> <em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Join an array of <code>const char *</code> components into a '/' separated path, allocated in <em>pool</em>. 
<p>
The joined path is absolute if the first component is a lone dir separator.<p>
Calling <a class="el" href="svn__path_8h.html#2c2280945af53502c92180e12cb23365" title="Join an array of const char * components into a &#39;/&#39; separated path, allocated...">svn_path_compose()</a> on the output of <a class="el" href="svn__path_8h.html#ed307c7a409271407b44c6edc50a4313" title="Decompose the canonicalized path into an array of const char * components, allocated...">svn_path_decompose()</a> will return the exact same path.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div><p>
<a class="anchor" name="336e77861107b3b14ac3e42c356727ab"></a><!-- doxytag: member="svn_path.h::svn_path_condense_targets" ref="336e77861107b3b14ac3e42c356727ab" args="(const char **pcommon, apr_array_header_t **pcondensed_targets, const apr_array_header_t *targets, svn_boolean_t remove_redundancies, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_path_condense_targets           </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>pcommon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_array_header_t **&nbsp;</td>
          <td class="paramname"> <em>pcondensed_targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&nbsp;</td>
          <td class="paramname"> <em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a>&nbsp;</td>
          <td class="paramname"> <em>remove_redundancies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the common prefix of the canonicalized paths in <em>targets</em> (an array of <code>const char *</code>'s), and remove redundant paths if <em>remove_redundancies</em> is TRUE. 
<p>
<ul>
<li>Set <em>*pcommon</em> to the absolute path of the path or URL common to all of the targets. If the targets have no common prefix, or are a mix of URLs and local paths, set <em>*pcommon</em> to the empty string.</li></ul>
<p>
<ul>
<li>If <em>pcondensed_targets</em> is non-NULL, set <em>*pcondensed_targets</em> to an array of targets relative to <em>*pcommon</em>, and if <em>remove_redundancies</em> is TRUE, omit any paths/URLs that are descendants of another path/URL in <em>targets</em>. If *pcommon is empty, <em>*pcondensed_targets</em> will contain full URLs and/or absolute paths; redundancies can still be removed (from both URLs and paths). If <em>pcondensed_targets</em> is NULL, leave it alone.</li></ul>
<p>
Else if there is exactly one target, then<p>
<ul>
<li>Set <em>*pcommon</em> to that target, and</li></ul>
<p>
<ul>
<li>If <em>pcondensed_targets</em> is non-NULL, set <em>*pcondensed_targets</em> to an array containing zero elements. Else if <em>pcondensed_targets</em> is NULL, leave it alone.</li></ul>
<p>
If there are no items in <em>targets</em>, set <em>*pcommon</em> and (if applicable) <em>*pcondensed_targets</em> to <code>NULL</code>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>There is no guarantee that <em>*pcommon</em> is within a working copy. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ed307c7a409271407b44c6edc50a4313"></a><!-- doxytag: member="svn_path.h::svn_path_decompose" ref="ed307c7a409271407b44c6edc50a4313" args="(const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_array_header_t* svn_path_decompose           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decompose the canonicalized <em>path</em> into an array of <code>const char *</code> components, allocated in <em>pool</em>. 
<p>
If <em>path</em> is absolute, the first component will be a lone dir separator (the root directory). 
</div>
</div><p>
<a class="anchor" name="27b1486db97591805fb513a1c73014c3"></a><!-- doxytag: member="svn_path.h::svn_path_dirname" ref="27b1486db97591805fb513a1c73014c3" args="(const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* svn_path_dirname           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the dirname of the specified canonicalized <em>path</em>, defined as the path with its basename removed. 
<p>
Get the dirname of the specified <em>path</em>, defined as the path with its basename removed. If <em>path</em> is root ("/"), it is returned unchanged.<p>
The returned dirname will be allocated in <em>pool</em>. 
</div>
</div><p>
<a class="anchor" name="d485d86ddbb7f8b07857a4992e243aae"></a><!-- doxytag: member="svn_path.h::svn_path_get_absolute" ref="d485d86ddbb7f8b07857a4992e243aae" args="(const char **pabsolute, const char *relative, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_path_get_absolute           </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>pabsolute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>relative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert <em>relative</em> canonicalized path to an absolute path and return the results in <em>*pabsolute</em>, allocated in <em>pool</em>. 
<p>
<em>relative</em> may be a URL, in which case no attempt is made to convert it, and a copy of the URL is returned. 
</div>
</div><p>
<a class="anchor" name="fc8d6c6604ebbe04537a5cfe0405138e"></a><!-- doxytag: member="svn_path.h::svn_path_get_longest_ancestor" ref="fc8d6c6604ebbe04537a5cfe0405138e" args="(const char *path1, const char *path2, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* svn_path_get_longest_ancestor           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the longest common path shared by two canonicalized paths, <em>path1</em> and <em>path2</em>. 
<p>
If there's no common ancestor, return the empty path.<p>
<em>path1</em> and <em>path2</em> may be URLs. In order for two URLs to have a common ancestor, they must (a) have the same protocol (since two URLs with the same path but different protocols may point at completely different resources), and (b) share a common ancestor in their path component, i.e. 'protocol://' is not a sufficient ancestor. 
</div>
</div><p>
<a class="anchor" name="9b002c8492b3f42010ce194bc4fe9674"></a><!-- doxytag: member="svn_path.h::svn_path_internal_style" ref="9b002c8492b3f42010ce194bc4fe9674" args="(const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_path_internal_style           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert <em>path</em> from the local style to the canonical internal style. 
<p>

</div>
</div><p>
<a class="anchor" name="a3f82e432465ad05ea28dcb9ab3d231e"></a><!-- doxytag: member="svn_path.h::svn_path_is_ancestor" ref="a3f82e432465ad05ea28dcb9ab3d231e" args="(const char *path1, const char *path2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_path_is_ancestor           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return TRUE if <em>path1</em> is an ancestor of <em>path2</em> or the paths are equal and FALSE otherwise. 
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.3. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2e27f0f689e3cd85f023b43c2a02158d"></a><!-- doxytag: member="svn_path.h::svn_path_is_backpath_present" ref="2e27f0f689e3cd85f023b43c2a02158d" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_path_is_backpath_present           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test to see if a backpath, i.e. 
<p>
'..', is present in <em>path</em>. If not, return <code>FALSE</code>. If so, return <code>TRUE</code>.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ee225e4d7950ad37dc1d2aad8f8411ef"></a><!-- doxytag: member="svn_path.h::svn_path_is_canonical" ref="ee225e4d7950ad37dc1d2aad8f8411ef" args="(const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_path_is_canonical           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return <code>TRUE</code> iff path is canonical. 
<p>
Use <em>pool</em> for temporary allocations.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The test for canonicalization is currently defined as "looks exactly the same as <code><a class="el" href="svn__path_8h.html#71d5716a18e04df175633a65ddac7809" title="Return a new path (or URL) like path, but transformed such that some types of path...">svn_path_canonicalize()</a></code> would make it look".</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div><p>
<a class="anchor" name="723fa9b91b516a3f4057877396f17c85"></a><!-- doxytag: member="svn_path.h::svn_path_is_child" ref="723fa9b91b516a3f4057877396f17c85" args="(const char *path1, const char *path2, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_path_is_child           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test if <em>path2</em> is a child of <em>path1</em>. 
<p>
If not, return <code>NULL</code>. If so, return a copy of the remainder path, allocated in <em>pool</em>. (The remainder is the component which, added to <em>path1</em>, yields <em>path2</em>. The remainder does not begin with a dir separator.)<p>
Both paths must be in canonical form, and must either be absolute, or contain no ".." components.<p>
If <em>path2</em> is the same as <em>path1</em>, it is not considered a child, so the result is <code>NULL</code>; an empty string is never returned.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>In 1.5 this function has been extended to allow a <code>NULL</code> <em>pool</em> in which case a pointer into <em>path2</em> will be returned to identify the remainder path.</dd></dl>
### todo: the ".." restriction is unfortunate, and would ideally be lifted by making the implementation smarter. But this is not trivial: if the path is "../foo", how do you know whether or not the current directory is named "foo" in its parent? 
</div>
</div><p>
<a class="anchor" name="0fba1793cc2fd35254b86dbfdfd5bd10"></a><!-- doxytag: member="svn_path.h::svn_path_is_single_path_component" ref="0fba1793cc2fd35254b86dbfdfd5bd10" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="svn__types_8h.html#22b35baddc4213c688d1bb12feea1024">svn_boolean_t</a> svn_path_is_single_path_component           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test that <em>name</em> is a single path component, that is:<ul>
<li>not <code>NULL</code> or empty. </li></ul>

<p>
<ul>
<li>not a `/'-separated directory path</li><li>not empty or `..' </li></ul>

</div>
</div><p>
<a class="anchor" name="a2d6c1ad05e2e71d91981b63a313a9d9"></a><!-- doxytag: member="svn_path.h::svn_path_join" ref="a2d6c1ad05e2e71d91981b63a313a9d9" args="(const char *base, const char *component, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* svn_path_join           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Join a base path (<em>base</em>) with a component (<em>component</em>), allocated in <em>pool</em>. 
<p>
If either <em>base</em> or <em>component</em> is the empty path, then the other argument will be copied and returned. If both are the empty path the empty path is returned.<p>
If the <em>component</em> is an absolute path, then it is copied and returned. Exactly one slash character ('/') is used to joined the components, accounting for any trailing slash in <em>base</em>.<p>
Note that the contents of <em>base</em> are not examined, so it is possible to use this function for constructing URLs, or for relative URLs or repository paths.<p>
This function is NOT appropriate for native (local) file paths. Only for "internal" canonicalized paths, since it uses '/' for the separator. Further, an absolute path (for <em>component</em>) is based on a leading '/' character. Thus, an "absolute URI" for the <em>component</em> won't be detected. An absolute URI can only be used for the base. 
</div>
</div><p>
<a class="anchor" name="8b124175ae26b1a3b04964cb3b4fce47"></a><!-- doxytag: member="svn_path.h::svn_path_join_many" ref="8b124175ae26b1a3b04964cb3b4fce47" args="(apr_pool_t *pool, const char *base,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* svn_path_join_many           </td>
          <td>(</td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Join multiple components onto a <em>base</em> path, allocated in <em>pool</em>. 
<p>
The components are terminated by a <code>NULL</code>.<p>
If any component is the empty string, it will be ignored.<p>
If any component is an absolute path, then it resets the base and further components will be appended to it.<p>
See <a class="el" href="svn__path_8h.html#a2d6c1ad05e2e71d91981b63a313a9d9" title="Join a base path (base) with a component (component), allocated in pool.">svn_path_join()</a> for further notes about joining paths. 
</div>
</div><p>
<a class="anchor" name="12c6078657e62c3fa5a7c27c842f533e"></a><!-- doxytag: member="svn_path.h::svn_path_local_style" ref="12c6078657e62c3fa5a7c27c842f533e" args="(const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* svn_path_local_style           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert <em>path</em> from the canonical internal style to the local style. 
<p>

</div>
</div><p>
<a class="anchor" name="a8cd686d60f29900e6f2400650c9b65d"></a><!-- doxytag: member="svn_path.h::svn_path_remove_component" ref="a8cd686d60f29900e6f2400650c9b65d" args="(svn_stringbuf_t *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_path_remove_component           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>path</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove one component off the end of the canonicalized <em>path</em>. 
<p>

</div>
</div><p>
<a class="anchor" name="deabdc440c35448dc47d540a0fe71a12"></a><!-- doxytag: member="svn_path.h::svn_path_remove_components" ref="deabdc440c35448dc47d540a0fe71a12" args="(svn_stringbuf_t *path, apr_size_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_path_remove_components           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsvn__stringbuf__t.html">svn_stringbuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove <em>n</em> components off the end of the canonicalized <em>path</em>. 
<p>
Equivalent to calling <a class="el" href="svn__path_8h.html#a8cd686d60f29900e6f2400650c9b65d" title="Remove one component off the end of the canonicalized path.">svn_path_remove_component()</a> <em>n</em> times.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fa349ae99101a8be8fec7c2b514e3d8f"></a><!-- doxytag: member="svn_path.h::svn_path_remove_redundancies" ref="fa349ae99101a8be8fec7c2b514e3d8f" args="(apr_array_header_t **pcondensed_targets, const apr_array_header_t *targets, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_path_remove_redundancies           </td>
          <td>(</td>
          <td class="paramtype">apr_array_header_t **&nbsp;</td>
          <td class="paramname"> <em>pcondensed_targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_array_header_t *&nbsp;</td>
          <td class="paramname"> <em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy a list of canonicalized <em>targets</em>, one at a time, into <em>pcondensed_targets</em>, omitting any targets that are found earlier in the list, or whose ancestor is found earlier in the list. 
<p>
Ordering of targets in the original list is preserved in the condensed list of targets. Use <em>pool</em> for any allocations.<p>
How does this differ in functionality from <a class="el" href="svn__path_8h.html#336e77861107b3b14ac3e42c356727ab" title="Find the common prefix of the canonicalized paths in targets (an array of const char...">svn_path_condense_targets()</a>?<p>
Here's the short version:<p>
1. Disclaimer: if you wish to debate the following, talk to Karl. :-) Order matters for updates because a multi-arg update is not atomic, and CVS users are used to, when doing 'cvs up targetA targetB' seeing targetA get updated, then targetB. I think the idea is that if you're in a time-sensitive or flaky-network situation, a user can say, "I really *need* to update wc/A/D/G/tau, but I might as well update my whole working copy if I can." So that user will do 'svn up wc/A/D/G/tau wc', and if something dies in the middles of the 'wc' update, at least the user has 'tau' up-to-date.<p>
2. Also, we have this notion of an anchor and a target for updates (the anchor is where the update editor is rooted, the target is the actual thing we want to update). I needed a function that would NOT screw with my input paths so that I could tell the difference between someone being in A/D and saying 'svn up G' and being in A/D/G and saying 'svn up .' -- believe it or not, these two things don't mean the same thing. <a class="el" href="svn__path_8h.html#336e77861107b3b14ac3e42c356727ab" title="Find the common prefix of the canonicalized paths in targets (an array of const char...">svn_path_condense_targets()</a> plays with absolute paths (which is fine, so does <a class="el" href="svn__path_8h.html#fa349ae99101a8be8fec7c2b514e3d8f" title="Copy a list of canonicalized targets, one at a time, into pcondensed_targets, omitting...">svn_path_remove_redundancies()</a>), but the difference is that it actually tweaks those targets to be relative to the "grandfather path" common to all the targets. Updates don't require a "grandfather path" at all, and even if it did, the whole conversion to an absolute path drops the crucial difference between saying "i'm in foo, update bar" and "i'm in foo/bar, update '.'" 
</div>
</div><p>
<a class="anchor" name="0bc6d306f3c26daa29a689ce0c8173aa"></a><!-- doxytag: member="svn_path.h::svn_path_split" ref="0bc6d306f3c26daa29a689ce0c8173aa" args="(const char *path, const char **dirpath, const char **base_name, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_path_split           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>dirpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>base_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Divide the canonicalized <em>path</em> into <em>*dirpath</em> and <em>*base_name</em>, allocated in <em>pool</em>. 
<p>
If <em>dirpath</em> or <em>base_name</em> is NULL, then don't set that one.<p>
Either <em>dirpath</em> or <em>base_name</em> may be <em>path's</em> own address, but they may not both be the same address, or the results are undefined.<p>
If <em>path</em> has two or more components, the separator between <em>dirpath</em> and <em>base_name</em> is not included in either of the new names.<p>
examples:<ul>
<li><pre>"/foo/bar/baz"  ==&gt;  "/foo/bar" and "baz"</pre></li><li><pre>"/bar"          ==&gt;  "/"  and "bar"</pre></li><li><pre>"/"             ==&gt;  "/"  and "/"</pre></li><li><pre>"X:/"           ==&gt;  "X:/" and "X:/"</pre></li><li><pre>"bar"           ==&gt;  ""   and "bar"</pre></li><li><pre>""              ==&gt;  ""   and ""</pre> </li></ul>

</div>
</div><p>
<a class="anchor" name="116fa3935551000e0ad1a478fdb42057"></a><!-- doxytag: member="svn_path.h::svn_path_split_if_file" ref="116fa3935551000e0ad1a478fdb42057" args="(const char *path, const char **pdirectory, const char **pfile, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>* svn_path_split_if_file           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>pdirectory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>pfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the path part of the canonicalized <em>path</em> in <em>*pdirectory</em>, and the file part in <em>*pfile</em>. 
<p>
If <em>path</em> is a directory, set <em>*pdirectory</em> to <em>path</em>, and <em>*pfile</em> to the empty string. If <em>path</em> does not exist it is treated as if it is a file, since directories do not normally vanish. 
</div>
</div><p>
<a class="anchor" name="9213e8c2c819ef1e78376bdeece0610f"></a><!-- doxytag: member="svn_path.h::svn_path_splitext" ref="9213e8c2c819ef1e78376bdeece0610f" args="(const char **path_root, const char **path_ext, const char *path, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svn_path_splitext           </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>path_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>path_ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Split <em>path</em> into a root portion and an extension such that the root + the extension = the original path, and where the extension contains no period (. 
<p>
) characters. If not <code>NULL</code>, set <em>*path_root</em> to the root portion. If not <code>NULL</code>, set <em>*path_ext</em> to the extension (or "" if there is no extension found). Allocate both <em>*path_root</em> and <em>*path_ext</em> in <em>pool</em>.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>New in 1.5. </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 24 16:18:28 2008 for Subversion by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
